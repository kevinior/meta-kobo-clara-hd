From 909f2a7ef0e72a2f1696b8b6b88c700b4308c1fa Mon Sep 17 00:00:00 2001
From: Kevin O'Rourke <misc1-github@caboose.org.uk>
Date: Sun, 31 Jan 2021 11:30:53 +0100
Subject: [PATCH] Add Kobo Clara HD board.

---
 arch/arm/cpu/armv7/mx6/Kconfig                |    7 +
 board/freescale/mx6sll_kobo_clara_hd/Kconfig  |   12 +
 board/freescale/mx6sll_kobo_clara_hd/Makefile |   11 +
 .../mx6sll_kobo_clara_hd/imximage.cfg         |  127 +
 .../mx6sll_kobo_clara_hd/imximage_lpddr2.cfg  |  121 +
 .../imximage_lpddr2_512M.cfg                  |  121 +
 .../imximage_lpddr2_org.cfg                   |  127 +
 .../mx6sll_kobo_clara_hd.c                    |  893 +++++
 .../freescale/mx6sll_kobo_clara_hd/ntx_cmd.c  | 1775 ++++++++++
 .../freescale/mx6sll_kobo_clara_hd/ntx_comm.c | 3046 +++++++++++++++++
 .../freescale/mx6sll_kobo_clara_hd/ntx_comm.h |   80 +
 board/freescale/mx6sll_kobo_clara_hd/ntx_hw.c | 2299 +++++++++++++
 board/freescale/mx6sll_kobo_clara_hd/ntx_hw.h |   59 +
 .../mx6sll_kobo_clara_hd/ntx_hwconfig.h       |  364 ++
 .../freescale/mx6sll_kobo_clara_hd/ntx_pads.h |  140 +
 board/freescale/mx6sll_kobo_clara_hd/plugin.S |  283 ++
 configs/mx6sll_kobo_clara_hd_defconfig        |    7 +
 include/configs/mx6sll_kobo_clara_hd.h        |  267 ++
 18 files changed, 9739 insertions(+)
 create mode 100644 board/freescale/mx6sll_kobo_clara_hd/Kconfig
 create mode 100644 board/freescale/mx6sll_kobo_clara_hd/Makefile
 create mode 100644 board/freescale/mx6sll_kobo_clara_hd/imximage.cfg
 create mode 100644 board/freescale/mx6sll_kobo_clara_hd/imximage_lpddr2.cfg
 create mode 100644 board/freescale/mx6sll_kobo_clara_hd/imximage_lpddr2_512M.cfg
 create mode 100644 board/freescale/mx6sll_kobo_clara_hd/imximage_lpddr2_org.cfg
 create mode 100644 board/freescale/mx6sll_kobo_clara_hd/mx6sll_kobo_clara_hd.c
 create mode 100644 board/freescale/mx6sll_kobo_clara_hd/ntx_cmd.c
 create mode 100644 board/freescale/mx6sll_kobo_clara_hd/ntx_comm.c
 create mode 100644 board/freescale/mx6sll_kobo_clara_hd/ntx_comm.h
 create mode 100644 board/freescale/mx6sll_kobo_clara_hd/ntx_hw.c
 create mode 100644 board/freescale/mx6sll_kobo_clara_hd/ntx_hw.h
 create mode 100644 board/freescale/mx6sll_kobo_clara_hd/ntx_hwconfig.h
 create mode 100644 board/freescale/mx6sll_kobo_clara_hd/ntx_pads.h
 create mode 100644 board/freescale/mx6sll_kobo_clara_hd/plugin.S
 create mode 100644 configs/mx6sll_kobo_clara_hd_defconfig
 create mode 100644 include/configs/mx6sll_kobo_clara_hd.h

diff --git a/arch/arm/cpu/armv7/mx6/Kconfig b/arch/arm/cpu/armv7/mx6/Kconfig
index 289e9dca9d..574cbbcce3 100644
--- a/arch/arm/cpu/armv7/mx6/Kconfig
+++ b/arch/arm/cpu/armv7/mx6/Kconfig
@@ -120,6 +120,12 @@ config TARGET_MX6SLL_NTX
 	select DM
 	select DM_THERMAL
 
+config TARGET_MX6SLL_KOBO_CLARA_HD
+	bool "mx6sll Kobo Clara HD"
+	select MX6SLL
+	select DM
+	select DM_THERMAL
+
 config TARGET_MX6SL_NTX
 	bool "mx6sl ntx"
 	select MX6SL
@@ -277,6 +283,7 @@ source "board/freescale/mx6slevk/Kconfig"
 source "board/freescale/mx6sllevk/Kconfig"
 source "board/freescale/mx6sll_arm2/Kconfig"
 source "board/freescale/mx6sll_ntx/Kconfig"
+source "board/freescale/mx6sll_kobo_clara_hd/Kconfig"
 source "board/freescale/mx6sxsabresd/Kconfig"
 source "board/freescale/mx6sxsabreauto/Kconfig"
 source "board/freescale/mx6ul_14x14_evk/Kconfig"
diff --git a/board/freescale/mx6sll_kobo_clara_hd/Kconfig b/board/freescale/mx6sll_kobo_clara_hd/Kconfig
new file mode 100644
index 0000000000..64892418ee
--- /dev/null
+++ b/board/freescale/mx6sll_kobo_clara_hd/Kconfig
@@ -0,0 +1,12 @@
+if TARGET_MX6SLL_KOBO_CLARA_HD
+
+config SYS_BOARD
+	default "mx6sll_kobo_clara_hd"
+
+config SYS_VENDOR
+	default "freescale"
+
+config SYS_CONFIG_NAME
+	default "mx6sll_kobo_clara_hd"
+
+endif
diff --git a/board/freescale/mx6sll_kobo_clara_hd/Makefile b/board/freescale/mx6sll_kobo_clara_hd/Makefile
new file mode 100644
index 0000000000..6ee82b07d3
--- /dev/null
+++ b/board/freescale/mx6sll_kobo_clara_hd/Makefile
@@ -0,0 +1,11 @@
+# (C) Copyright 2016 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := mx6sll_kobo_clara_hd.o ntx_cmd.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
+
diff --git a/board/freescale/mx6sll_kobo_clara_hd/imximage.cfg b/board/freescale/mx6sll_kobo_clara_hd/imximage.cfg
new file mode 100644
index 0000000000..2b852982d3
--- /dev/null
+++ b/board/freescale/mx6sll_kobo_clara_hd/imximage.cfg
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+
+BOOT_FROM	sd
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6sll_ntx/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+/* Enable all clocks */
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+
+DATA 4 0x020E0550 0x00080000
+DATA 4 0x020E0534 0x00000000
+DATA 4 0x020E02AC 0x00000030
+DATA 4 0x020E0548 0x00000030
+DATA 4 0x020E052C 0x00000030
+DATA 4 0x020E0530 0x00020000
+DATA 4 0x020E02B0 0x00003030
+DATA 4 0x020E02B4 0x00003030
+DATA 4 0x020E02B8 0x00003030
+DATA 4 0x020E02BC 0x00003030
+DATA 4 0x020E0540 0x00020000
+DATA 4 0x020E0544 0x00000030
+DATA 4 0x020E054C 0x00000030
+DATA 4 0x020E0554 0x00000030
+DATA 4 0x020E0558 0x00000030
+DATA 4 0x020E0294 0x00000030
+DATA 4 0x020E0298 0x00000030
+DATA 4 0x020E029C 0x00000030
+DATA 4 0x020E02A0 0x00000030
+DATA 4 0x020E02C0 0x00082030
+
+DATA 4 0x021B001C 0x00008000
+
+DATA 4 0x021B0800 0xA1390003
+DATA 4 0x021B085c 0x084700C7
+DATA 4 0x021B0890 0x00400000
+DATA 4 0x021B0848 0x3C3A3C3C
+DATA 4 0x021B0850 0x24293625
+DATA 4 0x021B081C 0x33333333
+DATA 4 0x021B0820 0x33333333
+DATA 4 0x021B0824 0x33333333
+DATA 4 0x021B0828 0x33333333
+
+DATA 4 0x021B082C 0xf3333333
+DATA 4 0x021B0830 0xf3333333
+DATA 4 0x021B0834 0xf3333333
+DATA 4 0x021B0838 0xf3333333
+DATA 4 0x021B08C0 0x24922492
+DATA 4 0x021B08b8 0x00000800
+
+DATA 4 0x021B0004 0x00020052
+DATA 4 0x021B000C 0x53574333
+DATA 4 0x021B0010 0x00100B22
+DATA 4 0x021B0038 0x00170778
+DATA 4 0x021B0014 0x00C700DB
+DATA 4 0x021B0018 0x00201718
+DATA 4 0x021B002C 0x0F9F26D2
+DATA 4 0x021B0030 0x009F0E10
+DATA 4 0x021B0040 0x0000005F
+DATA 4 0x021B0000 0xC4190000
+
+DATA 4 0x021B083C 0x20000000
+
+DATA 4 0x021B001C 0x00008050
+DATA 4 0x021B001C 0x00008058
+DATA 4 0x021B001C 0x003F8030
+DATA 4 0x021B001C 0x003F8038
+DATA 4 0x021B001C 0xFF0A8030
+DATA 4 0x021B001C 0xFF0A8038
+DATA 4 0x021B001C 0x04028030
+DATA 4 0x021B001C 0x04028038
+DATA 4 0x021B001C 0x83018030
+DATA 4 0x021B001C 0x83018038
+DATA 4 0x021B001C 0x01038030
+DATA 4 0x021B001C 0x01038038
+
+DATA 4 0x021B0020 0x00001800
+DATA 4 0x021B0800 0xA1390003
+DATA 4 0x021B0004 0x00020052
+DATA 4 0x021B0404 0x00011006
+DATA 4 0x021B001C 0x00000000
+#endif
diff --git a/board/freescale/mx6sll_kobo_clara_hd/imximage_lpddr2.cfg b/board/freescale/mx6sll_kobo_clara_hd/imximage_lpddr2.cfg
new file mode 100644
index 0000000000..ce5b27a07c
--- /dev/null
+++ b/board/freescale/mx6sll_kobo_clara_hd/imximage_lpddr2.cfg
@@ -0,0 +1,121 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+
+BOOT_FROM	sd
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6sll_ntx/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+/* Enable all clocks */
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+
+DATA 4 0x020E0550 0x00080000
+DATA 4 0x020E0534 0x00000000
+DATA 4 0x020E02AC 0x00000030
+DATA 4 0x020E0548 0x00000030
+DATA 4 0x020E052C 0x00000030
+DATA 4 0x020E0530 0x00020000
+DATA 4 0x020E02B0 0x00003030
+DATA 4 0x020E02B4 0x00003030
+DATA 4 0x020E02B8 0x00003030
+DATA 4 0x020E02BC 0x00003030
+DATA 4 0x020E0540 0x00020000
+DATA 4 0x020E0544 0x00000030
+DATA 4 0x020E054C 0x00000030
+DATA 4 0x020E0554 0x00000030
+DATA 4 0x020E0558 0x00000030
+DATA 4 0x020E0294 0x00000030
+DATA 4 0x020E0298 0x00000030
+DATA 4 0x020E029C 0x00000030
+DATA 4 0x020E02A0 0x00000030
+DATA 4 0x020E02C0 0x00082030
+
+DATA 4 0x021B001C 0x00008000
+
+DATA 4 0x021B0800 0xA1390003
+DATA 4 0x021B085c 0x084700C7
+DATA 4 0x021B0890 0x00400000
+DATA 4 0x021B0848 0x42424442
+DATA 4 0x021B0850 0x2A303A2E
+DATA 4 0x021B081C 0x33333333
+DATA 4 0x021B0820 0x33333333
+DATA 4 0x021B0824 0x33333333
+DATA 4 0x021B0828 0x33333333
+
+DATA 4 0x021B082C 0xf3333333
+DATA 4 0x021B0830 0xf3333333
+DATA 4 0x021B0834 0xf3333333
+DATA 4 0x021B0838 0xf3333333
+DATA 4 0x021B08C0 0x24922492
+DATA 4 0x021B08b8 0x00000800
+
+DATA 4 0x021B0004 0x00020052
+DATA 4 0x021B000C 0x53574333
+DATA 4 0x021B0010 0x00100A82
+DATA 4 0x021B0038 0x00170777
+DATA 4 0x021B0014 0x00C70093
+DATA 4 0x021B0018 0x00201708
+DATA 4 0x021B002C 0x0F9F26D2
+DATA 4 0x021B0030 0x009F0E10
+DATA 4 0x021B0040 0x0000004F
+DATA 4 0x021B0000 0x83010000
+
+DATA 4 0x021B083C 0x20000000
+
+DATA 4 0x021B001C 0x00008050
+DATA 4 0x021B001C 0x003F8030
+DATA 4 0x021B001C 0xFF0A8030
+DATA 4 0x021B001C 0x04028030
+DATA 4 0x021B001C 0x82018030
+DATA 4 0x021B001C 0x01038030
+
+DATA 4 0x021B0020 0x00001800
+DATA 4 0x021B0800 0xA1390003
+DATA 4 0x021B0004 0x00020052
+DATA 4 0x021B0404 0x00011006
+DATA 4 0x021B001C 0x00000000
+#endif
diff --git a/board/freescale/mx6sll_kobo_clara_hd/imximage_lpddr2_512M.cfg b/board/freescale/mx6sll_kobo_clara_hd/imximage_lpddr2_512M.cfg
new file mode 100644
index 0000000000..821f2a5ccc
--- /dev/null
+++ b/board/freescale/mx6sll_kobo_clara_hd/imximage_lpddr2_512M.cfg
@@ -0,0 +1,121 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+
+BOOT_FROM	sd
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6sll_ntx/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+/* Enable all clocks */
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+
+DATA 4 0x020E0550 0x00080000
+DATA 4 0x020E0534 0x00000000
+DATA 4 0x020E02AC 0x00000028
+DATA 4 0x020E0548 0x00000030
+DATA 4 0x020E052C 0x00000030
+DATA 4 0x020E0530 0x00020000
+DATA 4 0x020E02B0 0x00003030
+DATA 4 0x020E02B4 0x00003030
+DATA 4 0x020E02B8 0x00003030
+DATA 4 0x020E02BC 0x00003030
+DATA 4 0x020E0540 0x00020000
+DATA 4 0x020E0544 0x00000030
+DATA 4 0x020E054C 0x00000030
+DATA 4 0x020E0554 0x00000030
+DATA 4 0x020E0558 0x00000030
+DATA 4 0x020E0294 0x00000030
+DATA 4 0x020E0298 0x00000030
+DATA 4 0x020E029C 0x00000030
+DATA 4 0x020E02A0 0x00000030
+DATA 4 0x020E02C0 0x00082030
+
+DATA 4 0x021B001C 0x00008000
+
+DATA 4 0x021B0800 0xA1390003
+DATA 4 0x021B085c 0x1b4700c7
+DATA 4 0x021B0890 0x00300000
+DATA 4 0x021B0848 0x48444A4E
+DATA 4 0x021B0850 0x34363830
+DATA 4 0x021B081C 0x33333333
+DATA 4 0x021B0820 0x33333333
+DATA 4 0x021B0824 0x33333333
+DATA 4 0x021B0828 0x33333333
+
+DATA 4 0x021B082C 0xf3333333
+DATA 4 0x021B0830 0xf3333333
+DATA 4 0x021B0834 0xf3333333
+DATA 4 0x021B0838 0xf3333333
+DATA 4 0x021B08C0 0x24922492
+DATA 4 0x021B08b8 0x00000800
+
+DATA 4 0x021B0004 0x00020024
+DATA 4 0x021B000C 0x33374133
+DATA 4 0x021B0010 0x00100A82
+DATA 4 0x021B0038 0x00190778
+DATA 4 0x021B0014 0x00000093
+DATA 4 0x021B0018 0x00201688
+DATA 4 0x021B002C 0x0F9F26D2
+DATA 4 0x021B0030 0x009F0E10
+DATA 4 0x021B0040 0x0000004F
+DATA 4 0x021B0000 0xC3110000
+
+DATA 4 0x021B083C 0x20000000
+
+DATA 4 0x021B001C 0x00008050
+DATA 4 0x021B001C 0x003F8030
+DATA 4 0x021B001C 0xFF0A8030
+DATA 4 0x021B001C 0x04028030
+DATA 4 0x021B001C 0x82018030
+DATA 4 0x021B001C 0x02038030
+
+DATA 4 0x021B0020 0x00001800
+DATA 4 0x021B0800 0xA1390003
+DATA 4 0x021B0004 0x00025564
+DATA 4 0x021B0404 0x00011006
+DATA 4 0x021B001C 0x00000000
+#endif
diff --git a/board/freescale/mx6sll_kobo_clara_hd/imximage_lpddr2_org.cfg b/board/freescale/mx6sll_kobo_clara_hd/imximage_lpddr2_org.cfg
new file mode 100644
index 0000000000..66d5e4fe9a
--- /dev/null
+++ b/board/freescale/mx6sll_kobo_clara_hd/imximage_lpddr2_org.cfg
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+
+BOOT_FROM	sd
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6sll_arm2/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+/* Enable all clocks */
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+
+DATA 4 0x020E0550 0x00080000
+DATA 4 0x020E0534 0x00000000
+DATA 4 0x020E02AC 0x00000030
+DATA 4 0x020E0548 0x00000030
+DATA 4 0x020E052C 0x00000030
+DATA 4 0x020E0530 0x00020000
+DATA 4 0x020E02B0 0x00003030
+DATA 4 0x020E02B4 0x00003030
+DATA 4 0x020E02B8 0x00003030
+DATA 4 0x020E02BC 0x00003030
+DATA 4 0x020E0540 0x00020000
+DATA 4 0x020E0544 0x00000030
+DATA 4 0x020E054C 0x00000030
+DATA 4 0x020E0554 0x00000030
+DATA 4 0x020E0558 0x00000030
+DATA 4 0x020E0294 0x00000030
+DATA 4 0x020E0298 0x00000030
+DATA 4 0x020E029C 0x00000030
+DATA 4 0x020E02A0 0x00000030
+DATA 4 0x020E02C0 0x00082030
+
+DATA 4 0x021B001C 0x00008000
+
+DATA 4 0x021B0800 0xA1390003
+DATA 4 0x021B085c 0x084700C7
+DATA 4 0x021B0890 0x00400000
+DATA 4 0x021B0848 0x3A383C40
+DATA 4 0x021B0850 0x242C3020
+DATA 4 0x021B081C 0x33333333
+DATA 4 0x021B0820 0x33333333
+DATA 4 0x021B0824 0x33333333
+DATA 4 0x021B0828 0x33333333
+
+DATA 4 0x021B082C 0xf3333333
+DATA 4 0x021B0830 0xf3333333
+DATA 4 0x021B0834 0xf3333333
+DATA 4 0x021B0838 0xf3333333
+DATA 4 0x021B08C0 0x24922492
+DATA 4 0x021B08b8 0x00000800
+
+DATA 4 0x021B0004 0x00020052
+DATA 4 0x021B000C 0x53574333
+DATA 4 0x021B0010 0x00100A82
+DATA 4 0x021B0038 0x00170777
+DATA 4 0x021B0014 0x00C70093
+DATA 4 0x021B0018 0x00201708
+DATA 4 0x021B002C 0x0F9F26D2
+DATA 4 0x021B0030 0x009F0E10
+DATA 4 0x021B0040 0x0000004F
+DATA 4 0x021B0000 0xC3110000
+
+DATA 4 0x021B083C 0x20000000
+
+DATA 4 0x021B001C 0x00008050
+DATA 4 0x021B001C 0x00008058
+DATA 4 0x021B001C 0x003F8030
+DATA 4 0x021B001C 0x003F8038
+DATA 4 0x021B001C 0xFF0A8030
+DATA 4 0x021B001C 0xFF0A8038
+DATA 4 0x021B001C 0x04028030
+DATA 4 0x021B001C 0x04028038
+DATA 4 0x021B001C 0x82018030
+DATA 4 0x021B001C 0x82018038
+DATA 4 0x021B001C 0x01038030
+DATA 4 0x021B001C 0x01038038
+
+DATA 4 0x021B0020 0x00001800
+DATA 4 0x021B0800 0xA1390003
+DATA 4 0x021B0004 0x00020052
+DATA 4 0x021B0404 0x00011006
+DATA 4 0x021B001C 0x00000000
+#endif
diff --git a/board/freescale/mx6sll_kobo_clara_hd/mx6sll_kobo_clara_hd.c b/board/freescale/mx6sll_kobo_clara_hd/mx6sll_kobo_clara_hd.c
new file mode 100644
index 0000000000..bc632b45a4
--- /dev/null
+++ b/board/freescale/mx6sll_kobo_clara_hd/mx6sll_kobo_clara_hd.c
@@ -0,0 +1,893 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/arch-mx6/clock.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/io.h>
+#include <common.h>
+#include <fsl_esdhc.h>
+#include <i2c.h>
+#include <linux/sizes.h>
+#include <linux/fb.h>
+#include <miiphy.h>
+#include <mmc.h>
+#include <mxsfb.h>
+#include <netdev.h>
+#include <power/pmic.h>
+#include <power/pfuze100_pmic.h>
+#include "../common/pfuze.h"
+#include <usb.h>
+#include <usb/ehci-fsl.h>
+#if defined(CONFIG_MXC_EPDC)
+#include <lcd.h>
+#include <mxc_epdc_fb.h>
+#endif
+#include <asm/imx-common/video.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+
+#include "ntx_pads.h"
+
+#include "ntx_comm.h"
+#include "ntx_comm.c"
+
+#include "ntx_hw.h"
+#include "ntx_hw.c"
+
+#include "ntx_hwconfig.h"
+
+
+#ifdef CONFIG_SYS_I2C_MXC
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+/* I2C1 for PMIC and EPD */
+struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		/* conflict with usb_otg2_pwr */
+		.i2c_mode = MX6_PAD_I2C1_SCL__I2C1_SCL | PC,
+		.gpio_mode = MX6_PAD_I2C1_SCL__GPIO3_IO12 | PC,
+		.gp = IMX_GPIO_NR(3, 12),
+	},
+	.sda = {
+		/* conflict with usb_otg2_oc */
+		.i2c_mode = MX6_PAD_I2C1_SDA__I2C1_SDA | PC,
+		.gpio_mode = MX6_PAD_I2C1_SDA__GPIO3_IO13 | PC,
+		.gp = IMX_GPIO_NR(3, 13),
+	},
+};
+
+/* I2C2 for LCD and ADV */
+struct i2c_pads_info i2c_pad_info2 = {
+	.scl = {
+		.i2c_mode = MX6_PAD_I2C2_SCL__I2C2_SCL | PC,
+		.gpio_mode = MX6_PAD_I2C2_SCL__GPIO3_IO14 | PC,
+		.gp = IMX_GPIO_NR(3, 14),
+	},
+	.sda = {
+		.i2c_mode = MX6_PAD_I2C2_SDA__I2C2_SDA | PC,
+		.gpio_mode = MX6_PAD_I2C2_SDA__GPIO3_IO15 | PC,
+		.gp = IMX_GPIO_NR(3, 15),
+	},
+};
+
+/* I2C1 for PMIC and EPD */
+struct i2c_pads_info i2c_pad_info3 = {
+	.scl = {
+		/* conflict with usb_otg2_pwr */
+		.i2c_mode = MX6_PAD_REF_CLK_24M__I2C3_SCL | PC,
+		.gpio_mode = MX6_PAD_REF_CLK_24M__GPIO3_IO21 | PC,
+		.gp = IMX_GPIO_NR(3, 21),
+	},
+	.sda = {
+		/* conflict with usb_otg2_oc */
+		.i2c_mode = MX6_PAD_REF_CLK_32K__I2C3_SDA | PC,
+		.gpio_mode = MX6_PAD_REF_CLK_32K__GPIO3_IO22 | PC,
+		.gp = IMX_GPIO_NR(3, 22),
+	},
+};
+
+#endif
+
+int dram_init(void)
+{
+	gd->ram_size = PHYS_SDRAM_SIZE;
+
+	return 0;
+}
+
+static iomux_v3_cfg_t const wdog_pads[] = {
+	MX6_PAD_WDOG_B__WDOG1_B | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const led_pads[] = {
+	MX6_PAD_SD1_DATA6__GPIO5_IO07 | MUX_PAD_CTRL(UART_PAD_CTRL),		// ON_LED
+	MX6_PAD_EPDC_PWR_CTRL3__GPIO2_IO10 | MUX_PAD_CTRL(UART_PAD_CTRL),	// FL_EN
+	MX6_PAD_KEY_ROW2__GPIO3_IO29 | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const led_pads_emmc[] = {
+	MX6_PAD_GPIO4_IO22__GPIO4_IO22 | MUX_PAD_CTRL(UART_PAD_CTRL),		// ON_LED
+	MX6_PAD_EPDC_PWR_CTRL3__GPIO2_IO10 | MUX_PAD_CTRL(UART_PAD_CTRL),	// FL_EN
+	MX6_PAD_KEY_ROW2__GPIO3_IO29 | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const uart1_pads[] = {
+	MX6_PAD_UART1_TXD__UART1_DCE_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_UART1_RXD__UART1_DCE_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+/* 8bit SD1 */
+static iomux_v3_cfg_t const usdhc1_pads[] = {
+	MX6_PAD_SD1_CLK__SD1_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_CMD__SD1_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA0__SD1_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA1__SD1_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA2__SD1_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA3__SD1_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA4__SD1_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA5__SD1_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA6__SD1_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA7__SD1_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+/* EMMC */
+static iomux_v3_cfg_t const usdhc2_pads[] = {
+	MX6_PAD_SD2_CLK__SD2_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_CMD__SD2_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA0__SD2_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA1__SD2_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA2__SD2_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA3__SD2_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA4__SD2_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA5__SD2_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA6__SD2_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA7__SD2_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+/* Wifi SD */
+static iomux_v3_cfg_t const usdhc3_pads[] = {
+	MX6_PAD_SD3_CLK__SD3_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_CMD__SD3_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA0__SD3_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA1__SD3_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA2__SD3_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA3__SD3_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+
+static void setup_iomux_uart(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
+}
+
+#ifdef CONFIG_FSL_ESDHC
+static struct fsl_esdhc_cfg usdhc_cfg[CONFIG_SYS_FSL_USDHC_NUM] = {
+	{USDHC1_BASE_ADDR, 0, 4}, 
+	{USDHC2_BASE_ADDR, 0, 4},
+	{USDHC3_BASE_ADDR, 0, 4},
+};
+
+int board_mmc_get_env_dev(int devno)
+{
+	return CONFIG_SYS_MMC_ENV_DEV;
+}
+
+int mmc_map_to_kernel_blk(int devno)
+{
+	return CONFIG_SYS_MMC_ENV_DEV;
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC1_BASE_ADDR:
+		ret = 1;
+		break;
+	case USDHC2_BASE_ADDR:
+		ret = 1;
+		break;
+	case USDHC3_BASE_ADDR:
+		ret = 1;
+		break;
+	}
+
+	return ret;
+}
+
+static int _sdhc_setup(int iSDHC_idx,bd_t *bis)
+{
+
+	switch (iSDHC_idx) {
+	case 0:
+		imx_iomux_v3_setup_multiple_pads(
+			usdhc1_pads, ARRAY_SIZE(usdhc1_pads));
+		usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
+		break;
+	case 1:
+		imx_iomux_v3_setup_multiple_pads(
+			usdhc2_pads, ARRAY_SIZE(usdhc2_pads));
+		usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+		break;
+	case 2:
+		imx_iomux_v3_setup_multiple_pads(
+			usdhc3_pads, ARRAY_SIZE(usdhc3_pads));
+		usdhc_cfg[2].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+		break;
+	default:
+		printf("Warning: you configured more USDHC controllers"
+			"(%d) than supported by the board\n", iSDHC_idx + 1);
+		return -1;
+	}
+
+	if (fsl_esdhc_initialize(bis, &usdhc_cfg[iSDHC_idx]))
+		printf("Warning: failed to initialize mmc dev %d\n", iSDHC_idx);
+
+	return 0;
+}
+
+int board_mmc_init(bd_t *bis)
+{
+#if 1
+//	int i;
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    USDHC1
+	 * mmc1                    USDHC2
+	 * mmc2                    USDHC3 (eMMC)
+	 */
+
+
+	int iISD_IDX = _get_boot_sd_number();
+
+	printf("%s() : isd=%d \n",__FUNCTION__,iISD_IDX);
+	_sdhc_setup(iISD_IDX,bis); // ISD .
+
+	printf("%s() : wifi=2 \n",__FUNCTION__);
+	_sdhc_setup(2,bis); // WIFI
+
+	return 0;
+#else
+	int i;
+
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    USDHC1
+	 * mmc1                    USDHC2
+	 * mmc2                    USDHC3
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (usdhc_cfg[i].esdhc_base) {
+		case USDHC1_BASE_ADDR:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc1_pads, ARRAY_SIZE(usdhc1_pads));
+			usdhc_cfg[i].sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
+			break;
+		case USDHC2_BASE_ADDR:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc2_pads, ARRAY_SIZE(usdhc2_pads));
+			usdhc_cfg[i].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+			break;
+		case USDHC3_BASE_ADDR:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc3_pads, ARRAY_SIZE(usdhc3_pads));
+			usdhc_cfg[i].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers (%d) than supported by the board\n", i + 1);
+			return 0;
+		}
+
+		if (fsl_esdhc_initialize(bis, &usdhc_cfg[i]))
+			printf("Warning: failed to initialize mmc dev %d\n", i);
+	}
+
+	return 0;
+#endif
+}
+#endif
+
+#ifdef CONFIG_POWER
+#define I2C_PMIC	0
+static struct pmic *pfuze;
+int power_init_board(void)
+{
+	int ret;
+	u32 rev_id, value;
+
+	ret = power_pfuze100_init(I2C_PMIC);
+	if (ret)
+		return ret;
+
+	pfuze = pmic_get("PFUZE100");
+	if (!pfuze)
+		return -ENODEV;
+
+	ret = pmic_probe(pfuze);
+	if (ret)
+		return ret;
+
+	ret = pfuze_mode_init(pfuze, APS_PFM);
+	if (ret < 0)
+		return ret;
+
+	pmic_reg_read(pfuze, PFUZE100_DEVICEID, &value);
+	pmic_reg_read(pfuze, PFUZE100_REVID, &rev_id);
+	printf("PMIC: PFUZE100! DEV_ID=0x%x REV_ID=0x%x\n", value, rev_id);
+
+	/* set SW1AB standby volatage 0.975V */
+	pmic_reg_read(pfuze, PFUZE100_SW1ABSTBY, &value);
+	value &= ~0x3f;
+	value |= PFUZE100_SW1ABC_SETP(9750);
+	pmic_reg_write(pfuze, PFUZE100_SW1ABSTBY, value);
+
+	/* set SW1AB/VDDARM step ramp up time from 16us to 4us/25mV */
+	pmic_reg_read(pfuze, PFUZE100_SW1ABCONF, &value);
+	value &= ~0xc0;
+	value |= 0x40;
+	pmic_reg_write(pfuze, PFUZE100_SW1ABCONF, value);
+
+	/* set SW1C staby volatage 0.975V */
+	pmic_reg_read(pfuze, PFUZE100_SW1CSTBY, &value);
+	value &= ~0x3f;
+	value |= 0x1b;
+	pmic_reg_write(pfuze, PFUZE100_SW1CSTBY, value);
+
+	/* set SW1C/VDDSOC step ramp up time to from 16us to 4us/25mV */
+	pmic_reg_read(pfuze, PFUZE100_SW1CCONF, &value);
+	value &= ~0xc0;
+	value |= 0x40;
+	pmic_reg_write(pfuze, PFUZE100_SW1CCONF, value);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_MXC_SPI
+iomux_v3_cfg_t const ecspi1_pads[] = {
+	MX6_PAD_ECSPI1_SCLK__ECSPI1_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_ECSPI1_MOSI__ECSPI1_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_ECSPI1_MISO__ECSPI1_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL),
+
+	/* CS0 */
+	MX6_PAD_ECSPI1_SS0__GPIO4_IO11   | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+void setup_spinor(void)
+{
+	imx_iomux_v3_setup_multiple_pads(ecspi1_pads,
+					 ARRAY_SIZE(ecspi1_pads));
+	gpio_direction_output(IMX_GPIO_NR(4, 11), 0);
+}
+
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? (IMX_GPIO_NR(4, 11)) : -1;
+}
+#endif
+
+#ifdef CONFIG_VIDEO_MXS
+static iomux_v3_cfg_t const lcd_pads[] = {
+	MX6_PAD_LCD_CLK__LCD_CLK | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_ENABLE__LCD_ENABLE | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_HSYNC__LCD_HSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_VSYNC__LCD_VSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA00__LCD_DATA00 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA01__LCD_DATA01 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA02__LCD_DATA02 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA03__LCD_DATA03 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA04__LCD_DATA04 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA05__LCD_DATA05 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA06__LCD_DATA06 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA07__LCD_DATA07 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA08__LCD_DATA08 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA09__LCD_DATA09 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA10__LCD_DATA10 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA11__LCD_DATA11 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA12__LCD_DATA12 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA13__LCD_DATA13 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA14__LCD_DATA14 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA15__LCD_DATA15 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA16__LCD_DATA16 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA17__LCD_DATA17 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA18__LCD_DATA18 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA19__LCD_DATA19 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA20__LCD_DATA20 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA21__LCD_DATA21 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA22__LCD_DATA22 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA23__LCD_DATA23 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_ECSPI1_SCLK__GPIO4_IO08 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_LCD_RESET__GPIO2_IO19 | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/* Use GPIO for Brightness adjustment, duty cycle = period */
+	MX6_PAD_PWM1__GPIO3_IO23 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+void do_enable_parallel_lcd(struct display_info_t const *dev)
+
+{
+	int ret;
+
+	ret = enable_lcdif_clock(dev->bus);
+	if (ret) {
+		printf("Enable LCDIF clock failed, %d\n", ret);
+		return;
+	}
+
+	imx_iomux_v3_setup_multiple_pads(lcd_pads, ARRAY_SIZE(lcd_pads));
+
+	/* Reset the LCD */
+	gpio_direction_output(IMX_GPIO_NR(2, 19) , 0);
+	udelay(500);
+	gpio_direction_output(IMX_GPIO_NR(2, 19) , 1);
+
+	gpio_direction_output(IMX_GPIO_NR(4, 8) , 1);
+
+	/* Set Brightness to high */
+	gpio_direction_output(IMX_GPIO_NR(3, 23) , 1);
+}
+
+struct display_info_t const displays[] = {{
+	.bus = MX6SLL_LCDIF_BASE_ADDR,
+	.addr = 0,
+	.pixfmt = 24,
+	.detect = NULL,
+	.enable	= do_enable_parallel_lcd,
+	.mode	= {
+		.name			= "MCIMX28LCD",
+		.xres           = 800,
+		.yres           = 480,
+		.pixclock       = 29850,
+		.left_margin    = 89,
+		.right_margin   = 164,
+		.upper_margin   = 23,
+		.lower_margin   = 10,
+		.hsync_len      = 10,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+size_t display_count = ARRAY_SIZE(displays);
+#endif
+
+#ifdef CONFIG_MXC_EPDC
+static iomux_v3_cfg_t const epdc_enable_pads[] = {
+	MX6_PAD_EPDC_DATA00__EPDC_DATA00	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA01__EPDC_DATA01	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA02__EPDC_DATA02	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA03__EPDC_DATA03	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA04__EPDC_DATA04	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA05__EPDC_DATA05	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA06__EPDC_DATA06	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA07__EPDC_DATA07	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA08__EPDC_DATA08	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA09__EPDC_DATA09	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA10__EPDC_DATA10	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA11__EPDC_DATA11	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA12__EPDC_DATA12	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA13__EPDC_DATA13	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA14__EPDC_DATA14	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_DATA15__EPDC_DATA15	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_SDCLK__EPDC_SDCLK_P	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_SDLE__EPDC_SDLE		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_SDOE__EPDC_SDOE		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_SDSHR__EPDC_SDSHR		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_SDCE0__EPDC_SDCE0		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_GDCLK__EPDC_GDCLK		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_GDOE__EPDC_GDOE		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_GDRL__EPDC_GDRL		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_GDSP__EPDC_GDSP		| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const epdc_disable_pads[] = {
+	MX6_PAD_EPDC_DATA01__GPIO1_IO08,
+	MX6_PAD_EPDC_DATA02__GPIO1_IO09,
+	MX6_PAD_EPDC_DATA03__GPIO1_IO10,
+	MX6_PAD_EPDC_DATA04__GPIO1_IO11,
+	MX6_PAD_EPDC_DATA05__GPIO1_IO12,
+	MX6_PAD_EPDC_DATA06__GPIO1_IO13,
+	MX6_PAD_EPDC_DATA07__GPIO1_IO14,
+	MX6_PAD_EPDC_DATA08__GPIO1_IO15,
+	MX6_PAD_EPDC_DATA09__GPIO1_IO16,
+	MX6_PAD_EPDC_DATA10__GPIO1_IO17,
+	MX6_PAD_EPDC_DATA11__GPIO1_IO18,
+	MX6_PAD_EPDC_DATA12__GPIO1_IO19,
+	MX6_PAD_EPDC_DATA13__GPIO1_IO20,
+	MX6_PAD_EPDC_DATA14__GPIO1_IO21,
+	MX6_PAD_EPDC_DATA15__GPIO1_IO22,
+	MX6_PAD_EPDC_SDCLK__GPIO1_IO23,
+	MX6_PAD_EPDC_SDLE__GPIO1_IO24,
+	MX6_PAD_EPDC_SDOE__GPIO1_IO25,
+	MX6_PAD_EPDC_SDSHR__GPIO1_IO26,
+	MX6_PAD_EPDC_SDCE0__GPIO1_IO27,
+	MX6_PAD_EPDC_GDCLK__GPIO1_IO31,
+	MX6_PAD_EPDC_GDOE__GPIO2_IO00,
+	MX6_PAD_EPDC_GDRL__GPIO2_IO01,
+	MX6_PAD_EPDC_GDSP__GPIO2_IO02,
+};
+
+vidinfo_t panel_info = {
+	.vl_refresh = 85,
+	.vl_col = 1024,
+	.vl_row = 758,
+	.vl_pixclock = 40000000,
+	.vl_left_margin = 12,
+	.vl_right_margin = 76,
+	.vl_upper_margin = 4,
+	.vl_lower_margin = 5,
+	.vl_hsync = 12,
+	.vl_vsync = 2,
+	.vl_sync = 0,
+	.vl_mode = 0,
+	.vl_flag = 0,
+	.vl_bpix = 3,
+	.cmap = 0,
+};
+
+struct epdc_timing_params panel_timings = {
+	.vscan_holdoff = 4,
+	.sdoed_width = 10,
+	.sdoed_delay = 20,
+	.sdoez_width = 10,
+	.sdoez_delay = 20,
+	.gdclk_hp_offs = 524,
+	.gdsp_offs = 327,
+	.gdoe_offs = 0,
+	.gdclk_offs = 19,
+	.num_ce = 1,
+};
+
+static void setup_epdc_power(void)
+{
+	/* Setup epdc voltage */
+
+	/* EPDC_PWRSTAT - GPIO2[13] for PWR_GOOD status */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_PWR_STAT__GPIO2_IO13 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	gpio_direction_input(IMX_GPIO_NR(2, 13));
+
+	/* EPDC_VCOM0 - GPIO2[03] for VCOM control */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_VCOM0__GPIO2_IO03 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(2, 3), 1);
+
+	/* EPDC_PWRWAKEUP - GPIO2[14] for EPD PMIC WAKEUP */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_PWR_WAKE__GPIO2_IO14 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(2, 14), 1);
+
+	/* EPDC_PWRCTRL0 - GPIO2[07] for EPD PWR CTL0 */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_PWR_CTRL0__GPIO2_IO07 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(2, 7), 1);
+}
+
+static void epdc_enable_pins(void)
+{
+	/* epdc iomux settings */
+	imx_iomux_v3_setup_multiple_pads(epdc_enable_pads,
+				ARRAY_SIZE(epdc_enable_pads));
+}
+
+static void epdc_disable_pins(void)
+{
+	/* Configure MUX settings for EPDC pins to GPIO  and drive to 0 */
+	imx_iomux_v3_setup_multiple_pads(epdc_disable_pads,
+				ARRAY_SIZE(epdc_disable_pads));
+}
+
+static void setup_epdc(void)
+{
+	/*** epdc Maxim PMIC settings ***/
+
+	/* EPDC_PWRSTAT - GPIO2[13] for PWR_GOOD status */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_PWR_STAT__GPIO2_IO13 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* EPDC_VCOM0 - GPIO2[03] for VCOM control */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_VCOM0__GPIO2_IO03 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* EPDC_PWRWAKEUP - GPIO2[14] for EPD PMIC WAKEUP */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_PWR_WAKE__GPIO2_IO14 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* EPDC_PWRCTRL0 - GPIO2[07] for EPD PWR CTL0 */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_PWR_CTRL0__GPIO2_IO07 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* Set pixel clock rates for EPDC in clock.c */
+
+	panel_info.epdc_data.wv_modes.mode_init = 0;
+	panel_info.epdc_data.wv_modes.mode_du = 1;
+	panel_info.epdc_data.wv_modes.mode_gc4 = 3;
+	panel_info.epdc_data.wv_modes.mode_gc8 = 2;
+	panel_info.epdc_data.wv_modes.mode_gc16 = 2;
+	panel_info.epdc_data.wv_modes.mode_gc32 = 2;
+
+	panel_info.epdc_data.epdc_timings = panel_timings;
+
+	setup_epdc_power();
+}
+
+void epdc_power_on(void)
+{
+	unsigned int reg;
+	struct gpio_regs *gpio_regs = (struct gpio_regs *)GPIO2_BASE_ADDR;
+
+	/* Set EPD_PWR_CTL0 to high - enable EINK_VDD (3.15) */
+	gpio_set_value(IMX_GPIO_NR(2, 7), 1);
+	udelay(1000);
+
+	/* Enable epdc signal pin */
+	epdc_enable_pins();
+
+	/* Set PMIC Wakeup to high - enable Display power */
+	gpio_set_value(IMX_GPIO_NR(2, 14), 1);
+
+	/* Wait for PWRGOOD == 1 */
+	while (1) {
+		reg = readl(&gpio_regs->gpio_psr);
+		if (!(reg & (1 << 13)))
+			break;
+
+		udelay(100);
+	}
+
+	/* Enable VCOM */
+	gpio_set_value(IMX_GPIO_NR(2, 3), 1);
+
+	udelay(500);
+}
+
+void epdc_power_off(void)
+{
+	/* Set PMIC Wakeup to low - disable Display power */
+	gpio_set_value(IMX_GPIO_NR(2, 14), 0);
+
+	/* Disable VCOM */
+	gpio_set_value(IMX_GPIO_NR(2, 3), 0);
+
+	epdc_disable_pins();
+
+	/* Set EPD_PWR_CTL0 to low - disable EINK_VDD (3.15) */
+	gpio_set_value(IMX_GPIO_NR(2, 7), 0);
+}
+#endif
+
+
+#ifdef CONFIG_USB_EHCI_MX6
+#define USB_OTHERREGS_OFFSET	0x800
+#define UCTRL_PWR_POL		(1 << 9)
+iomux_v3_cfg_t const usb_otg1_pads[] = {
+	MX6_PAD_KEY_COL4__USB_OTG1_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_KEY_ROW4__USB_OTG1_OC  | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_EPDC_PWR_COM__USB_OTG1_ID | MUX_PAD_CTRL(OTG_ID_PAD_CTRL),
+};
+
+iomux_v3_cfg_t const usb_otg2_pads[] = {
+	MX6_PAD_KEY_COL5__USB_OTG2_PWR   | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_ECSPI2_SCLK__USB_OTG2_OC | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_EPDC_PWR_IRQ__USB_OTG2_ID | MUX_PAD_CTRL(OTG_ID_PAD_CTRL),
+};
+
+int board_usb_phy_mode(int port)
+{
+	return usb_phy_mode(port);
+}
+
+int board_ehci_hcd_init(int port)
+{
+	u32 *usbnc_usb_ctrl;
+
+	if (port > 1)
+		return -EINVAL;
+
+	switch (port) {
+	case 0:
+		imx_iomux_v3_setup_multiple_pads(usb_otg1_pads,
+						 ARRAY_SIZE(usb_otg1_pads));
+		break;
+	case 1:
+		imx_iomux_v3_setup_multiple_pads(usb_otg2_pads,
+						 ARRAY_SIZE(usb_otg2_pads));
+		break;
+	default:
+		printf("MXC USB port %d not yet supported\n", port);
+		return 1;
+	}
+
+	usbnc_usb_ctrl = (u32 *)(USB_BASE_ADDR + USB_OTHERREGS_OFFSET +
+				 port * 4);
+
+	/* Set Power polarity */
+	setbits_le32(usbnc_usb_ctrl, UCTRL_PWR_POL);
+
+	return 0;
+}
+#endif
+
+int board_early_init_f(void)
+{
+	setup_iomux_uart();
+	enable_uart_clk(true);
+	return 0;
+}
+
+int board_init(void)
+{
+	/* Address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+	if (_get_boot_sd_number()) {
+		imx_iomux_v3_setup_multiple_pads(led_pads, ARRAY_SIZE(led_pads));
+		gpio_direction_output(IMX_GPIO_NR(5, 7) , 0);	// ON_LED
+	}
+	else {
+		imx_iomux_v3_setup_multiple_pads(led_pads_emmc, ARRAY_SIZE(led_pads_emmc));
+		gpio_direction_output(IMX_GPIO_NR(4, 22) , 0);	// ON_LED
+	}
+	gpio_direction_output(IMX_GPIO_NR(2, 10) , 1);	// FL_EN
+	gpio_direction_output(IMX_GPIO_NR(3, 29) , 1);	// FL_EN
+
+
+#ifdef CONFIG_SYS_I2C_MXC
+	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+	setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info2);
+	setup_i2c(2, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info3);
+#endif
+
+#ifdef CONFIG_MXC_SPI
+	setup_spinor();
+#endif
+
+#ifdef	CONFIG_MXC_EPDC
+	enable_epdc_clock();
+	setup_epdc();
+#endif
+
+	return 0;
+}
+
+int board_late_init(void)
+{
+	if (is_boot_from_usb())
+		return 0;
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_env_init();
+#endif
+
+	ntx_hw_early_init();
+
+	ntx_hw_late_init();
+
+	setenv("mmcdev","0");
+
+	ntx_config_fastboot_layout();
+
+	imx_iomux_v3_setup_multiple_pads(wdog_pads, ARRAY_SIZE(wdog_pads));
+
+	set_wdog_reset((struct wdog_regs *)WDOG1_BASE_ADDR);
+
+	return 0;
+}
+
+u32 get_board_rev(void)
+{
+	return get_cpu_rev();
+}
+
+int checkboard(void)
+{
+#if defined(CONFIG_LPDDR2) || defined(CONFIG_LPDDR2_512M)
+	puts("Board: MX6SLL LPDDR2 NTX e60k02\n");
+#else
+	puts("Board: MX6SLL LPDDR3 NTX e60k02\n");
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_FSL_FASTBOOT
+void board_fastboot_setup(void)
+{
+	switch (get_boot_device()) {
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD1_BOOT:
+	case MMC1_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc0");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc0");
+		break;
+	case SD2_BOOT:
+	case MMC2_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc1");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc1");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+	case NAND_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "nand");
+		if (!getenv("fbparts"))
+			setenv("fbparts", ANDROID_FASTBOOT_NAND_PARTS);
+		if (!getenv("bootcmd"))
+			setenv("bootcmd",
+				"nand read ${loadaddr} ${boot_nand_offset} "
+				"${boot_nand_size};boota ${loadaddr}");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_NAND*/
+
+	default:
+		printf("unsupported boot devices\n");
+		break;
+	}
+}
+
+#ifdef CONFIG_ANDROID_RECOVERY
+int check_recovery_cmd_file(void)
+{
+	int recovery_mode = 0;
+
+	recovery_mode = recovery_check_and_clean_flag();
+
+	return recovery_mode;
+}
+
+void board_recovery_setup(void)
+{
+	int bootdev = get_boot_device();
+
+	switch (bootdev) {
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD1_BOOT:
+	case MMC1_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery", "boota mmc0 recovery");
+		break;
+	case SD2_BOOT:
+	case MMC2_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery", "boota mmc1 recovery");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+	default:
+		printf("Unsupported bootup device for recovery: dev: %d\n",
+			bootdev);
+		return;
+	}
+
+	printf("setup env for recovery..\n");
+	setenv("bootcmd", "run bootcmd_android_recovery");
+}
+#endif /*CONFIG_ANDROID_RECOVERY*/
+
+#endif /*CONFIG_FSL_FASTBOOT*/
+
+
+
+
+
diff --git a/board/freescale/mx6sll_kobo_clara_hd/ntx_cmd.c b/board/freescale/mx6sll_kobo_clara_hd/ntx_cmd.c
new file mode 100644
index 0000000000..749ee12558
--- /dev/null
+++ b/board/freescale/mx6sll_kobo_clara_hd/ntx_cmd.c
@@ -0,0 +1,1775 @@
+
+
+#include <common.h>
+#include <command.h>
+#include <exports.h>
+#include <i2c.h>
+#include <mxc_keyb.h>
+#include <rtc.h>
+#include <asm/io.h>
+
+#ifdef _MX50_//[
+#include <asm/arch/mx50.h>
+#include <asm/arch/mx50_pins.h>
+#elif defined(_MX6SL_) //][ 
+#include <asm/arch/mx6sl_pins.h>
+#elif defined(_MX6SLL_) //][ 
+#include <asm/arch/mx6sll_pins.h>
+#elif defined(_MX7D_)
+#include <asm/arch/mx7d_pins.h>
+#endif //] _MX50_
+
+#include <asm/imx-common/iomux-v3.h>
+
+#include "ntx_hwconfig.h"
+
+#include "ntx_comm.h"
+#include "ntx_hw.h"
+
+#include <ext_common.h>
+#include <ext4fs.h>
+#include <malloc.h>
+
+
+
+#ifdef _MX50_//[
+
+	#define FL_R_EN_IOMUX 	MX50_PIN_EPDC_VCOM1
+	#define FL_EN_IOMUX			MX50_PIN_ECSPI1_MISO
+
+#elif defined(_MX6SL_) //][
+
+#endif //] 
+
+
+extern unsigned int gdwBusNum;
+
+
+typedef struct tagRTC_HumanReadable {
+	unsigned short wYear; // 2010~XXXX .
+	unsigned char bMonth; // 1~12 .
+	unsigned char bDay; // 1~31 .
+	
+	unsigned char bHour; // 0~23 .
+	unsigned char bMin; // 0~59 .
+	unsigned char bSecs; // 0~59 .
+}RTC_HR;
+
+
+static unsigned char gbEsdUPGKeyVal_default[2]={0x00,0x01}; // E60612,E60612D,E60612C,E606A2,E606B2 ,....
+static unsigned char gbEsdUPGKeyVal_E60630[2]={0x00,0x02};
+static unsigned char gbEsdUPGKeyVal_E50600[2]={0x00,0x08};
+
+static unsigned char gbMicroP_VersionA[2] ;
+static int giIsMicroP_inited=0;
+
+static const unsigned short gwDefaultStartYear = 2000; // microp default start year .
+
+static const unsigned char gbZforceI2C_ChipAddr = 0x50;
+
+static int isUpgMSP430=0;
+
+extern NTX_HWCONFIG *gptNtxHwCfg ;
+
+#define EVENT_REG_BIT_POWERON		0x80 // 1: power on .
+#define EVENT_REG_BIT_KEYIN			0x40 // 1: keypad input .
+#define EVENT_REG_BIT_ESDIN			0x20 // 1: External SD card inserted .
+#define EVENT_REG_BIT_I2CEVT		0x10 // 1: i2c event for touch .
+#define EVENT_REG_BIT_UARTEVT		0x08 // 1: uart event for touch .
+#define EVENT_REG_BIT_DCIN			0x04 // 1: DC in .
+#define EVENT_REG_BIT_BATLOW		0x02 // 1: battery is low .
+#define EVENT_REG_BIT_BATCRTLOW		0x01 // 1: battery very low .
+
+static int giCurrentHallSensorState = -1;
+
+
+static unsigned short calc_crc16(unsigned char *data, unsigned short len) {
+
+	unsigned short crc = 0xffff;
+	unsigned char i;
+ 
+	while (len--) {
+		crc ^= *data++ << 8;
+		for (i = 0; i < 8; i++) {
+			crc = crc & 0x8000 ? (crc << 1) ^ 0x1021 : crc << 1;
+		}
+	}
+	return crc;
+
+}
+
+static void add_crc16(unsigned char *data, int len) {
+
+	unsigned short crc = calc_crc16(data, len);
+	data[len] = crc & 0xff;
+	data[len+1] = (crc >> 8) & 0xff;
+}
+
+int ntxup_init(void)
+{
+	int iRet = 0 ;
+	int iChk;
+	
+		
+	if(1!=giIsMicroP_inited) {
+		giCurrentHallSensorState = _hallsensor_status();
+	}
+	
+	init_pwr_i2c_function(0);
+	iChk = msp430_read_buf(0,gbMicroP_VersionA, 2);
+	if(0==iChk) {
+		// success .
+		printf("microp version=0x%02x%02x\n",gbMicroP_VersionA[0],gbMicroP_VersionA[1]);
+		if (0xe9==gbMicroP_VersionA[0] && 0x16==gbMicroP_VersionA[1]) {
+			unsigned char buffer[10];
+			isUpgMSP430 = 1;
+			buffer[0]=22;
+			buffer[1]=0xFF;
+			add_crc16(buffer, 2);
+			msp430_write_buf(22,&buffer[1],3);
+		}
+		if(1==gptNtxHwCfg->m_val.bHOME_LED_PWM) {
+			// HOME LED controlled by MICROP .
+			// enable the home pad and re-calibration 
+			uchar bBufA[2] = {0x03,0x00};
+			msp430_write_buf(0xC0,&bBufA[0], 2);
+		}
+	}
+	else {
+		printf("microp version read fail !\n");
+		iRet = -1;
+	}
+	giIsMicroP_inited = 1;
+	
+	return iRet ;
+}
+
+int ntxup_get_adcvalue(unsigned short *O_pwAdcValue)
+{
+	int iRet = 0;
+	int iChk ;
+	unsigned char bBufA[2];
+	
+	if (1 == gptNtxHwCfg->m_val.bPMIC) {	// ricoh619 pmic
+		RC5T619_write_reg(0x66, 0x1C);
+		udelay (5000);
+		RC5T619_read_reg(0x70, &bBufA[0]);
+		RC5T619_read_reg(0x71, &bBufA[1]);
+		*O_pwAdcValue = ((bBufA[0]<<4) | (bBufA[1] &0x0F));
+		return iRet;
+	}
+	
+	if(!giIsMicroP_inited) {
+		ntxup_init();
+	}
+	
+	if (isUpgMSP430) {
+		iChk = msp430_read_buf(0x08,bBufA, 2);
+		if(0==iChk) {
+			if(O_pwAdcValue) {
+				*O_pwAdcValue = ((bBufA[1] << 8) | bBufA[0])>>2;
+			}
+		}
+		else {
+			printf("%s : ctrl&event read fail (%d)!\n",__FUNCTION__,iChk);
+			iRet = -1;
+		}
+	}
+	else {
+		iChk = msp430_read_buf(0x41,bBufA, 2);
+		if(0==iChk) {
+			if(O_pwAdcValue) {
+				*O_pwAdcValue = (bBufA[0] << 8) | bBufA[1];
+			}
+		}
+		else {
+			printf("%s : ctrl&event read fail (%d)!\n",__FUNCTION__,iChk);
+			iRet = -1;
+		}
+	}
+	return iRet;
+}
+
+
+
+int ntxup_get_CtrlEvent(unsigned char *O_pbEvent,unsigned char *O_pbCtrl)
+{
+	int iRet = 0;
+	int iChk ;
+	unsigned char bBufA[2];
+	
+	if(!giIsMicroP_inited) {
+		ntxup_init();
+	}
+	//printf("%s : ctrl&event=0x%02x%02x\n",__FUNCTION__,bBufA[0],bBufA[1]);
+	iChk = msp430_read_buf(0x60, bBufA, 2);
+	if(0==iChk) {
+		if(O_pbEvent) {
+			*O_pbEvent = bBufA[1];
+		}
+		if(O_pbCtrl) {
+			*O_pbCtrl = bBufA[0];
+		}
+	}
+	else {
+		printf("%s : ctrl&event read fail (%d)!\n",__FUNCTION__,iChk);
+		iRet = -1;
+	}
+	
+	return iRet;
+}
+
+int ntxup_is_ext_card_inserted(void)
+{
+#if 0
+	// card insert detected by micro-p .
+	int iRet = 0;
+	unsigned char bEvent;
+	
+	if(ntxup_get_CtrlEvent(&bEvent,0)<0) {
+		// read ctrl & event error .
+	}
+	else {
+		if(bEvent&EVENT_REG_BIT_ESDIN) {
+			iRet = 1;
+		}
+	}
+	
+	return iRet;
+#else 
+	return (_sd_cd_status());
+#endif
+}
+
+static unsigned char dec2bcd(unsigned char dec)
+{
+	return ((dec/10)<<4)+(dec%10);
+}
+
+static unsigned char bcd2dec(unsigned char bcd)
+{
+	return (bcd >> 4)*10+(bcd & 0xf);
+}
+
+int ntxup_rtc_cmd(int iIsSet,
+	unsigned char *IO_pbY,unsigned char *IO_pbM,unsigned char *IO_pbD,
+	unsigned char *IO_pbH,unsigned char *IO_pbm,unsigned char *IO_pbS)
+{
+	int iRet = 0;
+	int iChk;
+	
+	if (1 == gptNtxHwCfg->m_val.bRTC) {	// ricoh619 pmic	
+		if(iIsSet) {
+			RC5T619_write_reg(0xAF, 0x20);
+			RC5T619_write_reg(0xAE, 0x20);
+			
+			RC5T619_write_reg(0xA7, 0);
+			
+			RC5T619_write_reg(0xA6, dec2bcd(*IO_pbY)); 
+			RC5T619_write_reg(0xA5, dec2bcd(*IO_pbM)|0x80); 
+			RC5T619_write_reg(0xA4, dec2bcd(*IO_pbD));
+			RC5T619_write_reg(0xA2, dec2bcd(*IO_pbH)); 
+			RC5T619_write_reg(0xA1, dec2bcd(*IO_pbm));
+			RC5T619_write_reg(0xA0, dec2bcd(*IO_pbS));
+		}
+		else {
+			RC5T619_read_reg(0xA6, IO_pbY);
+			RC5T619_read_reg(0xA5, IO_pbM);
+			RC5T619_read_reg(0xA4, IO_pbD);
+			RC5T619_read_reg(0xA2, IO_pbH);
+			RC5T619_read_reg(0xA1, IO_pbm);
+			RC5T619_read_reg(0xA0, IO_pbS);
+			*IO_pbY = bcd2dec(*IO_pbY); 
+			*IO_pbM = bcd2dec(*IO_pbM&0x1f); 
+			*IO_pbD = bcd2dec(*IO_pbD);
+			*IO_pbH = bcd2dec(*IO_pbH); 
+			*IO_pbm = bcd2dec(*IO_pbm);
+			*IO_pbS = bcd2dec(*IO_pbS);
+		}
+		return iRet;
+	}
+	
+	if(!giIsMicroP_inited) {
+		ntxup_init();
+	}
+	
+	if (isUpgMSP430) {
+		struct rtc_time tm;
+		unsigned long time;
+		unsigned char buffer[10];
+		
+		if(iIsSet) {
+#if 1
+			time = rtc_mktime (&tm);
+#else
+			time = mktime ((*IO_pbY+gwDefaultStartYear), *IO_pbM, *IO_pbD, *IO_pbH, *IO_pbm, *IO_pbS);
+#endif
+			buffer[0] = 5;
+			buffer[1] = 0;
+			buffer[2] = time&0xFF;
+			buffer[3] = (time>>8)&0xFF;
+			buffer[4] = (time>>16)&0xFF;
+			buffer[5] = (time>>24)&0xFF;
+			add_crc16(buffer, 6);
+			iChk = msp430_write_buf(5,&buffer[1], 7);
+			if(iChk!=0) {
+				iRet = -1;
+			}
+		}               
+		else {
+			iChk = msp430_read_buf(4,buffer, 4);
+			time = buffer[3]<<24 | buffer[2]<<16 | buffer[1]<<8 | buffer[0];
+#if 1
+			rtc_to_tm(time, &tm);
+#else 
+			to_tm(time, &tm);
+#endif
+			if (gwDefaultStartYear > tm.tm_year)
+				*IO_pbY = 0; 
+			else
+				*IO_pbY = tm.tm_year-gwDefaultStartYear; 
+			*IO_pbM = tm.tm_mon; 
+			*IO_pbD = tm.tm_mday;
+			*IO_pbH = tm.tm_hour; 
+			*IO_pbm = tm.tm_min;
+			*IO_pbS = tm.tm_sec;
+		}
+	}
+	else {
+		if(iIsSet) {
+			if(IO_pbY) {
+				iChk = msp430_write_reg(0x10,*IO_pbY);
+				if(iChk!=0) {
+					iRet = -1;
+				}
+			}
+			if(IO_pbM) {
+				iChk = msp430_write_reg(0x11,*IO_pbM);
+				if(iChk!=0) {
+					iRet = -2;
+				}
+			}
+			if(IO_pbD) {
+				iChk = msp430_write_reg(0x12,*IO_pbD);
+				if(iChk!=0) {
+					iRet = -3;
+				}
+			}
+			if(IO_pbH) {
+				iChk = msp430_write_reg(0x13,*IO_pbH);
+				if(iChk!=0) {
+					iRet = -4;
+				}
+			}
+			if(IO_pbm) {
+				iChk = msp430_write_reg(0x14,*IO_pbm);
+				if(iChk!=0) {
+					iRet = -5;
+				}
+			}
+			if(IO_pbS) {
+				iChk = msp430_write_reg(0x15,*IO_pbS);
+				if(iChk!=0) {
+					iRet = -6;
+				}
+			}
+		}
+		else {
+			unsigned char bBufA[2];
+			if(IO_pbY||IO_pbM) {
+				iChk = msp430_read_buf(0x20,bBufA,2);
+				if(iChk!=0) {
+					iRet = -7;
+				}
+				//printf("YM=0x%02x,0x%02x\n",bBufA[0],bBufA[1]);
+				if(IO_pbY) {
+					*IO_pbY = bBufA[0];
+				}
+				if(IO_pbM) {
+					*IO_pbM = bBufA[1];
+				}
+			}
+			if(IO_pbD||IO_pbH) {
+				iChk = msp430_read_buf(0x21,bBufA, 2);
+				if(iChk!=0) {
+					iRet = -8;
+				}
+				//printf("DH=0x%02x,0x%02x\n",bBufA[0],bBufA[1]);
+				if(IO_pbD) {
+					*IO_pbD = bBufA[0];
+				}
+				if(IO_pbH) {
+					*IO_pbH = bBufA[1];
+				}
+			}
+			if(IO_pbm||IO_pbS) {
+				iChk = msp430_read_buf(0x23,bBufA, 2);
+				if(iChk!=0) {
+					iRet = -9;
+				}
+				//printf("mS=0x%02x,0x%02x\n",bBufA[0],bBufA[1]);
+				if(IO_pbm) {
+					*IO_pbm = bBufA[0];
+				}
+				if(IO_pbS) {
+					*IO_pbS = bBufA[1];
+				}
+			}
+		}
+	}
+	return iRet;
+}
+
+
+int ntxup_rtc_set(RTC_HR *ptRTCHR) 
+{
+	int iRet = 0;
+	unsigned char bYear;
+	
+	// convert humanable format to microp format ...
+	if(ptRTCHR->wYear<gwDefaultStartYear) {
+		return -1;
+	}
+	bYear = (unsigned char)(ptRTCHR->wYear - gwDefaultStartYear);
+	
+	if( ntxup_rtc_cmd(1,&bYear,&ptRTCHR->bMonth,&ptRTCHR->bDay,
+		&ptRTCHR->bHour,&ptRTCHR->bMin,&ptRTCHR->bSecs) <0) 
+	{
+		iRet = -2;
+	}
+	
+	return iRet;
+}
+
+int ntxup_rtc_get(RTC_HR *ptRTCHR) 
+{
+	int iRet = 0;
+	unsigned char bYear;
+	
+	
+	if( ntxup_rtc_cmd(0,&bYear,&ptRTCHR->bMonth,&ptRTCHR->bDay,
+		&ptRTCHR->bHour,&ptRTCHR->bMin,&ptRTCHR->bSecs) <0) 
+	{
+		iRet = -2;
+	}
+	
+	ptRTCHR->wYear = (unsigned short)bYear ;
+	ptRTCHR->wYear += gwDefaultStartYear;
+	
+	return iRet;
+}
+
+int rtc_get (struct rtc_time *tm)
+{
+	return 0;
+}
+
+int rtc_set (struct rtc_time *tm)
+{
+	return 0;
+}
+
+void rtc_reset (void) {}
+
+int ntxup_wait_key(unsigned char *pbWaitKeysMaskA,int iIntervalms,int iTimeoutms)
+{
+#if 0
+	int iRet = -1;
+	int iTotalms = 0;
+	unsigned char bReadKeyValA[2];
+	
+	struct kpp_key_info *key_info;
+	int keys, i;
+	int iKeyPressedCnt = 0;
+	
+	unsigned short wKeyVal = 0;
+	
+	mxc_kpp_init();
+	do {
+		udelay(iIntervalms*1000);
+			
+		key_info = 0;
+		keys = mxc_kpp_getc(&key_info);
+		for (i = 0; i < keys; i++) {
+			if (key_info[i].evt == KDepress) {
+				wKeyVal |= 0x1 << key_info[i].val;
+				iKeyPressedCnt++;
+			}
+		}
+		bReadKeyValA[0] = (wKeyVal>>8)&0xff;
+		bReadKeyValA[1] = (wKeyVal)&0xff;
+		if (keys)
+			printf("%d keys,0x%02x,0x%02x\n",keys,bReadKeyValA[0],bReadKeyValA[1]);
+		
+		if( (0==(bReadKeyValA[0]^pbWaitKeysMaskA[0])) && \
+			(0==(bReadKeyValA[1]^pbWaitKeysMaskA[1])) ) 
+		{
+			iRet = 0;
+			break;
+		}
+
+		if(key_info) {
+			free(key_info);
+		}
+		
+		iTotalms += iIntervalms;
+	}while(iTotalms<iTimeoutms) ;
+		
+	return iRet;
+#else
+	return -1;
+#endif
+}
+
+
+int ntxup_wait_key_downloadmode(void) 
+{
+	int iRet=0;
+	iRet = ntx_gpio_key_is_menu_down();	
+	return iRet;
+}
+
+int ntxup_wait_key_esdupg(void) 
+{
+	int iRet=0;
+
+	//printf("%s: gptNtxHwCfg=%p ,pcb=%d,hw pcb id=%d,pcb flags=0x%x\n",__FUNCTION__,gptNtxHwCfg,gptNtxHwCfg->m_val.bPCB,_get_pcba_id(),gptNtxHwCfg->m_val.bPCB_Flags);
+	
+	if(12==gptNtxHwCfg->m_val.bKeyPad) {
+		// model without keypad .
+		return 0;
+	}
+
+	if(NTXHWCFG_TST_FLAG(gptNtxHwCfg->m_val.bPCB_Flags,0)) {
+		// no keymatrix .
+		if( 11==gptNtxHwCfg->m_val.bKeyPad||
+				16==gptNtxHwCfg->m_val.bKeyPad||
+				36==gptNtxHwCfg->m_val.bPCB||
+				40==gptNtxHwCfg->m_val.bPCB) 
+		{
+			// KeyPad Only FL key or KeyPad with HOMEPAD .
+			// do not use touch home key for upgrading . 
+			iRet = ntx_gpio_key_is_fl_down();
+		}
+		else {
+			iRet = ntx_gpio_key_is_home_down();
+		}
+		//printf("%d=ntx_gpio_key_is_home_down()\n",iRet);
+	}
+#ifdef _MX7D_
+#elif defined(_MX6SL_) //][
+#else //][!_MX6SL_
+	else
+	if (16 == gptNtxHwCfg->m_val.bPCB) 
+	{
+		// E6063X .
+		iRet = (ntxup_wait_key(gbEsdUPGKeyVal_E60630,5,20)==0)?1:0;
+	}
+	else 
+	if (18 == gptNtxHwCfg->m_val.bPCB) 
+	{
+		// E5060X .
+		iRet = (ntxup_wait_key(gbEsdUPGKeyVal_E50600,5,20)==0)?1:0;
+	}
+#endif //]_MX6SL_
+	else  
+	{
+		//printf("%s: fail ,pcb=%d, hw_pcb_id =%d\n",__FUNCTION__,gptNtxHwCfg->m_val.bPCB,_get_pcba_id());
+		iRet = (ntxup_wait_key(gbEsdUPGKeyVal_default,5,20)==0)?1:0;
+	}
+
+	return iRet;
+}
+
+void ntx_power_off(void)
+{
+
+	while(1) {
+		printf("---%s(),PMIC=%d ---",__FUNCTION__,gptNtxHwCfg->m_val.bPMIC);
+		if(1==gptNtxHwCfg->m_val.bPMIC) {
+			// RICOH 5T619 ...
+			RC5T619_write_reg(0x0e,0x01);
+		}
+		else {
+			unsigned char bBufA[2]={0x01,0x00};
+			// MSP430 .
+			msp430_write_buf(0x50, bBufA, 2);
+		}
+		udelay(800000);
+	}
+}
+
+
+int zforce_read (unsigned char *data)
+{
+	int iChk=0;
+	int retry = 0;
+	int readCnt;
+	do {
+		iChk = i2c_read(gbZforceI2C_ChipAddr, 0, 1, data, 2);
+		if(0==iChk) {
+			readCnt = data[1];
+			if (0xEE == data[0]) {
+				do {
+					iChk = i2c_read(gbZforceI2C_ChipAddr, 0, 1, data, readCnt);
+				} while ((0 > iChk) && (100 > retry++));
+				printf("zforce read %X %X (%d bytes)\n", data[0], data[1], readCnt);
+				return readCnt;
+			}
+			else
+				printf("zforce frame start not found !\n");
+		}
+		else
+			printf("zforce read failed !\n");
+	} while ((0 > iChk) && (100 > retry++));
+	return -1;
+}
+
+#if 1
+#define DEFAULT_PANEL_W		800
+#define DEFAULT_PANEL_H		600
+#else
+#define DEFAULT_PANEL_W		1440
+#define DEFAULT_PANEL_H		1080
+#endif
+static uint8_t cmd_Resolution_v2[] = {0x05, 0x02, (DEFAULT_PANEL_H&0xFF), (DEFAULT_PANEL_H>>8), (DEFAULT_PANEL_W&0xFF), (DEFAULT_PANEL_W>>8)};
+static const uint8_t cmd_TouchData_v2[] = { 0x01, 0x04};
+static const uint8_t cmd_Frequency_v2[] = { 0x07, 0x08, 10, 00, 100, 00, 100, 00};
+static const uint8_t cmd_Active_v2[] = { 0x01, 0x01};
+static const uint8_t cmd_Dual_touch_v2[] = { 0x05,0x03,1,0,0,0};
+extern int _power_key_status (void);
+
+int ntxup_wait_touch_recovery(void) 
+{
+	int iRet=0;
+	unsigned char data[128];
+	int retry;
+//	unsigned int reg;
+	unsigned int current_i2c_bus;
+
+	int iRLight=0;
+
+#if 0
+	// touch_rst high
+	mxc_request_iomux(MX50_PIN_SD3_D6,
+				IOMUX_CONFIG_ALT1);
+	{
+			// set output .
+			reg = readl(GPIO5_BASE_ADDR + 0x4);
+			reg |= (0x1 << 26);
+			writel(reg, GPIO5_BASE_ADDR + 0x4);
+			
+			// output high .
+			reg = readl(GPIO5_BASE_ADDR + 0x0);
+			reg |= (0x1 << 26);
+			writel(reg, GPIO5_BASE_ADDR + 0x0);		
+	}
+#endif
+	current_i2c_bus = i2c_get_bus_num();
+	if( (46==gptNtxHwCfg->m_val.bPCB && gptNtxHwCfg->m_val.bPCB_REV>=0x10) ||
+			48==gptNtxHwCfg->m_val.bPCB	|| 50==gptNtxHwCfg->m_val.bPCB || 
+			51==gptNtxHwCfg->m_val.bPCB || 55==gptNtxHwCfg->m_val.bPCB ||
+			58==gptNtxHwCfg->m_val.bPCB)
+	{
+		//E60Q9X pcba rev >= 0x10
+		//E60QAX | E60QFX | E60QHX | E70Q0X | E60QJX .
+		i2c_set_bus_num (1);
+	}
+	else {
+		i2c_set_bus_num (0);
+	}
+	if(4==gptNtxHwCfg->m_val.bTouchType) {
+		// IR touch .
+
+		zforce_read (data);
+		if (7 == data[0]) {
+			i2c_write (gbZforceI2C_ChipAddr,0xEE,1,(uchar *)cmd_Active_v2, sizeof(cmd_Active_v2));
+			zforce_read (data);
+			i2c_write (gbZforceI2C_ChipAddr,0xEE,1,(uchar *)cmd_Resolution_v2,sizeof(cmd_Resolution_v2));
+			zforce_read (data);
+			i2c_write (gbZforceI2C_ChipAddr,0xEE,1,(uchar *)cmd_Frequency_v2,sizeof(cmd_Frequency_v2));
+			zforce_read (data);
+			i2c_write (gbZforceI2C_ChipAddr,0xEE,1,(uchar *)cmd_Dual_touch_v2,sizeof(cmd_Dual_touch_v2));
+			zforce_read (data);
+			i2c_write (gbZforceI2C_ChipAddr,0xEE,1,(uchar *)cmd_TouchData_v2,sizeof(cmd_TouchData_v2));
+			zforce_read (data);
+			for (retry=0;retry<100;retry++) {
+				// int dataCnt;
+
+				_led_R(iRLight);iRLight=!iRLight;
+
+				/*dataCnt=*/ zforce_read (data);
+				// FIXME: shouldn't this check dataCnt?
+				if (0 <= iRet && 4 == data[0]) {
+					if (2 == data[1]) {
+						int x,y;
+						unsigned long flag=0;
+						printf ("Got dual finger touched!!\n");
+						x = (data[3]<<8) | data[2];
+						y = (data[5]<<8) | data[4];
+						if (60 > x && (DEFAULT_PANEL_W-60) < y)
+							flag |= 1;
+						if ((DEFAULT_PANEL_H-60) < x && (DEFAULT_PANEL_W-60) < y)
+							flag |= 2;
+						if (60 > x && 60 > y)
+							flag |= 0x10;
+						if ((DEFAULT_PANEL_H-60) < x && 60 > y)
+							flag |= 0x20;
+						x = (data[12]<<8) | data[11];
+						y = (data[14]<<8) | data[13];
+
+						if (60 > x && (DEFAULT_PANEL_W-60) < y)
+							flag |= 1;
+						if ((DEFAULT_PANEL_H-60) < x && (DEFAULT_PANEL_W-60) < y)
+							flag |= 2;
+						if (60 > x && 60 > y)
+							flag |= 0x10;
+						if ((DEFAULT_PANEL_H-60) < x && 60 > y)
+							flag |= 0x20;
+
+						if (3 == flag) {
+							_led_R (1);
+							printf ("Entering recovery mode !!\n");
+							iRet = 1;
+							break;
+						}
+						else if (0x30 == flag) {
+							_led_R (1);
+							printf ("Entering external sd boot mode !!\n");
+							iRet = 2;
+							break;
+						}
+						else if (0x11 == flag) {
+							_led_R (1);
+							printf ("Entering fastboot mode !!\n");
+							iRet = 3;
+							break;
+						}
+						else {
+							printf ("Wrong points combination ! 0x%lx\n",flag);
+						}
+					}
+					else {
+	//					printf ("[%02X %02X %02X %02X %02X %02X %02X %02X %02X]\n",data[1],data[2],data[3],data[4],data[5],data[6],data[7],data[8],data[9]);
+						printf ("Wrong point!\n");
+					}
+				}
+				if (!_power_key_status()) {
+					printf ("Power key released!!\n");
+					break;
+				}
+			}
+		}
+		else {
+			printf("Boot complete not received !!\n");
+		}
+	}
+
+	i2c_set_bus_num (current_i2c_bus);
+
+	return iRet;
+}
+
+static const uint8_t FL100[] = {0x01, 0x8F, 0xFF, 0xFF, 0x01, 0x90, 0x01};
+
+#ifdef _MX7D_
+static NTX_GPIO gtNtxGpio_FL_EN = {
+	MX7D_PAD_ENET1_RGMII_RD1__GPIO7_IO1,
+	7, //  gpio group .
+	1, // gpio number .
+	0, // default output value ,-1=>do not set output value .
+	0, // is initailized .
+	"FL_EN", // name
+	0, // 1:input ; 0:output .
+} ;
+
+static NTX_GPIO *gptNtxGpio_FL_R_EN ;
+static NTX_GPIO *gptNtxGpio_FL_EN=&gtNtxGpio_FL_EN ;
+
+#elif defined(_MX6ULL_) //][
+static NTX_GPIO *gptNtxGpio_FL_R_EN ;
+static NTX_GPIO *gptNtxGpio_FL_EN ;
+
+#elif defined(_MX6SL_) || defined(_MX6SLL_) //][
+
+static NTX_GPIO gtNtxGpio_FL_R_EN = {
+	MX6_PAD_EPDC_SDCE2__GPIO1_IO29,
+	1, //  gpio group .
+	29, // gpio number .
+	1, // default output value ,-1=>do not set output value .
+	0, // is initailized .
+	"FL_R_EN", // name
+	0, // 1:input ; 0:output .
+} , *gptNtxGpio_FL_R_EN = &gtNtxGpio_FL_R_EN ;
+
+static NTX_GPIO gtNtxGpio_FL_EN = {
+	MX6_PAD_EPDC_PWR_CTRL3__GPIO2_IO10,
+	2, //  gpio group .
+	10, // gpio number .
+	0, // default output value ,-1=>do not set output value .
+	0, // is initailized .
+	"FL_EN", // name
+	0, // 1:input ; 0:output .
+} ;
+static NTX_GPIO *gptNtxGpio_FL_EN=&gtNtxGpio_FL_EN ;
+
+#elif defined (_MX50_) //][
+
+static NTX_GPIO gtNtxGpio_FL_R_EN = {
+	MX50_PIN_EPDC_VCOM1, // pin name .
+	IOMUX_CONFIG_ALT1, // pin config .
+	0, // pad config .
+	4, //  gpio group .
+	22, // gpio number .
+	1, // default output value ,-1=>do not set output value .
+	0, // is initailized .
+	"FL_R_EN", // name
+	0, // 1:input ; 0:output .
+} ;
+static NTX_GPIO gtNtxGpio_FL_EN = {
+	MX50_PIN_ECSPI1_MISO, // pin name .
+	IOMUX_CONFIG_ALT1, // pin config .
+	0, // pad config .
+	4, //  gpio group .
+	14, // gpio number .
+	0, // default output value ,-1=>do not set output value .
+	0, // is initailized .
+	"FL_EN", // name
+	0, // 1:input ; 0:output .
+} ;
+
+static NTX_GPIO *gptNtxGpio_FL_EN=&gtNtxGpio_FL_EN ;
+
+#endif //]
+
+
+
+
+void frontLightCtrl(void){
+	if(0==gptNtxGpio_FL_EN) {
+		return;
+	}
+
+	if(NTXHWCFG_TST_FLAG(gptNtxHwCfg->m_val.bFrontLight_Flags,0)){
+//		unsigned int reg;
+
+		printf("turning on FL\n");
+		if(NTXHWCFG_TST_FLAG(gptNtxHwCfg->m_val.bFrontLight_Flags,2)) {
+			// FRONT LIGHT EN control invert (high enable).
+			gptNtxGpio_FL_EN->iDefaultValue = 1;
+		}
+		else {
+			// FRONT LIGHT EN control invert (low enable).
+			gptNtxGpio_FL_EN->iDefaultValue = 0;
+		}
+		if (50 == gptNtxHwCfg->m_val.bPCB)
+			ntx_gpio_init(gptNtxGpio_FL_EN);
+	
+		msp430_write_reg(0xA7,FL100[0]);
+		msp430_write_reg(0xA6,FL100[1]);
+     
+		msp430_write_reg(0xA1,FL100[2]);
+		msp430_write_reg(0xA2,FL100[3]);
+		msp430_write_reg(0xA5,FL100[4]);
+		msp430_write_reg(0xA4,FL100[5]);
+		msp430_write_reg(0xA3,FL100[6]);
+
+	
+		if(gptNtxGpio_FL_R_EN) {
+			ntx_gpio_init(gptNtxGpio_FL_R_EN);
+		}
+		if (50 != gptNtxHwCfg->m_val.bPCB)
+			ntx_gpio_init(gptNtxGpio_FL_EN);
+
+	}
+	else {
+		// turn off the FL .
+		if(NTXHWCFG_TST_FLAG(gptNtxHwCfg->m_val.bFrontLight_Flags,2)) {
+			// FRONT LIGHT EN control invert (high enable).
+			gptNtxGpio_FL_EN->iDefaultValue = 0;
+		}
+		else {
+			// FRONT LIGHT EN control invert (low enable).
+			gptNtxGpio_FL_EN->iDefaultValue = 0;
+			gptNtxGpio_FL_EN->iDirection = 1;
+		}
+		ntx_gpio_init(gptNtxGpio_FL_EN);
+	}
+}
+
+static int do_ntxup(cmd_tbl_t * cmdtp, int flag, int argc, char *const argv[])
+{
+	int iRet = 0;
+	int iChk ;
+	unsigned char bBufA[2];
+	
+	if(argc<2) {
+		printf("%s:argc<2\n\t%s\n",__FUNCTION__,cmdtp->usage);
+		return -1;
+	}
+
+	if(0==strcmp(argv[1],"init")) {
+		iRet = ntxup_init();
+	}
+	else 
+	if(0==strcmp(argv[1],"release")) {
+		iRet = init_pwr_i2c_function(1);
+	}
+	else
+	if(0==strcmp(argv[1],"getkey")) {
+		
+		if(!giIsMicroP_inited) {
+			ntxup_init();
+		}
+
+
+		iChk = i2c_read(0x43, 0x42, 1, bBufA, 2);
+		if(0==iChk) {
+			// success .
+			printf("keyval=0x%02x%02x\n",bBufA[0],bBufA[1]);
+		}
+		else {
+			printf("microp key read fail !\n");
+		}
+	}
+	else
+	if(0==strcmp(argv[1],"extcard_st")) {
+		if(ntxup_is_ext_card_inserted()) {
+			printf("inserted\n");
+		}
+		else {
+			printf("NoCard\n");
+		}
+	}
+	else
+	if(0==strcmp(argv[1],"waitkey")) {
+		ntxup_wait_key_esdupg();
+	}
+	else
+	if(0==strcmp(argv[1],"waittouch")) {
+		ntxup_wait_touch_recovery();
+	}
+	else {
+	}
+	return iRet;
+}
+
+U_BOOT_CMD(ntxup, 6, 0, do_ntxup,
+	"ntxup - netronix microp commands\n",
+	"ntxup init"
+		" - ntxup initial : initial bus & protocols .\n"
+	"ntxup release"
+		" - ntxup release : release bus & protocols .\n"
+	"ntxup getkey"
+		" - ntxup get key value without wait .\n"
+	"ntxup extcard_st"
+		" - ntxup get external card status \"inserted\" or \"NoCard\" .\n"
+	"ntxup waitkey [keyvalue] [interval (ms)] [timeout (ms)]"
+		" - polling key each interval and wait until key pressed .\n"
+	"ntxup waittouch [interval (ms)] [timeout (ms)]"
+		" - polling touch each interval and wait until touch pressed .\n"
+);
+
+
+//#define PMIC_TPS65185	1
+#ifdef PMIC_TPS65185
+
+#define TPS65185_RET_SUCCESS				(0)
+#define TPS65185_RET_I2CTRANS_ERR 	(-1)
+
+static const unsigned char gbI2C_ADDR_TPS65185 = 0x68; 
+static unsigned char gbTPS65185_version;
+
+typedef struct tagTPS65185_VERSIONS{
+	unsigned char bMajor;
+	unsigned char bMinor;
+	unsigned char bVersion;
+	unsigned char bRevID;
+} TPS65185_VERSIONS;
+
+
+static int tps65185_get_reg(unsigned char bRegAddr,unsigned char  *O_pbRegVal)
+{
+	int iRet=TPS65185_RET_SUCCESS;
+	int iChk;
+	unsigned char bA[1] ;
+
+	char cCmdA[256];
+	int iCur_I2C_Chn=(int)(gdwBusNum+1);
+	int iTPS65185_I2C_Chn = GET_I2C_CHN_TPS65185();
+
+	//ASSERT(O_pbRegVal);
+	//
+	if( iCur_I2C_Chn != iTPS65185_I2C_Chn ) {
+		sprintf(cCmdA,"i2c dev %d",(iTPS65185_I2C_Chn-1));
+		run_command(cCmdA,0);
+		//printf(cCmdA);printf("\n");
+		udelay(10*1000);
+	}
+
+
+	bA[0]=bRegAddr;
+	
+	iChk = i2c_read(gbI2C_ADDR_TPS65185, (int)bRegAddr, 1,bA , 1);
+	if (iChk != 0) {
+		//ERR_MSG("%s(%d):%s i2c_master_send fail !\n",__FILE__,__LINE__,__FUNCTION__);
+		iRet = TPS65185_RET_I2CTRANS_ERR;
+		goto exit;
+	}
+
+	if(O_pbRegVal) {
+		*O_pbRegVal = bA[0];
+	}
+
+exit:
+
+	if( iCur_I2C_Chn != iTPS65185_I2C_Chn ) {
+		sprintf(cCmdA,"i2c dev %d",(iCur_I2C_Chn-1));
+		run_command(cCmdA,0);
+		//printf(cCmdA);printf("\n");
+		udelay(10*1000);
+	}
+
+	return iRet;
+}
+
+static int tps65185_get_versions(TPS65185_VERSIONS *O_pt65185ver)
+{
+	int iRet=TPS65185_RET_SUCCESS;
+	int iChk;
+	unsigned short wReg;
+	unsigned char bReg;
+
+	//ASSERT(O_pt65185ver);
+
+	iChk = tps65185_get_reg(0x10,&bReg);
+	if(iChk<0) {
+		//printf("%d=tps65185_get_reg() fail !\n",iChk);
+	}
+	else {
+		gbTPS65185_version = bReg;
+	}
+
+
+	iRet = iChk;
+	if(O_pt65185ver&&iChk>=0) {
+		O_pt65185ver->bMajor = (bReg>>6)&0x3;
+		O_pt65185ver->bMinor  = (bReg>>4)&0x3;
+		O_pt65185ver->bVersion = (bReg)&0xf;
+		O_pt65185ver->bRevID = bReg;
+	}
+
+	return iRet;
+}
+
+static int do_get_epdpmic_ver(cmd_tbl_t * cmdtp, int flag, int argc, char *const argv[])
+{
+	int iRet = 0;
+	TPS65185_VERSIONS tTPS65185_ver;
+
+	iRet = tps65185_get_versions(&tTPS65185_ver);
+	if(iRet<0) {
+		printf("cannnot get EPD PMIC version (%d)!!\n",iRet);
+	}
+	else {
+		printf("EPD PMIC version=0x%x\n",tTPS65185_ver.bRevID);
+	}
+
+	return iRet;
+}
+
+
+U_BOOT_CMD(get_epdpmic_ver, 2, 0, do_get_epdpmic_ver,
+	"get_epdpmic_ver - get EPD PMIC version \n",
+	"get_epdpmic_ver "
+		" - get EPD PMIC version .\n"
+);
+
+
+
+#endif //] PMIC_TPS65185
+
+
+
+#if 0
+// gallen add 2011/03/31 [
+#define TOTAL_KEY	16
+static char *gszKeyStringA[TOTAL_KEY] = {
+	"[S01]","[S02]","[S03]","[S04]",
+	"[S05]","[S06]","[S07]","[S08]",
+	"[S09]","[S10]","[S11]","[S12]",
+	"[S13]","[S14]","[S15]","[S16]"
+};
+#endif
+
+#ifndef CONFIG_MXC_KPD
+
+inline int test_key(int value, struct kpp_key_info *ki)
+{
+	return (ki->val == value) && (ki->evt == KDepress);
+}
+#endif //] CONFIG_MXC_KPD
+
+static int do_mf_key(cmd_tbl_t * cmdtp, int flag, int argc, char *const argv[])
+{
+//	struct kpp_key_info *key_info;
+//	int keys;
+	int i;
+	int iKeyPressedCnt = 0;
+	int iCurrentHallSensorState;
+	
+	int iChk;
+
+	iCurrentHallSensorState = _hallsensor_status();
+	if(iCurrentHallSensorState!=giCurrentHallSensorState) {
+		printf("fail: [S17]\n\r");
+		iKeyPressedCnt++;
+		giCurrentHallSensorState = iCurrentHallSensorState;
+	}
+	
+	
+	if(NTXHWCFG_TST_FLAG(gptNtxHwCfg->m_val.bPCB_Flags,0)) 
+	{
+		//if( 12 != gptNtxHwCfg->m_val.bKeyPad ) 
+		{
+			// not NO_Key ...
+			for(i=0;i<gi_ntx_gpio_keys;i++) {
+
+				if(0==ntx_gpio_keysA[i]) {
+					continue ;
+				}
+
+				iChk = ntx_gpio_key_is_down(ntx_gpio_keysA[i]);
+				if(1==iChk) {
+					// key down .
+					printf("fail: %s\n\r",ntx_gpio_keysA[i]->pszName);
+					iKeyPressedCnt++;
+				}
+				else if(0==iChk) {
+					// key up .
+				}
+				else {
+					// error !! .
+				}
+			}
+		}
+	}
+
+#if 0
+	else {
+		mxc_kpp_init();
+		udelay (1000);
+		keys = mxc_kpp_getc(&key_info);
+		for (i = 0; i < keys; i++) {
+			if (key_info[i].evt == KDepress) {
+				printf("fail: %s\n\r",gszKeyStringA[key_info[i].val]);
+				iKeyPressedCnt++;
+			}
+		}
+		free(key_info);
+	}
+#endif
+
+	if(0==iKeyPressedCnt) {
+		printf("pass\n\r");
+	}
+	return 0;
+}
+
+U_BOOT_CMD(mf_key, 2, 0, do_mf_key,
+	"mf_key - ntx key test \n",
+	"mf_key "
+		" - ntx key test .\n"
+);
+//] gallen add 2011/03/31
+
+
+static int do_mf_rtc(cmd_tbl_t * cmdtp, int flag, int argc, char *const argv[])
+{
+	int iRet = 0;
+	RTC_HR tRTC_HR;
+	
+	if(argc==7) {
+		tRTC_HR.wYear = simple_strtoul(argv[1], NULL, 10);
+		tRTC_HR.bMonth = simple_strtoul(argv[2], NULL, 10);
+		tRTC_HR.bDay = simple_strtoul(argv[3], NULL, 10);
+		tRTC_HR.bHour = simple_strtoul(argv[4], NULL, 10);
+		tRTC_HR.bMin = simple_strtoul(argv[5], NULL, 10);
+		tRTC_HR.bSecs = simple_strtoul(argv[6], NULL, 10);
+		
+		if(ntxup_rtc_set(&tRTC_HR)<0) {
+			printf("RTC set Error 1\n\n");
+			iRet = -1;
+		}
+		else {
+			printf("\rSet time %04d/%02d/%02d %02d:%02d:%02d\n\r",
+				tRTC_HR.wYear,tRTC_HR.bMonth,tRTC_HR.bDay,
+				tRTC_HR.bHour,tRTC_HR.bMin,tRTC_HR.bSecs);
+		}
+		
+	}
+	else if(argc==1) {
+
+		if(ntxup_rtc_get(&tRTC_HR)<0) {
+			printf("RTC get Error 1\n\n");
+			iRet = -2;
+		}
+		else {
+			printf("\r%04d/%02d/%02d %02d:%02d:%02d\n\r",
+				tRTC_HR.wYear,tRTC_HR.bMonth,tRTC_HR.bDay,
+				tRTC_HR.bHour,tRTC_HR.bMin,tRTC_HR.bSecs);
+		}
+	}
+	else {
+		printf("parameter cnt error argc=%d !\n",argc);
+	}
+	
+	
+
+	return iRet;
+}
+
+U_BOOT_CMD(mf_rtc, 7, 0, do_mf_rtc,
+	"mf_rtc - rtc date/time set/get \n",
+	"mf_rtc "
+		" - rtc date/time get .\n"
+	"mf_rtc <year> <month> <day> <hour> <min> <sec> "
+		" - rtc date/time set .\n"
+);
+
+static int do_mf_sd_wp(cmd_tbl_t * cmdtp, int flag, int argc, char *const argv[])
+{
+	int iRet = 0;
+#if 0
+	unsigned char bEvent;
+	int iIsWriteProtected = 0;
+	
+	if(ntxup_get_CtrlEvent(&bEvent,0)>=0) {
+		if(gptNtxHwCfg&&1==gptNtxHwCfg->m_val.bExternalMem) {
+			// external memory is SD card .
+			extern int esd_wp_read(void);
+			
+			iIsWriteProtected = esd_wp_read();
+			if(bEvent&EVENT_REG_BIT_ESDIN) {
+				if(iIsWriteProtected) {
+					printf("\rSD in :enabled\n\r");
+				}
+				else {
+					printf("\rSD in :disabled\n\r");
+				}
+			}
+			else {
+				if(iIsWriteProtected) {
+					printf("\rSD out :enabled\n\r");
+				}
+				else {
+					printf("\rSD out :disabled\n\r");
+				}
+			}
+		}
+		else {
+			// No external , micro sd or Nand flash .
+			if(bEvent&EVENT_REG_BIT_ESDIN) {
+				printf("\rSD in :disabled\n\r");
+			}
+			else {
+				printf("\rSD out :enabled\n\r");
+			}
+		}
+	}
+	else {
+		// get value from microp fail ! .
+		iRet = -1;
+	}
+#else
+	if(ntxup_is_ext_card_inserted()) {
+		printf("\rSD in :disabled\n\r");
+	}
+	else {
+		printf("\rSD out :enabled\n\r");
+	}
+#endif
+	return iRet;
+}
+
+U_BOOT_CMD(mf_sd_wp, 1, 0, do_mf_sd_wp,
+	"mf_sd_wp - external sd card info \n",
+	"mf_sd_wp "
+		" - extern sd card info .\n"
+);
+
+
+static int do_mf_adc(cmd_tbl_t * cmdtp, int flag, int argc, char *const argv[])
+{
+	int iRet = 0;
+	unsigned short wADC;
+	
+	if(ntxup_get_adcvalue(&wADC)>=0) {
+		iRet = (int)wADC;
+		printf("%d\n\r", iRet);
+	}
+	else {
+		iRet = -1;
+	}
+
+	return iRet;
+}
+
+U_BOOT_CMD(mf_adc, 1, 0, do_mf_adc,
+	"mf_adc - get adc value \n",
+	"mf_adc "
+		" - get adc value .\n"
+);
+
+#if 0
+// gallen add 2011/03/02 [
+#define NTX_BOOTMODE_NA		(-1)
+#define NTX_BOOTMODE_ISD	0 // internal sd boot ,internal kernel,root @ internal sdcard partition 1.
+#define NTX_BOOTMODE_ESD	1 // external sd boot ,detect external kernel or use internal kernel , root @ external sdcard partition 2.
+
+static int giNtxBootMode = NTX_BOOTMODE_NA ;
+
+static int do_load_ntxbins(cmd_tbl_t * cmdtp, int flag, int argc, char *const argv[])
+{
+	int iRet = 0;
+	char cAppendStr[128];
+	
+	if(NTX_BOOTMODE_NA == giNtxBootMode) {
+		giNtxBootMode = _detect_bootmode_and_append_boot_args(gszBootArgs,BOOTARGS_BUG_SIZE);
+	}
+	
+	_load_ntxbins_and_append_boot_args(gszBootArgs,BOOTARGS_BUG_SIZE);
+	
+	setenv("bootargs",gszBootArgs);	
+	return iRet;
+}
+
+U_BOOT_CMD(load_ntxbins, 2, 0, do_load_ntxbins,
+	"load_ntxbins - netronix binaries load \n",
+	"load_ntxbins "
+		" - load netronix binaries from sd card (hwcfg,logo,waveform).\n"
+);
+//] gallen add 2011/03/02
+#endif
+
+// gallen add 2011/03/31 [
+static int do_get_PCBA_id(cmd_tbl_t * cmdtp, int flag, int argc, char *const argv[])
+{
+	int iRet = 0;
+	
+	if(!gptNtxHwCfg) {
+		run_command("load_ntxbins",0);
+	}
+	
+	if(gptNtxHwCfg) {
+		printf("PCBA_ID:%d\n",gptNtxHwCfg->m_val.bPCB);
+	}
+	else {
+		printf("PCBA_ID:-1\n");
+	}
+	return iRet;
+}
+
+U_BOOT_CMD(get_PCBA_id, 2, 0, do_get_PCBA_id,
+	"get_PCBA_id - get PCBA id \n",
+	"get_PCBA_id "
+		" - get netronix PCBA id .\n"
+);
+//] gallen add 2011/03/31
+
+static int do_get_up_ver(cmd_tbl_t * cmdtp, int flag, int argc, char *const argv[])
+{
+	int iRet = 0;
+	iRet = ntxup_init();
+	return iRet;
+}
+
+
+U_BOOT_CMD(get_up_ver, 2, 0, do_get_up_ver,
+	"get_up_ver - get microp version \n",
+	"get_up_ver "
+		" - get microp version .\n"
+);
+
+#include <mmc.h>
+
+static int card_get_capacity_size(void)
+{
+	int iRet = 0;
+	struct mmc *mmc;
+	
+#if 0
+	mmc = find_mmc_device(_get_boot_sd_number());
+#else
+	mmc = find_mmc_device(0);
+#endif
+	
+	if (mmc) {
+		if (mmc_init(mmc))
+			puts("MMC card init failed!\n");
+		else
+			iRet = mmc->capacity>>10;
+	}
+	
+	return iRet;
+}
+
+
+static int do_nandinfo(cmd_tbl_t * cmdtp, int flag, int argc, char *const argv[])
+{
+	int iRet = 0;
+	int cardsize = card_get_capacity_size();
+	
+	_led_R (1);
+	_led_G (1);
+	_led_B (1);
+	
+	if (7000000 < cardsize)
+		cardsize = 8;
+	else if (3000000 < cardsize)
+		cardsize = 4;
+	else if (1500000 < cardsize)
+		cardsize = 2;
+	else 
+		cardsize = 1;
+
+    printf("\r[SD card] %dGB\n\r\n\r", cardsize);	
+
+	return iRet;
+}
+
+U_BOOT_CMD(nandinfo, 2, 0, do_nandinfo,
+	"nandinfo - get nand flash information .\n",
+	"nandinfo "
+		" - get get nand flash information .\n"
+);
+
+static int do_hallsensor(cmd_tbl_t * cmdtp, int flag, int argc, char *const argv[])
+{
+	int iRet = 0;
+	int iHallSensorState,iWaitState;
+
+	if(argc>1&&argc<=3) {
+		if(0==strcmp(argv[1],"wait")) {
+			if(3==argc) {
+				iWaitState = (argv[2][0]=='0')?0:1;
+			}
+			else {
+				iHallSensorState = _hallsensor_status();
+				iWaitState = iHallSensorState?0:1;
+			}
+			
+			do {
+				iHallSensorState = _hallsensor_status();
+			} while(iHallSensorState!=iWaitState);
+			printf("%d\n",iHallSensorState);
+		}
+	}
+	else {
+		printf("%d\n",_hallsensor_status());
+	}
+	return iRet;
+}
+
+U_BOOT_CMD(hallsensor, 3, 0, do_hallsensor,
+	"hallsensor - get hallsensor state .\n",
+	"hallsensor wait [waitstate] .\n"
+		" - get the hallsensor state until hallsensor state = [waitstate] (block mode) .\n"
+	"hallsensor wait .\n"
+		" - get the hallsensor state until hallsensor state changed (block mode) .\n"
+	"hallsensor"
+		" - get the hallsensor state (nonblock mode) .\n"
+);
+
+static int do_wifi_3v3(cmd_tbl_t * cmdtp, int flag, int argc, char *const argv[])
+{
+	int iRet = 0;
+	extern void wifi_3v3(int);
+
+	if(argc==2) {
+		if(0==strcmp(argv[1],"1")) {
+			printf("wifi 3v3 output 1\n");
+			wifi_3v3(1);
+		}
+		else {
+			printf("wifi 3v3 output 0\n");
+			wifi_3v3(0);
+		}
+	}
+	else {
+		printf("%s() : parameter error \n",__FUNCTION__);
+	}
+	return iRet;
+}
+
+U_BOOT_CMD(wifi_3v3, 2, 0, do_wifi_3v3,
+	"wifi_3v3 - wifi 3v3 output .\n",
+	"wifi_3v3 [1/0] .\n"
+		" - set wifi 3v3 output 1/0 .\n"
+);
+
+static int do_ledG(cmd_tbl_t * cmdtp, int flag, int argc, char *const argv[])
+{
+	int iRet = 0;
+
+	if(argc==2) {
+		if(0==strcmp(argv[1],"1")) {
+			printf("LED G ON\n");
+			_led_G(1);
+		}
+		else 
+		if(0==strcmp(argv[1],"0")) {
+			printf("LED G OFF\n");
+			_led_G(0);
+		}
+	}
+	else {
+		printf("%s() : parameter error \n",__FUNCTION__);
+	}
+	return iRet;
+}
+
+U_BOOT_CMD(ledG, 2, 0, do_ledG,
+	"ledG - ON/OFF Green LED .\n",
+	"ledG [1/0] .\n"
+		" - ON(1)/OFF(0) Green LED .\n"
+);
+
+
+#if defined(CONFIG_ANDROID_SUPPORT) && defined(CONFIG_CMD_EXT4)
+static int do_get_droid_ver(cmd_tbl_t * cmdtp, int flag, int argc, char *const argv[])
+{
+	int iRet = 0;
+
+	char *filename = NULL;
+	//char *ep;
+	int dev, part = -1;
+	//ulong part_length;
+	int filelen;
+	unsigned long chklen;
+	//disk_partition_t info;
+	//block_dev_desc_t *dev_desc = NULL;
+	//char buf [12];
+	//unsigned long count;
+	//char *addr_str;
+	//
+	char *pcMatch,*pcMatchValue,*pc;
+	//char cStore;
+	int iLen;
+	
+	char *pcBuildPropBuf,*pcBuildPropBufEnd,*pcPropName=0;
+	char *cmdline,*cmdline_end;
+
+	int iDebug=0;
+
+
+	filename = "/build.prop" ;
+	//count = 0;
+	//dev = GET_ISD_NUM();
+	dev=0;
+
+	cmdline = getenv("bootargs_base");
+	cmdline_end=cmdline + strlen(cmdline);
+	if(iDebug) {
+		printf("bootargs_base=%s\n",cmdline);
+	}
+
+	pcMatch = strstr(cmdline,"root=");
+	if(pcMatch) {
+		iLen = strlen("root=");
+
+		// 
+		pcMatchValue = pcMatch+iLen ;
+		pc = pcMatchValue;
+		while(pc<cmdline_end) {
+			if(0==*pc) {
+				break;
+			}
+			if( 0x0a==*pc || 0x0d==*pc || ' '==*pc) {
+				break;
+			}
+			pc++;
+		}
+
+		if(iDebug) {
+			printf("root=%s\n",pcMatchValue);
+		}
+
+		if('/'==pcMatchValue[0] && 
+			 'd'==pcMatchValue[1] && 
+			 'e'==pcMatchValue[2] &&
+			 'v'==pcMatchValue[3] &&
+			 '/'==pcMatchValue[4] &&
+			 'm'==pcMatchValue[5] &&
+			 'm'==pcMatchValue[6] &&
+			 'c'==pcMatchValue[7] &&
+			 'b'==pcMatchValue[8] &&
+			 'l'==pcMatchValue[9] &&
+			 'k'==pcMatchValue[10] ) 
+		{
+			dev = (int)(pcMatchValue[11]-'0');
+			part = (int)(pcMatchValue[13]-'0');
+		}
+		else 
+		{
+			printf ("[ERROR] kernel cmdline 'root=' not /dev/mmcblk !!\n");
+		}
+	}
+	
+
+ 	if(-1==part) {
+		// locate rootfs partition no.
+		switch(gptNtxHwCfg->m_val.bSysPartType) {
+		case 0://TYPE1
+		case 2://TYPE3
+		case 4://TYPE5
+		case 5://TYPE6
+			part = 1;
+			break;
+		case 1://TYPE2
+		case 3://TYPE4
+		case 6://TYPE7
+		case 7://TYPE8,system@p2
+		case 9://TYPE10,system@p2
+			part = 2;
+			break;
+		case 12://TYPE13
+			part = 3;
+			break;
+		case 8://TYPE9
+		case 10://TYPE11
+		case 11://TYPE12
+			//system@p5
+			part = 5;
+			break;
+		default:
+			part = 0;
+			break;
+		}
+	}
+
+
+
+	do {
+
+		if(iDebug) {
+			printf("%s:Using device mmc%d, partition %d\n",
+				__FUNCTION__, dev, part);
+		}
+
+
+		filelen = ntx_get_file_size_in_ext4(dev,part,filename);
+
+		pcBuildPropBuf = malloc(filelen);
+		if(0==pcBuildPropBuf) {
+			printf("[ERROR] memory not enought !!!,request %d bytes failed !!\n",filelen);
+			iRet = -11;break;
+		}
+		pcBuildPropBufEnd = pcBuildPropBuf+filelen;
+
+		iRet = ntx_read_file_in_ext4(dev,part,filename,&chklen,pcBuildPropBuf,filelen);
+		/* Loading ok, update default load address */
+
+		if(iDebug) {
+			printf ("%lu bytes read ok\n", chklen);
+		}
+	}while(0);
+
+	if(iRet<0) {
+		if(pcBuildPropBuf) {
+			free(pcBuildPropBuf);pcBuildPropBuf=0;
+		}
+		return iRet;
+	}
+
+
+
+	if(argc==2) {
+		pcPropName = argv[1];
+	}
+	else {
+		pcPropName = "ro.build.display.id";
+	}
+
+	if(pcPropName) {
+		pcMatch = strstr(pcBuildPropBuf,pcPropName);
+
+		if(pcMatch) {
+			iLen = strlen(pcPropName);
+			// 
+			pcMatchValue = pcMatch+iLen+1 ;
+			pc = pcMatchValue;
+			while(pc<pcBuildPropBufEnd) {
+				if(0==*pc) {
+					break;
+				}
+				if( 0x0a==*pc || 0x0d==*pc ) {
+					//cStore = *pc;
+					*pc = 0;
+					break;
+				}
+				pc++;
+			}
+			printf("%s\n\r",pcMatchValue);
+		}
+		else {
+			iRet = -12;
+		}
+	}
+	else {
+	}
+	
+	if(pcBuildPropBuf) {
+		free(pcBuildPropBuf);pcBuildPropBuf=0;
+	}
+	
+	return iRet;
+}
+
+
+U_BOOT_CMD(get_droid_ver, 2, 0, do_get_droid_ver,
+	"get_droid_ver - get android version \n",
+	"get_droid_ver [version field]"
+		"get_droid_ver - get android versions (ro.build.display.id).\n"
+		"get_droid_ver ro.build.display.id - get android ro.build.display.id in build.prop\n"
+		"get_droid_ver ro.build.version.release - get android ro.build.version.release in build.prop .\n"
+		"....\n"
+);
+
+#endif //]CONFIG_CMD_EXT4
+
+
+static int do_ricoh_reg(cmd_tbl_t * cmdtp, int flag, int argc, char *const argv[])
+{
+	{
+		unsigned char reg, val;
+
+		if (2 == argc) {
+			reg = simple_strtoul(argv[1], NULL, 16);
+			RC5T619_read_reg(reg, &val);
+			printf ("reg 0x%02X, value is 0x%02X\n",reg,val);
+			return 0;
+		}
+		else if (3 == argc) {
+			reg = simple_strtoul(argv[1], NULL, 16);
+			val = simple_strtoul(argv[2], NULL, 16);
+			RC5T619_write_reg(reg, val);
+			printf ("write reg 0x%02X, 0x%02X\n",reg,val);
+			return 0;
+
+		}
+		for (reg=0;reg < 0xFF; reg++) {
+			RC5T619_read_reg(reg, &val);
+			printf ("reg 0x%02X, 0x%02X\n",reg,val);
+		}
+	}
+	return 0;
+}
+
+U_BOOT_CMD(ricoh_reg, 3, 0, do_ricoh_reg,
+	"ricoh_reg -  read / write ricoh register .\n",
+	"ricoh_reg [register] [value] .\n"
+		"\n"
+);
+
+
diff --git a/board/freescale/mx6sll_kobo_clara_hd/ntx_comm.c b/board/freescale/mx6sll_kobo_clara_hd/ntx_comm.c
new file mode 100644
index 0000000000..c2842d9135
--- /dev/null
+++ b/board/freescale/mx6sll_kobo_clara_hd/ntx_comm.c
@@ -0,0 +1,3046 @@
+
+/* 
+ * U-BOOT,.c  .
+ * 
+ * 
+ */
+
+#include <mmc.h>
+
+
+#include <ext_common.h>
+#include <ext4fs.h>
+#include <common.h>
+#include <timer.h>
+
+#ifdef CONFIG_FASTBOOT
+	#include <fastboot.h>
+#endif
+#ifdef CONFIG_FSL_FASTBOOT
+	#include <fsl_fastboot.h>
+#endif
+#include "ntx_hwconfig.h"
+#include "ntx_hw.h"
+
+#define ASSERT(x)	if(!(x))printf("\n\n[WARNING]\nassertion (%s) failed !!!\n\n\n",#x)
+//#define DEBUG
+//#include <common.h>
+
+#define USB_OTG_FASTBOOT_MODE		1// enter fastboot mode by USB OTG .
+#define FASTBOOT_TIMEOUT_SETTING	1
+
+#define MMC_CMD_SEPERATED_SDNUM		1// run mmc command with seperated sd number .
+
+// binaries sector number of sd card .
+#define SD_OFFSET_SECS_KERNEL		2048
+#define SD_OFFSET_SECS_INITRD		12288
+#define SD_OFFSET_SECS_INITRD2		8192
+#ifdef _MX6Q_
+	#define SD_OFFSET_SECS_HWCFG		1524
+#else 
+	#define SD_OFFSET_SECS_HWCFG		1024
+#endif
+#define SD_OFFSET_SECS_WAVEFORM		14336
+#define SD_OFFSET_SECS_LOGO			18432
+#define SD_OFFSET_SECS_LOGO2			34816
+#define SD_OFFSET_SECS_DTB		1286
+
+#ifdef ADVANCE_WAVEFORM_FILE
+	#define SD_OFFSET_SECS_BOOTWAVEFORM		SD_OFFSET_SECS_WAVEFORM
+#else
+	#define SD_OFFSET_SECS_BOOTWAVEFORM		55296
+#endif
+
+#define SD_OFFSET_SECS_NTXFW		1030
+
+#define SD_OFFSET_SECS_SNMAC		1
+//#define SD_OFFSET_SECS_SN		1
+
+#define DEFAULT_LOAD_KERNEL_SZ	9*1024
+#define DEFAULT_LOAD_RD_SZ	8192
+//#define KERNEL_RAM_ADDR		CONFIG_LOADADDR
+
+
+//#define MAC_BOFFSET_IN_SNMAC_SECTOR		128
+
+//#define USE_HWCONFIG
+
+#ifdef USE_HWCONFIG
+#else
+const char gszNtxHwCfgMagic[]="HW CONFIG ";// hw config tool magic .
+
+const char * gszPCBA[]={ 
+	"E60800","E60810","E60820","E90800","E90810", //  0~4 
+	"E60830","E60850","E50800","E50810","E60860", //  5~9
+	"E60MT2","E60M10","E60610","E60M00","E60M30", // 10~14
+	"E60620","E60630","E60640","E50600","E60680", // 15~19
+	"E60610C","E60610D","E606A0","E60670","E606B0", // 20~24
+	"E50620","Q70Q00","E50610","E606C0","E606D0", // 25~29
+	"E606E0","E60Q00","E60Q10","E60Q20","E606F0",	// 30~34
+	"E606F0B","E60Q30","E60QB0","E60QC0","A13120",// 35~39
+	"E60Q50","E606G0","E60Q60","E60Q80","A13130",// 40~44
+	"E606H2","E60Q90","ED0Q00","E60QA0","E60QD0",// 45~49
+	"E60QF0","E60QH0","E60QG0","H70000","ED0Q10",// 50~54 
+	"E70Q00","H40000","NC","E60QJ0","E60QL0",// 55~59
+	"E60QM0", // 60~65
+};
+#endif
+
+#define NTX_HWCFG_PRELOAD_ADDR	0x9FFFFE00
+#define NTX_SN_PRELOAD_ADDR			0x9FFFFC00
+
+const static unsigned char gszNtxBinMagicA[4]={0xff,0xf5,0xaf,0xff};
+
+
+volatile NTX_HWCONFIG *gptNtxHwCfg=0,gtEsdNtxHwCfg,*gptEsdNtxHwCfg=0;
+unsigned long gdwNtxHwCfgSize = 0,gdwEsdNtxHwCfgSize = 0;
+#define NTX_HWCFG_SRC_SDMMC		0
+#define NTX_HWCFG_SRC_RAM			1
+volatile int giNtxHwCfgSrc = NTX_HWCFG_SRC_SDMMC;
+
+volatile unsigned char *gpbWaveform,*gpbLogo;
+volatile unsigned long gdwWaveformSize,gdwLogoSize;
+
+
+
+#define BOOTARGS_BUF_SIZE	1024	
+//char gszBootArgs[BOOTARGS_BUF_SIZE]="root=/dev/mmcblk0p1 noinitrd rootdelay=1 rw rootfstype=ext3 console=ttyS0,115200 uart_dma";
+//char gszBootArgs[BOOTARGS_BUF_SIZE]="noinitrd rw rootfstype=ext3 console=ttyS0,115200 uart_dma";
+char gszBootArgs[BOOTARGS_BUF_SIZE]="";
+char gszMMC_Boot_Cmd[128]="";
+
+//static unsigned char gbSectorBufA[512],*gpbSectorBuffer=gbSectorBufA;
+
+char gcNTX_SN[512],*gpszNTX_SN;
+
+
+#define NTX_BOOTMODE_NA		(-1)
+#define NTX_BOOTMODE_ISD		0 // normal boot mode .
+#define NTX_BOOTMODE_ESD_UPG	1 // external upgrade mode .
+#define NTX_BOOTMODE_RECOVERY	2 // internal recovery mode .
+#define NTX_BOOTMODE_FASTBOOT	3 // fastboot mode .
+#define NTX_BOOTMODE_SDOWNLOAD	4 // USB serial download mode .
+
+static volatile int giNtxBootMode = NTX_BOOTMODE_NA ;
+
+
+//#define MMC_DEV_ISD		0
+//#define MMC_DEV_ESD		1
+
+#define MMC_NUM_NUKOWN	(-1)
+#define MMC_NUM_NONE		(-2)
+static int gi_mmc_num_kernel=-1;
+static int gi_mmc_isd_num=0;
+static int gi_mmc_esd_num=1;
+
+#define AUTO_DETECT_KIMGSIZE		1
+
+
+// external function ...
+extern int ntxup_wait_key_downloadmode(void);
+extern void frontLightCtrl(void);
+extern int ntxup_wait_touch_recovery(void);
+extern int ntxup_is_ext_card_inserted(void);
+extern int ntxup_wait_key_esdupg(void);
+
+#if 0
+// internal help functions ...
+static int _detect_bootmode_and_append_boot_args(char *O_cBufA,unsigned long I_ulBufSize);
+#endif
+
+int ntx_is_fastboot_abort_inusbremove(void);
+
+
+#define GET_SD_NUM(_i)	({\
+	gi_mmc_##_i##sd_num; \
+})
+
+#define GET_ISD_NUM()	GET_SD_NUM(i)
+#define GET_ESD_NUM()	GET_SD_NUM(e)
+
+
+#ifdef FASTBOOT_TIMEOUT_SETTING
+extern unsigned long fastboot_connection_timeout_us_set(unsigned long dwTimeoutSetUS);
+extern int fastboot_connection_abortchk_setup(int (*fastboot_abort_check_fn)(void));
+#else
+#warning "[WARNING] FASTBOOT_TIMEOUT_SETTING not defined !!"
+
+unsigned long fastboot_connection_timeout_us_set(unsigned long dwTimeOutUS)
+{
+	return 0;
+}
+int fastboot_connection_abort_at_usb_remove_chk_setup(int (*func)(void))
+{
+	return 0;
+}
+
+#endif
+
+
+int ntx_gpio_init(NTX_GPIO *I_pt_gpio)
+{
+	int iRet = 0 ;
+	unsigned int reg;
+	u32 dwGPIO_dir_addr=0;
+	u32 dwGPIO_data_addr=0;
+	int iIsSetVal = 0;
+	
+	if(!I_pt_gpio) {
+		printf("%s(%d) : error parameter ! null ptr !\n",__FUNCTION__,__LINE__);
+		return -1;
+	}
+	
+#ifdef _MX50_
+	imx_request_iomux(I_pt_gpio->PIN, I_pt_gpio->PIN_CFG);
+	imx_iomux_set_pad(I_pt_gpio->PIN, I_pt_gpio->PIN_PAD_CFG);
+#else
+	imx_iomux_v3_setup_pad(I_pt_gpio->tIOMUXv3_PAD_CFG);
+#endif
+	
+	switch(I_pt_gpio->GPIO_Grp) {
+	case 1:
+		dwGPIO_dir_addr = GPIO1_BASE_ADDR + 0x4;
+		dwGPIO_data_addr = GPIO1_BASE_ADDR + 0x0;
+		break;
+	case 2:
+		dwGPIO_dir_addr = GPIO2_BASE_ADDR + 0x4;
+		dwGPIO_data_addr = GPIO2_BASE_ADDR + 0x0;
+		break;
+	case 3:
+		dwGPIO_dir_addr = GPIO3_BASE_ADDR + 0x4;
+		dwGPIO_data_addr = GPIO3_BASE_ADDR + 0x0;
+		break;
+	case 4:
+		dwGPIO_dir_addr = GPIO4_BASE_ADDR + 0x4;
+		dwGPIO_data_addr = GPIO4_BASE_ADDR + 0x0;
+		break;
+	case 5:
+		dwGPIO_dir_addr = GPIO5_BASE_ADDR + 0x4;
+		dwGPIO_data_addr = GPIO5_BASE_ADDR + 0x0;
+		break;
+
+#ifndef _MX6ULL_
+	case 6:
+		dwGPIO_dir_addr = GPIO6_BASE_ADDR + 0x4;
+		dwGPIO_data_addr = GPIO6_BASE_ADDR + 0x0;
+		break;
+	case 7:
+		dwGPIO_dir_addr = GPIO7_BASE_ADDR + 0x4;
+		dwGPIO_data_addr = GPIO7_BASE_ADDR + 0x0;
+		break;
+#endif
+
+	default :
+		printf("%s():%s [ERROR] GPIO group number error (%hd)!!\n",
+			__FUNCTION__,I_pt_gpio->pszName,
+			I_pt_gpio->GPIO_Grp);
+		return -2;
+	}
+	
+	if(0==I_pt_gpio->iDirection) {
+		/* Set as output */
+		reg = readl(dwGPIO_dir_addr);
+		reg |= (u32)(1 << I_pt_gpio->GPIO_Num);
+		writel(reg, dwGPIO_dir_addr);
+
+
+		// set output value .
+		if(1==I_pt_gpio->iDefaultValue) {
+			reg = readl(dwGPIO_data_addr);
+			reg |= (u32)(1 << I_pt_gpio->GPIO_Num);
+			I_pt_gpio->iCurrentVal = 1;
+			iIsSetVal = 1;
+		}
+		else if(0==I_pt_gpio->iDefaultValue){
+			reg = readl(dwGPIO_data_addr);
+			reg &= ~((u32)(1 << I_pt_gpio->GPIO_Num));
+			I_pt_gpio->iCurrentVal = 0;
+			iIsSetVal = 1;
+		}
+		else {
+			I_pt_gpio->iCurrentVal = -1;
+		}
+
+		if(iIsSetVal) {
+			writel(reg, dwGPIO_data_addr);
+		}
+
+	}
+	else if(1==I_pt_gpio->iDirection||2==I_pt_gpio->iDirection) {
+		/* Set as input */
+		reg = readl(dwGPIO_dir_addr);
+		reg &= ~(1 << I_pt_gpio->GPIO_Num);
+		writel(reg, dwGPIO_dir_addr);
+	}
+	else {
+		// error direction .
+		printf("[WARNING] %s : error direction type (%d)!\n",\
+				__FUNCTION__,I_pt_gpio->iDirection);
+	}
+	
+	++I_pt_gpio->iIsInited;
+	
+	return iRet;
+}
+
+int ntx_gpio_set_valueEx(NTX_GPIO *I_pt_gpio,int iOutVal,int iSetDir) 
+{
+	unsigned int reg,regDir;
+	int iRet = 0;
+	int iChk;
+	u32 dwGPIO_data_addr=0;
+	u32 dwGPIO_dir_addr=0;
+	
+	if(!I_pt_gpio) {
+		printf("%s(%d) : error parameter ! null ptr !\n",__FUNCTION__,__LINE__);
+		return -1;
+	}
+
+	if(0==I_pt_gpio->iIsInited) {
+		iChk = ntx_gpio_init(I_pt_gpio);
+		if(iChk<0) {
+			return iChk;
+		}
+		udelay(100);
+	}
+
+	
+	
+	switch(I_pt_gpio->GPIO_Grp) {
+	case 1:
+		dwGPIO_data_addr = GPIO1_BASE_ADDR + 0x0;
+		dwGPIO_dir_addr = GPIO1_BASE_ADDR + 0x4;
+		break;
+	case 2:
+		dwGPIO_data_addr = GPIO2_BASE_ADDR + 0x0;
+		dwGPIO_dir_addr = GPIO2_BASE_ADDR + 0x4;
+		break;
+	case 3:
+		dwGPIO_data_addr = GPIO3_BASE_ADDR + 0x0;
+		dwGPIO_dir_addr = GPIO3_BASE_ADDR + 0x4;
+		break;
+	case 4:
+		dwGPIO_data_addr = GPIO4_BASE_ADDR + 0x0;
+		dwGPIO_dir_addr = GPIO4_BASE_ADDR + 0x4;
+		break;
+	case 5:
+		dwGPIO_data_addr = GPIO5_BASE_ADDR + 0x0;
+		dwGPIO_dir_addr = GPIO5_BASE_ADDR + 0x4;
+		break;
+#ifndef _MX6ULL_
+	case 6:
+		dwGPIO_data_addr = GPIO6_BASE_ADDR + 0x0;
+		dwGPIO_dir_addr = GPIO6_BASE_ADDR + 0x4;
+		break;
+	case 7:
+		dwGPIO_data_addr = GPIO7_BASE_ADDR + 0x0;
+		dwGPIO_dir_addr = GPIO7_BASE_ADDR + 0x4;
+		break;
+#endif
+	default :
+		printf("%s():%s [ERROR] GPIO group number error (%hd)!!\n",
+			__FUNCTION__,I_pt_gpio->pszName,
+			I_pt_gpio->GPIO_Grp);
+		return -2;
+	}
+
+	regDir = readl(dwGPIO_dir_addr);
+	if(-1==iSetDir) {
+		// do not set direction of gpio 
+		if(0!=I_pt_gpio->iDirection) {
+			printf("%s(%d):gpio%d-%d,cannot set value (the direction must be output) !\n",
+				__FUNCTION__,__LINE__,I_pt_gpio->GPIO_Grp,I_pt_gpio->GPIO_Num);
+		}
+
+		if(!(regDir&(u32)(1 << I_pt_gpio->GPIO_Num))) {
+			// direction is input 
+			printf("%s():[WARNING] \"%s\" set output value on input GPIO pin \n",
+				__FUNCTION__,I_pt_gpio->pszName);
+		}
+	}
+	else {
+		if(1==iSetDir || 2==iSetDir) {
+			// input .
+			I_pt_gpio->iDirection = iSetDir;
+			regDir &= ~(1 << I_pt_gpio->GPIO_Num);
+		}
+		else if(0==iSetDir) {
+			// output .
+			I_pt_gpio->iDirection = 0;
+			regDir |= (u32)(1 << I_pt_gpio->GPIO_Num);
+		}
+		writel(regDir, dwGPIO_dir_addr);
+	}
+
+	reg = readl(dwGPIO_data_addr);
+	if(1==iOutVal) {
+		reg |= (u32)(1 << I_pt_gpio->GPIO_Num);
+		I_pt_gpio->iCurrentVal = 1;
+	}
+	else if(0==iOutVal){
+		reg &= ~((u32)(1 << I_pt_gpio->GPIO_Num));
+		I_pt_gpio->iCurrentVal = 0;
+	}
+	writel(reg, dwGPIO_data_addr);
+	
+	
+	return iRet;
+}
+
+int ntx_gpio_set_value(NTX_GPIO *I_pt_gpio,int iOutVal) 
+{
+	return ntx_gpio_set_valueEx(I_pt_gpio,iOutVal,-1);
+}
+
+int ntx_gpio_get_value(NTX_GPIO *I_pt_gpio) 
+{
+	unsigned int regDir;
+	int iRet;
+	int iChk;
+	u32 dwGPIO_data_addr=0;
+	u32 dwGPIO_dir_addr=0;
+	
+	if(!I_pt_gpio) {
+		printf("%s(%d) : error parameter ! null ptr !\n",__FUNCTION__,__LINE__);
+		return -1;
+	}
+	
+	if(0==I_pt_gpio->iIsInited) {
+		iChk = ntx_gpio_init(I_pt_gpio);
+		if(iChk<0) {
+			return iChk;
+		}
+		udelay(100);
+	}
+
+	if(1!=I_pt_gpio->iDirection&&2!=I_pt_gpio->iDirection) {
+		printf("[WARNING] %s() :read gpio%d-%d \"%s\" with wrong direction (%d) \n",\
+				__FUNCTION__,I_pt_gpio->GPIO_Grp,I_pt_gpio->GPIO_Num,\
+				I_pt_gpio->pszName,I_pt_gpio->iDirection);
+	}
+	
+	switch(I_pt_gpio->GPIO_Grp) {
+	case 1:
+		dwGPIO_data_addr = GPIO1_BASE_ADDR + 0x0;
+		dwGPIO_dir_addr = GPIO1_BASE_ADDR + 0x4;
+		break;
+	case 2:
+		dwGPIO_data_addr = GPIO2_BASE_ADDR + 0x0;
+		dwGPIO_dir_addr = GPIO2_BASE_ADDR + 0x4;
+		break;
+	case 3:
+		dwGPIO_data_addr = GPIO3_BASE_ADDR + 0x0;
+		dwGPIO_dir_addr = GPIO3_BASE_ADDR + 0x4;
+		break;
+	case 4:
+		dwGPIO_data_addr = GPIO4_BASE_ADDR + 0x0;
+		dwGPIO_dir_addr = GPIO4_BASE_ADDR + 0x4;
+		break;
+	case 5:
+		dwGPIO_data_addr = GPIO5_BASE_ADDR + 0x0;
+		dwGPIO_dir_addr = GPIO5_BASE_ADDR + 0x4;
+		break;
+#ifndef _MX6ULL_
+	case 6:
+		dwGPIO_data_addr = GPIO6_BASE_ADDR + 0x0;
+		dwGPIO_dir_addr = GPIO6_BASE_ADDR + 0x4;
+		break;
+	case 7:
+		dwGPIO_data_addr = GPIO7_BASE_ADDR + 0x0;
+		dwGPIO_dir_addr = GPIO7_BASE_ADDR + 0x4;
+		break;
+#endif
+	default :
+		printf("%s():%s [ERROR] GPIO group number error (%hd)!!\n",
+			__FUNCTION__,I_pt_gpio->pszName,
+			I_pt_gpio->GPIO_Grp);
+		return -2;
+	}
+	regDir = readl(dwGPIO_dir_addr);
+	if((regDir&(u32)(1 << I_pt_gpio->GPIO_Num))) {
+		// direction is input 
+		printf("%s():[WARNING] \"%s\" read value on output GPIO pin\n",
+				__FUNCTION__,I_pt_gpio->pszName);
+	}
+	
+	iRet = (readl(dwGPIO_data_addr)&(1<<I_pt_gpio->GPIO_Num))?1:0;
+	
+	return iRet;
+}
+
+
+int ntx_gpio_get_current_value(NTX_GPIO *I_pt_gpio) 
+{
+	if(!I_pt_gpio) {
+		printf("%s(%d) : error parameter ! null ptr !\n",__FUNCTION__,__LINE__);
+		return -2;
+	}
+	
+	if(0==I_pt_gpio->iIsInited) {
+		printf("%s(%d) : error parameter ! \"%s\" uninit !\n",
+				__FUNCTION__,__LINE__,I_pt_gpio->pszName);
+		return -3;
+	}
+	
+	return I_pt_gpio->iCurrentVal;
+}
+
+
+int ntx_gpio_key_is_down(NTX_GPIO *I_pt_gpio)
+{
+	int iRet,iChk;
+
+	iChk = ntx_gpio_get_value(I_pt_gpio);
+
+	if(iChk<0) {
+		iRet = iChk;
+	}
+	else if(iChk == I_pt_gpio->iDefaultValue) {
+		iRet = 1;
+	}
+	else {
+		iRet = 0;
+	}
+
+	return iRet;
+}
+
+
+
+
+static unsigned long _get_ramsize(unsigned char **O_ppbRamStart)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	if(O_ppbRamStart) {
+		*O_ppbRamStart = (unsigned char*)gd->bd->bi_dram[0].start;
+	}
+	return (unsigned long)(gd->bd->bi_dram[0].size);
+}
+
+
+static int _read_mmc(int I_iSDDevNum,unsigned char *O_pbBuf,
+		unsigned long I_dwBinSectorNum,unsigned long I_dwBinReadSectors)
+{
+	int iRet = 0;
+	char cCmdA[128+1];
+#ifdef MMC_CMD_SEPERATED_SDNUM
+
+	static int giCurSDDevNum=-1;
+
+	if(giCurSDDevNum!=I_iSDDevNum) {
+		sprintf(cCmdA,"mmc dev %d",I_iSDDevNum);
+		run_command(cCmdA,0);
+		giCurSDDevNum = I_iSDDevNum;
+	}
+
+	//printf("%s(): read to %p\n",__FUNCTION__,O_pbBuf);
+
+	sprintf(cCmdA,"mmc read 0x%x 0x%x 0x%x",(unsigned)O_pbBuf,
+			(unsigned)(I_dwBinSectorNum),(unsigned)I_dwBinReadSectors);
+	printf("%s\n",cCmdA);
+	run_command(cCmdA, 0);//
+
+#else	
+
+	sprintf(cCmdA,"mmc read %d 0x%x 0x%x 0x%x",I_iSDDevNum,(unsigned)O_pbBuf,
+			(unsigned)(I_dwBinSectorNum),(unsigned)I_dwBinReadSectors);
+	run_command(cCmdA, 0);//
+
+#endif
+
+	return iRet;
+}
+
+static unsigned long _load_ntx_bin_header(int I_iSDDevNum,unsigned long I_dwBinSectorNum,
+		unsigned char *O_pbBuf,unsigned long I_dwBufSize)
+{
+	unsigned long dwBinSize = 0;
+	unsigned char *pbMagic;
+	
+	//ASSERT(I_dwBufSize>=512);
+	_read_mmc(I_iSDDevNum,O_pbBuf,(unsigned long)(I_dwBinSectorNum-1),1) ;
+	
+	pbMagic = O_pbBuf + 512 -16 ;
+	if( gszNtxBinMagicA[0]==pbMagic[0]&&gszNtxBinMagicA[1]==pbMagic[1]&&
+		gszNtxBinMagicA[2]==pbMagic[2]&&gszNtxBinMagicA[3]==pbMagic[3]) 
+	{
+		dwBinSize = *((unsigned long *)(pbMagic+8));
+	}
+	else {
+		printf("binary magic @ sector no. %lu not found !\n",I_dwBinSectorNum);
+	}
+	
+	return dwBinSize; 
+}
+
+static void _load_ntx_bin(int I_iSDDevNum,unsigned long I_dwBinSectorNum,
+		unsigned long I_dwBinSectorsToLoad,unsigned char *O_pbBuf,unsigned long I_dwBufSize)
+{
+	//char cCmdA[128];
+	
+	if(I_dwBufSize<(I_dwBinSectorsToLoad*512)) {
+		printf("%s() : buffer size not enough (buffer size %d should >= %d)!\n",
+				__FUNCTION__,(int)I_dwBufSize,(int)(I_dwBinSectorsToLoad*512));
+		return ;
+	}
+	
+	_read_mmc(I_iSDDevNum,O_pbBuf,I_dwBinSectorNum,I_dwBinSectorsToLoad);
+		 
+}
+
+const static char gszKParamName_HwCfg[]="hwcfg";
+const static char gszKParamName_logo[]="logo";
+const static char gszKParamName_logo2[]="logo";
+const static char gszKParamName_waveform[]="waveform";
+const static char gszKParamName_ntxfw[]="ntxfw";
+
+volatile unsigned char *gpbRAM_TopAddr;
+volatile unsigned long gdwRAM_TotalSize,gdwRAM_ReservedSize;
+
+typedef struct tagNtxHiddenMem {
+	// private :
+	const char *pszName; // binary data name .
+	const unsigned long dwLoadSectNo;// the sector numbers loaded from emmc .
+	// public :
+	unsigned long dwLoadSects; // total sectors loaded from emmc .
+
+	unsigned char *pbMemStart; // binary data ptr in ram for program using .
+	unsigned long dwMemSize; // binary data size in ram for program using .
+	unsigned long dwIdx; // loaded index .
+	int iIsEnabled; // active flag .
+} NtxHiddenMem;
+
+static unsigned long gdwNtxHiddenMemIdx;
+static NtxHiddenMem *gptNtxHiddenMemInfoA[4];
+
+static NtxHiddenMem gtNtxHiddenMem_HwCfg = {
+	.pszName = gszKParamName_HwCfg ,
+	.dwLoadSectNo = SD_OFFSET_SECS_HWCFG,
+};
+static NtxHiddenMem gtNtxHiddenMem_waveform = {
+	.pszName = gszKParamName_waveform ,
+	.dwLoadSectNo = SD_OFFSET_SECS_WAVEFORM,
+};
+#if 0
+static NtxHiddenMem gtNtxHiddenMem_logo = {
+	.pszName = gszKParamName_logo ,
+	.dwLoadSectNo = SD_OFFSET_SECS_LOGO,
+};
+static NtxHiddenMem gtNtxHiddenMem_logo2 = {
+	.pszName = gszKParamName_logo2 ,
+	.dwLoadSectNo = SD_OFFSET_SECS_LOGO2,
+};
+#endif
+static NtxHiddenMem gtNtxHiddenMem_ntxfw = {
+	.pszName = gszKParamName_ntxfw ,
+	.dwLoadSectNo = SD_OFFSET_SECS_NTXFW,
+};
+
+void NtxHiddenMem_append_kcmdline(char *I_pcCmdlineBufA,unsigned long I_ulCmdlineBufSize,char *O_pcCmdlineBufA)
+{
+	unsigned long dwTemp,dwTemp2;
+	char *pcTemp,*pcTemp2;
+
+	char cAppendStr[128];
+	int i;
+	int iTotalItems;
+
+	iTotalItems = sizeof(gptNtxHiddenMemInfoA)/sizeof(gptNtxHiddenMemInfoA[0]);
+
+	//printf("%s(),TotalItems=%d cmdline in=\"%s\" , out=\"%s\",outsize=%d\n",
+	//		__FUNCTION__,iTotalItems,I_pcCmdlineBufA,O_pcCmdlineBufA,(int)I_ulCmdlineBufSize);
+
+	if(O_pcCmdlineBufA) 
+	{
+		for (i=0;i<iTotalItems;i++)
+		{
+			if(!gptNtxHiddenMemInfoA[i]) {
+				break;
+			}
+
+			//printf("[%d]append kcmdline for \"%s\" \n",i,gptNtxHiddenMemInfoA[i]->pszName);
+
+			if(gptNtxHiddenMemInfoA[i]->iIsEnabled) {
+				sprintf(cAppendStr," %s_p=0x%x %s_sz=%d",
+					gptNtxHiddenMemInfoA[i]->pszName,
+					(unsigned)(gptNtxHiddenMemInfoA[i]->pbMemStart),
+					gptNtxHiddenMemInfoA[i]->pszName,
+					(int)gptNtxHiddenMemInfoA[i]->dwMemSize);
+
+				//printf("%s\n",cAppendStr);
+
+				if(strlen(cAppendStr)+strlen(O_pcCmdlineBufA)<I_ulCmdlineBufSize) 
+				{
+					strcat(O_pcCmdlineBufA,cAppendStr);
+					//printf("out=\"%s\"\n",O_pcCmdlineBufA);
+				}
+				else {
+					printf("%s(%d):cmdline buffer not enought !!\n",__FILE__,__LINE__);
+				}
+			}
+			else {
+				printf("%s mem disabled or not avalible !!\n",gptNtxHiddenMemInfoA[i]->pszName);
+				sprintf(cAppendStr," %s=bypass",
+					gptNtxHiddenMemInfoA[i]->pszName);
+
+
+				if(strlen(cAppendStr)+strlen(O_pcCmdlineBufA)<I_ulCmdlineBufSize) 
+				{
+					strcat(O_pcCmdlineBufA,cAppendStr);
+					//printf("out=\"%s\"\n",O_pcCmdlineBufA);
+				}
+				else {
+					printf("%s(%d):cmdline buffer not enought !!\n",__FILE__,__LINE__);
+				}
+			}
+		}
+	}
+	else {
+		printf("cmdline buffer not avalible !!\n");
+	}
+
+	//printf("%s(%d)\n",__FUNCTION__,__LINE__);
+
+#if !defined(_MX6Q_)
+	pcTemp = strstr(I_pcCmdlineBufA,"fbmem=");
+	if(pcTemp) {
+		pcTemp2 = strstr(pcTemp,"M");
+		*pcTemp2 = 0;
+
+		dwTemp2 = simple_strtoul(&pcTemp[6], NULL, 10);
+		*pcTemp2 = 'M';
+		gdwRAM_ReservedSize += (unsigned long)(dwTemp2<<20);
+		printf("fbmem=%dM ,reserved size=%u\n",(int)dwTemp2,(unsigned)gdwRAM_ReservedSize);
+	}
+#endif
+
+	//printf("%s(%d)\n",__FUNCTION__,__LINE__);
+	if(49==gptNtxHwCfg->m_val.bPCB) {	// only register ram console for E60QDx
+		printf("Reserved 1M for ram console\n");
+		gdwRAM_ReservedSize += 0x100000;	//reserve 1M for ram_console
+		dwTemp = (unsigned long)(gdwRAM_TotalSize-gdwRAM_ReservedSize)+0x80000000;
+		sprintf(cAppendStr," ram_console_p=0x%x",(int)dwTemp);
+		strcat(O_pcCmdlineBufA,cAppendStr);
+	}
+	
+	if(0!=gdwRAM_ReservedSize) 
+	{
+
+		dwTemp = (unsigned long)((gdwRAM_TotalSize-gdwRAM_ReservedSize)>>20);
+		dwTemp2 = dwTemp&0xffffffff;
+
+
+		printf("Kernel RAM visiable size=%dM->%dM\n",(int)dwTemp,(int)dwTemp2);
+
+		sprintf(cAppendStr," mem=%dM",(int)dwTemp2);
+		if(strlen(cAppendStr)+strlen(O_pcCmdlineBufA)<I_ulCmdlineBufSize) {
+			strcat(O_pcCmdlineBufA,cAppendStr);
+		}
+		else {
+			printf("%s(%d):cmdline buffer not enought !!\n",__FILE__,__LINE__);
+		}
+	}
+	//printf("%s() exit\n",__FUNCTION__);
+	
+}
+
+static unsigned char * NtxHiddenMem_get_topaddr(void)
+{
+	if(0==gpbRAM_TopAddr) {
+		gdwRAM_TotalSize = _get_ramsize((unsigned char **)&gpbRAM_TopAddr);
+		printf("ram p=%p,size=%u\n",gpbRAM_TopAddr,(unsigned)gdwRAM_TotalSize);
+		gpbRAM_TopAddr += gdwRAM_TotalSize;
+		gdwRAM_ReservedSize = 0;
+		gdwNtxHiddenMemIdx = 0;
+	}
+	return (unsigned char *)gpbRAM_TopAddr;
+}
+
+static unsigned char * NtxHiddenMem_load_ntxbin(NtxHiddenMem *IO_ptNtxHiddenMem,unsigned long *O_pdwBinSize)
+{
+	int iLoadDeviceNum ;
+	unsigned long dwChk;
+	unsigned long dwBinSectsToLoad;
+	unsigned long dwBinBytesToLoad;
+	unsigned char *pbRetAddr=0;
+	//char cAppendStr[128];
+
+
+	if(IO_ptNtxHiddenMem->pbMemStart && IO_ptNtxHiddenMem->dwMemSize) {
+		printf("\"%s\" loaded already !!\n",IO_ptNtxHiddenMem->pszName);
+		if(O_pdwBinSize) {
+			*O_pdwBinSize = IO_ptNtxHiddenMem->dwMemSize;
+		}
+		return IO_ptNtxHiddenMem->pbMemStart;
+	}
+
+	//cAppendStr[0] = '\0';
+
+	NtxHiddenMem_get_topaddr();
+
+	iLoadDeviceNum = GET_ISD_NUM();
+	
+	do {
+		dwChk = _load_ntx_bin_header(iLoadDeviceNum,\
+				IO_ptNtxHiddenMem->dwLoadSectNo,(unsigned char *)gpbRAM_TopAddr-512,512);
+
+		if(dwChk>0) {
+
+			if(dwChk>=(gdwRAM_TotalSize-gdwRAM_ReservedSize)) {
+				printf("ERROR : bin size (%d) bigger than RAM size(%d-%d) !!!\n",
+						(int)dwChk,(int)gdwRAM_TotalSize,(int)gdwRAM_ReservedSize);
+				break;
+			}
+
+			if(gdwNtxHiddenMemIdx!=0) {
+				if(IO_ptNtxHiddenMem->dwLoadSectNo<=gptNtxHiddenMemInfoA[gdwNtxHiddenMemIdx-1]->dwLoadSectNo) {
+					printf("[WARNING] Binaries load sequence should Lo->Hi !\n");
+				}
+				else 
+				if( (gptNtxHiddenMemInfoA[gdwNtxHiddenMemIdx-1]->dwLoadSectNo+\
+						gptNtxHiddenMemInfoA[gdwNtxHiddenMemIdx-1]->dwLoadSects) >= 
+						IO_ptNtxHiddenMem->dwLoadSectNo ) 
+				{
+					printf("skip load \"%s\" because it will overwrite \"%s\" \n",
+							IO_ptNtxHiddenMem->pszName,gptNtxHiddenMemInfoA[gdwNtxHiddenMemIdx-1]->pszName);
+					break ;
+				}
+			}
+
+			//dwBinSectsToLoad = (dwChk&0x1ff)?(dwChk>>9)+1:dwChk>>9;
+			dwBinSectsToLoad = (dwChk>>9)+1;
+			dwBinBytesToLoad = dwBinSectsToLoad<<9;
+			gpbRAM_TopAddr -= dwBinBytesToLoad;
+			_load_ntx_bin(iLoadDeviceNum,IO_ptNtxHiddenMem->dwLoadSectNo,
+					dwBinSectsToLoad,(unsigned char *)gpbRAM_TopAddr,dwBinBytesToLoad);
+
+			pbRetAddr = (unsigned char *)gpbRAM_TopAddr;
+
+			gdwRAM_ReservedSize += dwBinBytesToLoad;
+
+			
+			if(gdwNtxHiddenMemIdx<sizeof(gptNtxHiddenMemInfoA)/sizeof(gptNtxHiddenMemInfoA[0])) {
+				gptNtxHiddenMemInfoA[gdwNtxHiddenMemIdx] = IO_ptNtxHiddenMem;
+
+				gptNtxHiddenMemInfoA[gdwNtxHiddenMemIdx]->pbMemStart = (unsigned char *)gpbRAM_TopAddr;
+				gptNtxHiddenMemInfoA[gdwNtxHiddenMemIdx]->dwMemSize = dwChk;
+				gptNtxHiddenMemInfoA[gdwNtxHiddenMemIdx]->dwIdx = gdwNtxHiddenMemIdx;
+				gptNtxHiddenMemInfoA[gdwNtxHiddenMemIdx]->iIsEnabled = 1;
+
+				gptNtxHiddenMemInfoA[gdwNtxHiddenMemIdx]->dwLoadSects = dwBinSectsToLoad;
+
+#if 0
+				printf("[%d]%s added\n",gdwNtxHiddenMemIdx,gptNtxHiddenMemInfoA[gdwNtxHiddenMemIdx]->pszName);
+				printf(" mem start=%p\n",gptNtxHiddenMemInfoA[gdwNtxHiddenMemIdx]->pbMemStart);
+				printf(" mem size=%d\n",gptNtxHiddenMemInfoA[gdwNtxHiddenMemIdx]->dwMemSize);
+#endif
+
+				gdwNtxHiddenMemIdx++;
+			}
+			else {
+				printf("Hidden memory out of range (must < %d)\n",
+						sizeof(gptNtxHiddenMemInfoA)/sizeof(gptNtxHiddenMemInfoA[0]));
+			}
+
+
+			if(O_pdwBinSize) {
+				*O_pdwBinSize = dwChk;
+			}
+
+		}
+		else {
+			printf("\"%s\" not exist !!\n",IO_ptNtxHiddenMem->pszName);
+		}
+	} while(0);
+
+	return pbRetAddr;
+	
+}
+
+unsigned long ntx_get_file_size_in_ext4(int dev,int part,const char *filename)
+{
+	unsigned long dwRet=0;
+	char cCmdA[384];
+	char *s ;
+	//unsigned long filelen;
+
+
+	sprintf(cCmdA,"ext4size mmc %d:%d %s",dev,part,filename);
+	
+	printf("run cmd : \"%s\"\n",cCmdA);
+	run_command(cCmdA,0);
+
+	if ((s = getenv("filesize")) != NULL) {
+		dwRet = simple_strtoul(s, NULL, 16);
+		printf("filelen=%d\n",(int)dwRet);
+	}
+
+	return dwRet;
+}
+
+int ntx_read_file_in_ext4(int dev,int part,const char *filename,unsigned long *O_filelen,void *pvLoadAddr,unsigned long dwLoadMaxSize)
+{
+	int iRet=0;
+	char cCmdA[384];
+	char *s ;
+	//unsigned long filelen;
+
+	if((unsigned long)(-1)==dwLoadMaxSize) {
+		sprintf(cCmdA,"ext4load mmc %d:%d %p %s",dev,part,pvLoadAddr,filename);
+	}
+	else {
+		sprintf(cCmdA,"ext4load mmc %d:%d %p %s 0x%x",dev,part,pvLoadAddr,filename,(unsigned int)dwLoadMaxSize);
+	}
+	
+	printf("run cmd : \"%s\"\n",cCmdA);
+	run_command(cCmdA,0);
+
+	if(O_filelen) {
+		if ((s = getenv("filesize")) != NULL) {
+			*O_filelen = simple_strtoul(s, NULL, 16);
+			printf("filelen=%d\n",(int)*O_filelen);
+		}
+	}
+
+	return iRet;
+}
+
+
+void _load_boot_waveform(void)
+{
+#ifdef CONFIG_SPLASH_SCREEN
+	unsigned long dwChk;
+	unsigned long dwBinSectsToLoad ;
+	unsigned long dwBinBytesToLoad ;
+	int iLoadDeviceNum;
+
+
+	if(gpbWaveform) {
+		return ;
+	}
+
+#ifdef ADVANCE_WAVEFORM_FILE
+	gpbWaveform = NtxHiddenMem_load_ntxbin(&gtNtxHiddenMem_waveform,&gdwWaveformSize);
+#else
+	iLoadDeviceNum = GET_ISD_NUM();
+
+	dwChk = _load_ntx_bin_header(iLoadDeviceNum,SD_OFFSET_SECS_BOOTWAVEFORM,
+			gbSectorBufA,sizeof(gbSectorBufA));
+	if(dwChk>0) {
+		dwBinSectsToLoad = (dwChk>>9)+1;
+		dwBinBytesToLoad = dwBinSectsToLoad<<9;
+
+		gpbWaveform = CONFIG_WAVEFORM_BUF_ADDR;
+		_load_ntx_bin(iLoadDeviceNum,SD_OFFSET_SECS_BOOTWAVEFORM,
+				dwBinSectsToLoad,gpbWaveform,
+				CONFIG_FB_BASE-CONFIG_WAVEFORM_BUF_ADDR);
+
+		gdwWaveformSize = dwChk;
+	}
+#endif
+
+#endif
+}
+
+void _load_ntx_sn(void)
+{
+	unsigned char *pbSectTempBuf = NtxHiddenMem_get_topaddr()-512;
+
+	_load_ntx_bin(GET_ISD_NUM(),SD_OFFSET_SECS_SNMAC,1,pbSectTempBuf,512);
+	memcpy(gcNTX_SN,pbSectTempBuf,512);
+
+#ifdef CONFIG_MFG
+	if( !( 'S'==gcNTX_SN[0] && 'N'==gcNTX_SN[1] && '-'==gcNTX_SN[2] ) )
+	{
+		// serail no from MFGTool .
+		int i=0;
+
+		gcNTX_SN[i++]='S';
+		gcNTX_SN[i++]='N';
+		gcNTX_SN[i++]='-';
+
+#if 0
+		{
+			int j;
+			unsigned long long u64_cur_tick = get_ticks();
+			char cTemp;
+
+			printf("curtick=%016x\n",u64_cur_tick);
+			gcNTX_SN[i++]='M';
+			gcNTX_SN[i++]='F';
+			gcNTX_SN[i++]='G';
+			for(j=0;j<16;j++,i++) {
+				cTemp = (char)((u64_cur_tick>>(j*4))&0xf);
+				if( cTemp>=0x0 && cTemp<=9) {
+					gcNTX_SN[i]=cTemp+'0';
+				}
+				else {
+					gcNTX_SN[i]=cTemp+'a';
+				}
+			}
+		}
+#else
+		{
+			char *pc;
+			int j;
+
+			for(pc=NTX_SN_PRELOAD_ADDR,j=0;i<511;i++,j++)
+			{
+				if(pc[j]=='\0'||pc[j]=='\x0d'||pc[j]=='\x0a') {
+					break;
+				}
+				gcNTX_SN[i]=pc[j];
+			}
+		}
+#endif
+
+		gcNTX_SN[i]='\0';
+
+	}
+
+#endif
+	gpszNTX_SN = &gcNTX_SN[3];
+	if('S'==gpszNTX_SN[0] && 'N'==gpszNTX_SN[1] && '-'==gpszNTX_SN[2] ) {
+		printf("NTXSN:\"%s\"\n",gpszNTX_SN);
+	}
+	else {
+		printf("NTXSN not avalible !\n");
+	}
+}
+
+void _load_isd_hwconfig(void)
+{
+	//NTX_HWCONFIG *ptNtxHwCfg;
+
+#ifdef CONFIG_MFG
+	gptNtxHwCfg = NTX_HWCFG_PRELOAD_ADDR;
+	gdwNtxHwCfgSize = 110;
+#ifdef CONFIG_MFG_FASTBOOT
+	giNtxHwCfgSrc = NTX_HWCFG_SRC_RAM;
+#endif
+	return;
+#endif
+	
+	if(gptNtxHwCfg) {
+		return ;
+	}
+
+#if 0
+	ptNtxHwCfg = NTX_HWCFG_PRELOAD_ADDR;
+	if(gszNtxHwCfgMagic[0]==ptNtxHwCfg->m_hdr.cMagicNameA[0] &&\
+		gszNtxHwCfgMagic[1]==ptNtxHwCfg->m_hdr.cMagicNameA[1] &&\
+		gszNtxHwCfgMagic[2]==ptNtxHwCfg->m_hdr.cMagicNameA[2] &&\
+		gszNtxHwCfgMagic[3]==ptNtxHwCfg->m_hdr.cMagicNameA[3] &&\
+		gszNtxHwCfgMagic[4]==ptNtxHwCfg->m_hdr.cMagicNameA[4] &&\
+		gszNtxHwCfgMagic[5]==ptNtxHwCfg->m_hdr.cMagicNameA[5] &&\
+		gszNtxHwCfgMagic[6]==ptNtxHwCfg->m_hdr.cMagicNameA[6] &&\
+		gszNtxHwCfgMagic[7]==ptNtxHwCfg->m_hdr.cMagicNameA[7] &&\
+		gszNtxHwCfgMagic[8]==ptNtxHwCfg->m_hdr.cMagicNameA[8] &&\
+		gszNtxHwCfgMagic[9]==ptNtxHwCfg->m_hdr.cMagicNameA[9] )
+	{
+		gptNtxHwCfg = ptNtxHwCfg;
+		gdwNtxHwCfgSize = 110;
+		giNtxHwCfgSrc = NTX_HWCFG_SRC_RAM;
+		printf("ISD hwconfig loaded from RAM !\n");
+	}
+	else 
+#endif
+	{
+		gptNtxHwCfg = (NTX_HWCONFIG *)NtxHiddenMem_load_ntxbin(&gtNtxHiddenMem_HwCfg,&gdwNtxHwCfgSize);
+	}
+}
+
+void _load_esd_hwconfig(void)
+{
+	unsigned long dwChk;
+	int iSD_IDX;	
+	unsigned char *pbSectTempBuf = NtxHiddenMem_get_topaddr()-512;
+
+
+
+	if(gptEsdNtxHwCfg) {
+		return ;
+	}
+
+	iSD_IDX = GET_ESD_NUM();
+	dwChk = _load_ntx_bin_header(iSD_IDX,SD_OFFSET_SECS_HWCFG,pbSectTempBuf,512);
+	if(dwChk>0) {
+		_load_ntx_bin(iSD_IDX,SD_OFFSET_SECS_HWCFG,1,pbSectTempBuf,512);
+		memcpy((unsigned char *)&gtEsdNtxHwCfg,pbSectTempBuf,sizeof(gtEsdNtxHwCfg));
+		gptEsdNtxHwCfg = &gtEsdNtxHwCfg;
+		gdwEsdNtxHwCfgSize = dwChk;
+	}
+	else {
+		printf("ESD hwconfig missing !\n");
+	}
+}
+
+
+
+volatile unsigned char *gpbKernelAddr=0; // kernel address . 
+volatile unsigned long gdwKernelSize=0; // kernel size in byte .
+
+
+static int _load_ntxkernel(unsigned char **O_ppbKernelAddr,unsigned long *O_pdwKernelSize)
+{
+#ifdef CONFIG_MFG
+	return 0;
+#else
+	//char cCmdA[128];
+	volatile unsigned char *pbMagic ;
+	unsigned long dwReadSectors;
+	unsigned long dwImgSize=0 ;
+	char *s;
+	ulong offset = 0;
+
+	/* pre-set offset from CONFIG_SYS_LOAD_ADDR */
+	offset = CONFIG_SYS_LOAD_ADDR;
+
+	/* pre-set offset from $loadaddr */
+	if ((s = getenv("loadaddr")) != NULL) {
+		offset = simple_strtoul(s, NULL, 16);
+	}
+
+	if(0==offset) {
+		// load to unkown address .
+		return -1;
+	}
+
+	//pbMagic = gpbSectorBuffer+(512-16) ;
+	pbMagic = (unsigned char *)(offset+(512-16)) ;
+
+
+	if (gi_mmc_num_kernel<0) {
+		gi_mmc_num_kernel = GET_ISD_NUM() ;
+	}
+
+
+	if(9==gptNtxHwCfg->m_val.bCustomer)	{
+		dwImgSize = DEFAULT_LOAD_KERNEL_SZ;
+		_read_mmc(gi_mmc_num_kernel,(unsigned char *)offset,\
+			SD_OFFSET_SECS_KERNEL,DEFAULT_LOAD_KERNEL_SZ);
+	}
+	else {
+#ifdef AUTO_DETECT_KIMGSIZE
+
+		_read_mmc(gi_mmc_num_kernel,(unsigned char *)offset,\
+			(unsigned long)(SD_OFFSET_SECS_KERNEL-1),1);
+
+		if(gszNtxBinMagicA[0]==pbMagic[0]&&gszNtxBinMagicA[1]==pbMagic[1]\
+			&&gszNtxBinMagicA[2]==pbMagic[2]&&gszNtxBinMagicA[3]==pbMagic[3]) 
+		{
+
+			dwImgSize = *((unsigned long *)(pbMagic+8));
+			printf("kernel size = %lu@%p\n",dwImgSize,(unsigned char *)offset);
+			dwReadSectors = dwImgSize>>9|1;
+			dwReadSectors += 6;
+			//dwReadSectors = 0xfff;
+		
+			_read_mmc(gi_mmc_num_kernel,(unsigned char *)offset,\
+				(unsigned long)(SD_OFFSET_SECS_KERNEL),dwReadSectors);
+		}
+		else 
+#endif
+		{
+#ifdef AUTO_DETECT_KIMGSIZE
+
+			printf("no kernel image signature !\n");
+#endif
+			dwImgSize = DEFAULT_LOAD_KERNEL_SZ;
+			_read_mmc(gi_mmc_num_kernel,(unsigned char *)offset,\
+				SD_OFFSET_SECS_KERNEL,DEFAULT_LOAD_KERNEL_SZ);
+	
+		}
+	}
+
+	if(O_ppbKernelAddr) {
+		*O_ppbKernelAddr = (unsigned char *)offset;
+	}
+	if(O_pdwKernelSize) {
+		*O_pdwKernelSize = dwImgSize;
+	}
+
+	return 0;
+#endif
+}
+static int do_load_ntxkernel(cmd_tbl_t * cmdtp, int flag, int argc, char *const argv[])
+{
+	int iRet = 0;
+	iRet =  _load_ntxkernel((unsigned char **)&gpbKernelAddr,(unsigned long *)&gdwKernelSize)>=0?
+		CMD_RET_SUCCESS:CMD_RET_FAILURE;
+	return iRet;
+}
+U_BOOT_CMD(load_ntxkernel, 2, 0, do_load_ntxkernel,
+	"load_kernel - netronix kernel image load \n",
+	"load_kernel "
+		" - load netronix kernel from sd card .\n"
+);
+
+
+
+
+unsigned char *gpbRDaddr=0; // initrd address . 
+unsigned long gdwRDsize=0; // initrd size in byte .
+
+static int _load_ntxrd(unsigned char **O_ppbRDaddr,unsigned long *O_pdwRDsize)
+{
+#ifdef CONFIG_MFG
+	return 0;
+#else
+	int iRet = 0;
+	int i;
+	ulong offset = 0;
+	char *s;
+	unsigned char *L_pbRDAddr=0;
+	unsigned long L_dwRDSize=0;
+
+#ifdef CONFIG_RD_LOADADDR
+	/* pre-set offset from CONFIG_RD_LOADADDR */
+	offset = CONFIG_RD_LOADADDR;
+#endif
+
+	/* pre-set offset from $rd_loadaddr */
+	if ((s = getenv("rd_loadaddr")) != NULL) {
+		offset = simple_strtoul(s, NULL, 16);
+	}
+	else {
+		printf("no ramdisk env ,default rd->%p\n",(void *)offset);
+	}
+
+	if(0==offset) {
+		// load to unkown address .
+		printf("RD loadaddr not assigned !!\n");
+		iRet = -1;goto loadrd_end;
+	}
+
+	if (gi_mmc_num_kernel<0) {
+		gi_mmc_num_kernel = GET_ISD_NUM() ;
+	}
+
+#ifdef CONFIG_CMD_EXT4	// load INITRD from EMMC "rootfs/boot/uinitramfs"
+	if(0==L_pbRDAddr) {
+
+		char *filename = NULL;
+		int dev, part = 1;
+		ulong addr = 0;
+		int filelen;
+		
+		do {
+
+			filename = "/boot/uinitramfs" ;
+			addr = offset;
+
+			// locate rootfs partition no. 
+			switch(gptNtxHwCfg->m_val.bSysPartType) {
+			case 0://TYPE1
+			case 2://TYPE3
+			case 4://TYPE5
+			case 5://TYPE6
+				part = 1;
+				break;
+			case 1://TYPE2
+			case 3://TYPE4
+			case 6://TYPE7
+				part = 2;
+				break;
+			case 12://TYPE13
+				part = 3;
+				break;
+			default:
+				part = 0;
+				break;
+			}
+
+			dev = gi_mmc_num_kernel;
+
+			
+			ntx_read_file_in_ext4(dev,part,filename,
+					(unsigned long *)&filelen,(void *)addr,(unsigned long)(-1));
+
+			/* Loading ok, update default load address */
+
+			L_pbRDAddr = (unsigned char *)addr;
+			L_dwRDSize = (unsigned long)filelen;
+
+			printf ("\"%s\" %d bytes read @ %p\n",filename, filelen,(void *)addr);
+
+			if(filelen < 16 )
+			{
+				printf("## ramdisk is not exist , set rd_loadaddr -");
+				setenv("rd_loadaddr","-");		
+			}
+
+		} while(0);
+	}
+#endif
+
+
+#if 1	// load INITRD from EMMC offset .
+
+	if(0==L_pbRDAddr) 
+	{
+		//char cCmdA[128];
+		volatile unsigned char *pbMagic ;
+		unsigned long dwReadSectors;
+		unsigned long dwImgSize ;
+
+		unsigned long dwOffsetSecsINITRDA[2] = {
+			SD_OFFSET_SECS_INITRD2,SD_OFFSET_SECS_INITRD,
+		};
+
+		unsigned long dwBENV_NTXRD_offset;
+
+
+		if ((s = getenv("ntx_rd_offset")) != NULL) {
+			dwBENV_NTXRD_offset = simple_strtoul(s, NULL, 16);
+			dwOffsetSecsINITRDA[0]=dwBENV_NTXRD_offset;
+			dwOffsetSecsINITRDA[1]=0xffffffff;
+		}
+
+		//pbMagic = gpbSectorBuffer+(512-16) ;
+		pbMagic = (unsigned char *)(offset+(512-16)) ;
+		
+#ifdef AUTO_DETECT_KIMGSIZE
+
+		for (i=0;i<sizeof(dwOffsetSecsINITRDA)/sizeof(dwOffsetSecsINITRDA[0]);i++) {
+
+			if(0xffffffff==dwOffsetSecsINITRDA[i]) {
+				break;
+			}
+
+			_read_mmc(gi_mmc_num_kernel,(unsigned char *)offset,\
+					(unsigned long)(dwOffsetSecsINITRDA[i]-1),1);
+
+			if(gszNtxBinMagicA[0]==pbMagic[0]&&gszNtxBinMagicA[1]==pbMagic[1]\
+				&&gszNtxBinMagicA[2]==pbMagic[2]&&gszNtxBinMagicA[3]==pbMagic[3]) 
+			{
+
+				dwImgSize = *((unsigned long *)(pbMagic+8));
+				printf("rd size = %lu@%p\n",dwImgSize,(unsigned char *)offset);
+				dwReadSectors = dwImgSize>>9|1;
+				dwReadSectors += 6;
+				//dwReadSectors = 0xfff;
+
+				_read_mmc(gi_mmc_num_kernel,(unsigned char *)offset,\
+						(unsigned long)dwOffsetSecsINITRDA[i],dwReadSectors);
+
+				L_pbRDAddr = (unsigned char *)offset;
+				L_dwRDSize = (unsigned long)dwImgSize;
+
+				break;
+			}
+			else 
+			{
+				printf("no ramdisk image signature @sec no. %d ! \n",
+						(int)(dwOffsetSecsINITRDA[i]-1));
+			}
+
+		} // initrd offset loop .
+
+#else 
+
+		{
+
+			_read_mmc(gi_mmc_num_kernel,(unsigned char *)offset,\
+					SD_OFFSET_SECS_INITRD,DEFAULT_LOAD_RD_SZ);
+		
+		}
+
+#endif
+	}
+#endif
+
+
+loadrd_end:
+	if(O_ppbRDaddr) {
+		*O_ppbRDaddr = L_pbRDAddr;
+	}
+
+	if(O_pdwRDsize) {
+		*O_pdwRDsize = L_dwRDSize;
+	}
+
+	return iRet;
+#endif
+}
+
+static int do_load_ntxrd(cmd_tbl_t * cmdtp, int flag, int argc, char *const argv[])
+{
+	int iRet = 0;
+	iRet = _load_ntxrd(&gpbRDaddr,&gdwRDsize)>=0?
+		CMD_RET_SUCCESS:CMD_RET_FAILURE;
+	return iRet;
+}
+U_BOOT_CMD(load_ntxrd, 2, 0, do_load_ntxrd,
+	"load_ntxrd - netronix ramdisk image load \n",
+	"load_ntxrd "
+		" - load netronix ramdisk from sd card .\n"
+);
+
+
+
+unsigned char *gpbDTBaddr=0; // DTB address . 
+unsigned long gdwDTBsize=0; // DTB size in byte .
+
+static int _load_ntxdtb(unsigned char **O_ppbDTBAddr,unsigned long *O_pdwDTBSize)
+{
+#ifdef CONFIG_MFG
+	return 0;
+#else
+
+	//char cCmdA[128];
+	volatile unsigned char *pbMagic ;
+	unsigned long dwReadSectors;
+	unsigned long dwImgSize=0 ;
+	char *s;
+	ulong offset = 0;
+
+	/* pre-set offset from $loadaddr */
+	if ((s = getenv("fdt_addr")) != NULL) {
+		offset = simple_strtoul(s, NULL, 16);
+	}
+
+	if(0==offset) {
+		// load to unkown address .
+		return -1;
+	}
+
+	if (gi_mmc_num_kernel<0) {
+		gi_mmc_num_kernel = GET_ISD_NUM() ;
+	}
+	
+	//pbMagic = gpbSectorBuffer+(512-16) ;
+	pbMagic = (unsigned char *)(offset+(512-16)) ;
+#ifdef AUTO_DETECT_KIMGSIZE
+
+	_read_mmc(gi_mmc_num_kernel,(unsigned char *)offset,\
+			(unsigned long)(SD_OFFSET_SECS_DTB-1),1);
+
+	if(gszNtxBinMagicA[0]==pbMagic[0]&&gszNtxBinMagicA[1]==pbMagic[1]\
+		&&gszNtxBinMagicA[2]==pbMagic[2]&&gszNtxBinMagicA[3]==pbMagic[3]) 
+	{
+
+		dwImgSize = *((unsigned long *)(pbMagic+8));
+		printf("dtb size = %lu@%p\n",dwImgSize,(unsigned char *)offset);
+		dwReadSectors = dwImgSize>>9|1;
+		dwReadSectors += 6;
+		//dwReadSectors = 0xfff;
+		
+		_read_mmc(gi_mmc_num_kernel,(unsigned char *)offset,\
+			(unsigned long)(SD_OFFSET_SECS_DTB),dwReadSectors);
+	}
+	else 
+#endif
+	{
+#ifdef AUTO_DETECT_KIMGSIZE
+
+		printf("no dtb signature !\n");
+#endif
+		return -2;
+	}
+
+	if(O_ppbDTBAddr) {
+		*O_ppbDTBAddr = (unsigned char *)offset;
+	}
+	if(O_pdwDTBSize) {
+		*O_pdwDTBSize = dwImgSize;
+	}
+
+	return 0;
+#endif
+}
+
+static int do_load_ntxdtb(cmd_tbl_t * cmdtp, int flag, int argc, char *const argv[])
+{
+	int iRet = 0;
+	iRet = _load_ntxdtb(&gpbDTBaddr,&gdwDTBsize)>=0?
+		CMD_RET_SUCCESS:CMD_RET_FAILURE;
+	return iRet;
+}
+U_BOOT_CMD(load_ntxdtb, 2, 0, do_load_ntxdtb,
+	"load_ntxdtb - netronix dtb load \n",
+	"load_ntxdtb "
+		" - load netronix dtb from sd card .\n"
+);
+
+
+static int do_load_ntxwf(cmd_tbl_t * cmdtp, int flag, int argc, char *const argv[])
+{
+	int iRet = 0;
+	iRet = 	NtxHiddenMem_load_ntxbin(&gtNtxHiddenMem_waveform,0)?
+		CMD_RET_SUCCESS:CMD_RET_FAILURE;
+	return iRet;
+}
+U_BOOT_CMD(load_ntxwf, 2, 0, do_load_ntxwf,
+	"load_ntxwf - netronix waveform load \n",
+	"load_ntxwf "
+		" - load netronix waveform from sd card .\n"
+);
+
+
+
+static void _cp_swcfg_esd_to_isd(void)
+{
+	if(gptNtxHwCfg&&gptEsdNtxHwCfg) {
+		printf("copy soft configs from ESD to ISD ...\n");
+		// if boot from esd we should pass the ESD software configs to kernel .
+		gptNtxHwCfg->m_val.bRootFsType = gptEsdNtxHwCfg->m_val.bRootFsType;
+		gptNtxHwCfg->m_val.bSysPartType = gptEsdNtxHwCfg->m_val.bSysPartType;
+		gptNtxHwCfg->m_val.bProgressCnts = gptEsdNtxHwCfg->m_val.bProgressCnts;
+		gptNtxHwCfg->m_val.bProgressXHiByte = gptEsdNtxHwCfg->m_val.bProgressXHiByte;
+		gptNtxHwCfg->m_val.bProgressXLoByte = gptEsdNtxHwCfg->m_val.bProgressXLoByte;
+		gptNtxHwCfg->m_val.bProgressYHiByte = gptEsdNtxHwCfg->m_val.bProgressYHiByte;
+		gptNtxHwCfg->m_val.bProgressYLoByte = gptEsdNtxHwCfg->m_val.bProgressYLoByte;
+		gptNtxHwCfg->m_val.bContentType = gptEsdNtxHwCfg->m_val.bContentType;
+		gptNtxHwCfg->m_val.bUIStyle = gptEsdNtxHwCfg->m_val.bUIStyle;
+		gptNtxHwCfg->m_val.bUIConfig = gptEsdNtxHwCfg->m_val.bUIConfig;
+	}
+}
+
+/*********************************************************
+ * purpose : 
+ * 	detect ntx bootmode and modify the kernel command line .
+ * 
+ * return :
+ * 	return boot mode . 
+ * 	
+ * 
+ * args : 
+ * 	O_cBufA (output) : boot args string (kernel command line).
+ * 	I_ulBufSize (input) : boot args string buffer size .	
+ * 
+ * author :
+ * 	Gallen Lin
+ * 
+ * Date :
+ * 	2011/04/14
+ * 
+ * *******************************************************/
+static int _detect_bootmode(void)
+{
+	int iRet=NTX_BOOTMODE_NA;
+	int iPwr_Key=-1,iUPG_Key=-1,iESD_in=-1,iUSB_in=-1,iBootESD=0;
+	int iMenuKey=-1;
+
+	if(!gptNtxHwCfg) {
+		_load_isd_hwconfig();
+	}
+
+	if(gptNtxHwCfg && NTX_HWCFG_SRC_RAM == giNtxHwCfgSrc) {
+		//fastboot_connection_timeout_us_set(30*1000*1000);
+		return NTX_BOOTMODE_FASTBOOT;
+	}
+
+#if 1
+	printf("\n hwcfgp=%p,pcb=%d,customer=%d\n\n",gptNtxHwCfg,\
+			gptNtxHwCfg->m_val.bPCB,gptNtxHwCfg->m_val.bCustomer);
+#endif
+
+	switch(gptNtxHwCfg->m_val.bPCB) {
+#ifdef _MX50_
+	case 16://E60630.
+	case 18://E50600.
+		if(ntxup_is_ext_card_inserted() && 1==ntxup_wait_key_esdupg()) {
+			printf("\n**************************\n\n");
+			printf("\n**  1. Boot from ESD    **\n\n");
+			printf("\n**************************\n\n");		
+			iRet = NTX_BOOTMODE_ESD_UPG;
+			_cp_swcfg_esd_to_isd();
+		}
+		else {
+			iRet = NTX_BOOTMODE_ISD;
+		}
+		break;
+	case 27://E50610.
+		if(ntxup_wait_touch_recovery()) {
+			printf("\n**********************************\n\n");
+			printf("\n**  Boot from SD quick recovery **\n\n");
+			printf("\n**********************************\n\n");		
+			iRet = NTX_BOOTMODE_RECOVERY;
+		}
+		else
+			iRet = NTX_BOOTMODE_ISD;
+		break;
+#endif
+
+	default :
+		
+#if 0
+	{
+		// test code .
+		int iTempKey=-1;
+		while(1) {
+			iTempKey=_power_key_status();
+			if(iTempKey!=iPwr_Key) {
+				printf("PwrKey=%d\n",iTempKey);
+			}
+			iPwr_Key=iTempKey;
+		}
+	}
+#endif 
+
+		iUSB_in=ntx_detect_usb_plugin(0);
+		iESD_in=ntxup_is_ext_card_inserted();
+		iPwr_Key=_power_key_status();
+		iMenuKey = ntxup_wait_key_downloadmode();
+
+		if(1==iPwr_Key && 1==iESD_in) {
+			_load_esd_hwconfig();
+		}
+
+		iBootESD=(gptEsdNtxHwCfg&&NTXHWCFG_TST_FLAG(gptEsdNtxHwCfg->m_val.bBootOpt,0))?1:0;
+
+#ifdef USB_OTG_FASTBOOT_MODE
+		//printf("## fastboot mode OTG USB test&debug ##\n");	iUSB_in|=USB_CHARGER_OTG;//test&debug only .
+		if(iUSB_in&USB_CHARGER_OTG) {
+			printf("\n**********************************\n\n");
+			printf("\n** fastboot mode OTG USB        **\n\n");
+			printf("\n**********************************\n\n");
+			iRet = NTX_BOOTMODE_FASTBOOT;
+			//fastboot_connection_timeout_us_set(5*1000*1000);
+			fastboot_connection_timeout_us_set(0);
+			fastboot_connection_abort_at_usb_remove_chk_setup(&ntx_is_fastboot_abort_inusbremove);
+		}
+		else
+#endif
+		if(2!=gptNtxHwCfg->m_val.bUIStyle) 
+		{
+			if (12==gptNtxHwCfg->m_val.bKeyPad) {
+				int iChkRecovery = 0;
+
+				iRet = NTX_BOOTMODE_ISD;
+				// No Key in this model .
+				//iESD_in=ntxup_is_ext_card_inserted();
+				//iPwr_Key=_power_key_status();
+
+				if( 1==iPwr_Key && 1==iUSB_in ) {
+
+					printf("\n**********************************\n\n");
+					printf("\n** 0. fastboot mode (NO Key Model) **\n\n");
+					printf("\n**********************************\n\n");		
+					iRet = NTX_BOOTMODE_FASTBOOT;
+					fastboot_connection_timeout_us_set(5*1000*1000);
+					fastboot_connection_abort_at_usb_remove_chk_setup(&ntx_is_fastboot_abort_inusbremove);
+				}
+				else {
+					if( 1==iPwr_Key ) {
+						iUPG_Key=ntxup_wait_touch_recovery();
+
+						if(1==iESD_in) {
+
+							if ( 1==iBootESD || (2==iUPG_Key) ) 
+							{
+								printf("\n**********************************\n\n");
+								printf("\n* Boot from ESD (NO Key Model)  **\n\n");
+								printf("\n**********************************\n\n");		
+								iRet = NTX_BOOTMODE_ESD_UPG;
+								_cp_swcfg_esd_to_isd();
+							}
+							else {
+								iChkRecovery = 1;
+							}
+						}
+						else {
+							iChkRecovery = 1;
+						}
+					}
+
+					if( iChkRecovery && (1==iPwr_Key) && (1==iUPG_Key) ) {
+						printf("\n**********************************\n\n");
+						printf("\n** Boot recovery (NO Key Model) **\n\n");
+						printf("\n**********************************\n\n");		
+						iRet = NTX_BOOTMODE_RECOVERY;
+					}
+					else if( (1==iPwr_Key) && (3==iUPG_Key) ) {
+						printf("\n**********************************\n\n");
+						printf("\n** fastboot mode (NO Key Model) **\n\n");
+						printf("\n**********************************\n\n");		
+						iRet = NTX_BOOTMODE_FASTBOOT;
+						fastboot_connection_timeout_us_set(30*1000*1000);
+					}
+				}
+			}
+			else  {
+				iUPG_Key=ntxup_wait_key_esdupg();
+				if( (1==iMenuKey) && (1==iUSB_in) && (1==iPwr_Key)) {
+					printf("\n**********************************\n\n");
+					printf("\n** USB SDownload mode           **\n\n");
+					printf("\n**********************************\n\n");
+					iRet = NTX_BOOTMODE_SDOWNLOAD;
+				}
+				else
+				if( (1==iUPG_Key) && (1==iUSB_in)) {
+					printf("\n**********************************\n\n");
+					printf("\n** fastboot mode                **\n\n");
+					printf("\n**********************************\n\n");
+					iRet = NTX_BOOTMODE_FASTBOOT;
+					fastboot_connection_timeout_us_set(30*1000*1000);
+				}
+				else
+				if (18==gptNtxHwCfg->m_val.bKeyPad && (1==iPwr_Key) && (1==iUSB_in)) {
+					// HOMEPAD only type 
+					printf("\n**********************************\n\n");
+					printf("\n** fastboot mode (HOMEPAD) **\n\n");
+					printf("\n**********************************\n\n");		
+					iRet = NTX_BOOTMODE_FASTBOOT;
+					fastboot_connection_timeout_us_set(5*1000*1000);
+				}
+				else 
+				if((1==iESD_in) && (1==iPwr_Key) &&	((1==iBootESD) || (1==iUPG_Key)) ) 
+				{
+					printf("\n**************************\n\n");
+					printf("\n** Boot from ESD        **\n\n");
+					printf("\n**************************\n\n");		
+					iRet = NTX_BOOTMODE_ESD_UPG;
+					_cp_swcfg_esd_to_isd();
+				}
+				else 
+				if(1==iUPG_Key) {
+					printf("\n**********************************\n\n");
+					printf("\n**  Boot from SD quick recovery **\n\n");
+					printf("\n**********************************\n\n");		
+					iRet = NTX_BOOTMODE_RECOVERY;
+				}
+				else {
+					iRet = NTX_BOOTMODE_ISD;
+				}
+			}
+		}
+		else {
+			iRet = NTX_BOOTMODE_ISD;
+			//sprintf(cCmdA,"setenv bootcmd run bootcmd_mmc");
+			//run_command(cCmdA,0);
+			//_load_ntxrd(&gpbRDaddr,&gdwRDsize);
+		}
+
+#if 1
+		printf("ESDin=%d,UPGKey=%d,PWRKey=%d,USBin=0x%x,BootESD=%d,MenuKey=%d\n",
+				iESD_in,iUPG_Key,iPwr_Key,iUSB_in,iBootESD,iMenuKey);
+#endif
+
+		break;
+	}
+
+	if( (NTXHWCFG_TST_FLAG(gptNtxHwCfg->m_val.bFrontLight_Flags,0)) && (iRet == NTX_BOOTMODE_ISD) )
+	{
+		frontLightCtrl();	
+	}
+	return iRet;
+}
+
+int giNTX_VFAT_partNO;
+int giNTX_RootFS_partNO;
+int giNTX_RecoveryFS_partNO;
+int giNTX_BootImg_partNO;
+int giNTX_RecoveryImg_partNO;
+int giNTX_System_partNO;
+int giNTX_Data_partNO;
+int giNTX_Cache_partNO;
+int giNTX_Vendor_partNO;
+int giNTX_Misc_partNO;
+int giNTX_Emergency_partNO;
+
+
+int ntx_parse_syspart_type(void)
+{
+	int iRet = 0;
+
+	switch(gptNtxHwCfg->m_val.bSysPartType) {
+	case 0://TYPE1
+		giNTX_RootFS_partNO=1;
+		giNTX_VFAT_partNO=2;
+		break;
+
+	case 1://TYPE2
+		giNTX_RootFS_partNO=2;
+		giNTX_RecoveryFS_partNO=1;
+		giNTX_VFAT_partNO=3;
+		break;
+
+	case 2://TYPE3
+		giNTX_RootFS_partNO=1;
+		giNTX_RecoveryFS_partNO=2;
+		giNTX_VFAT_partNO=3;
+		break;
+
+	case 3://TYPE4
+		giNTX_RootFS_partNO=2;
+		giNTX_VFAT_partNO=1;
+		break;
+
+	case 4://TYPE5
+		giNTX_RootFS_partNO=1;
+		break;
+
+	case 5://TYPE6
+		giNTX_RootFS_partNO=1;
+		giNTX_RecoveryFS_partNO=3;
+		giNTX_VFAT_partNO=2;
+		break;
+
+	case 6://TYPE7
+		giNTX_RootFS_partNO=2;
+		giNTX_RecoveryFS_partNO=3;
+		giNTX_VFAT_partNO=1;
+		break;
+
+	case 7://TYPE8
+		giNTX_System_partNO=2;
+		giNTX_VFAT_partNO=1;
+		giNTX_RecoveryFS_partNO=4;
+		giNTX_Data_partNO=5;
+		giNTX_Cache_partNO=6;
+		break;
+
+	case 8://TYPE9
+		giNTX_BootImg_partNO=1;
+		giNTX_RecoveryImg_partNO=2;
+		giNTX_System_partNO=5;
+		giNTX_VFAT_partNO=4;
+		giNTX_Data_partNO=7;
+		giNTX_Cache_partNO=6;
+		giNTX_Vendor_partNO=8;
+		giNTX_Misc_partNO=9;
+		break;
+
+	case 9://TYPE10
+		giNTX_System_partNO=2;
+		giNTX_VFAT_partNO=1;
+		giNTX_RecoveryFS_partNO=4;
+		giNTX_Data_partNO=5;
+		giNTX_Cache_partNO=6;
+		giNTX_Emergency_partNO=7;
+		break;
+
+	case 10://TYPE11
+		giNTX_BootImg_partNO=1;
+		giNTX_RecoveryImg_partNO=2;
+		giNTX_System_partNO=5;
+		giNTX_Data_partNO=4;
+		giNTX_Cache_partNO=6;
+		giNTX_Vendor_partNO=7;
+		giNTX_Misc_partNO=8;
+		break;
+
+	case 11://TYPE12
+		giNTX_BootImg_partNO=1;
+		giNTX_RecoveryImg_partNO=2;
+		giNTX_System_partNO=5;
+		giNTX_VFAT_partNO=4;
+		giNTX_Data_partNO=7;
+		giNTX_Cache_partNO=6;
+		giNTX_Vendor_partNO=8;
+		giNTX_Misc_partNO=9;
+		giNTX_Emergency_partNO=10;
+		break;
+
+	case 12://TYPE13
+		giNTX_RootFS_partNO=3;
+		giNTX_RecoveryFS_partNO=2;
+		giNTX_VFAT_partNO=1;
+		break;
+
+	case 13://TYPE14
+		giNTX_BootImg_partNO=1;
+		giNTX_RecoveryImg_partNO=2;
+		giNTX_System_partNO=5;
+		giNTX_Data_partNO=4;
+		giNTX_Cache_partNO=6;
+		giNTX_Vendor_partNO=7;
+		giNTX_Misc_partNO=8;
+		break;
+
+	case 14://TYPE15
+		giNTX_RootFS_partNO=2;
+		giNTX_VFAT_partNO=3;
+		break;
+
+	default:
+		iRet = -1;
+		printf("%s():invalid partition type %d\n",__FUNCTION__,
+				(int)gptNtxHwCfg->m_val.bSysPartType);
+		break;
+	}
+	return iRet;
+}
+
+#if defined(CONFIG_FASTBOOT) || defined(CONFIG_FSL_FASTBOOT)
+
+//#define SECTOR_SIZE				512
+
+//unit: sector = 512B
+#define MBR_OFFSET		0
+#define MBR_SIZE			1
+#define SN_OFFSET                            1
+#define SN_SIZE                                  1
+
+#define BOOTLOADER_OFFSET	2
+
+#if defined(_MX6SL_) || defined(_MX7D_) || defined(_MX6ULL_)||defined(_MX6SLL_)
+	#define BOOTLOADER_SIZE	1022
+	#define HWCFG_OFFSET	1024
+#elif defined(_MX6Q_)
+	#define BOOTLOADER_SIZE	1522
+	#define HWCFG_OFFSET	1524
+#else
+	#error "unkown platform !!!"
+#endif
+
+#define HWCFG_SIZE		2
+#define WAVEFORM_OFFSET			14336//7MB
+#define WAVEFORM_SIZE				20480//10MB
+#define LOGO_OFFSET					34816 //17MB
+#define LOGO_SIZE						4096 //2MB
+#define KERNEL_OFFSET 			2048
+#define KERNEL_SIZE					12284
+#define DTB_OFFSET				1286
+#define DTB_SIZE					250
+#define BOOTENV_OFFSET 			1536
+#define BOOTENV_SIZE				510
+#define NTXFW_OFFSET				1030
+#define NTXFW_SIZE					255
+
+#define NTX_FASTBOOT_MAX_PPTN	16
+#define NTX_FASTBOOT_MAX_BPTN	12
+// fastboot binaries ...
+static struct fastboot_ptentry ntx_fb_binsA[NTX_FASTBOOT_MAX_BPTN]= {
+	{
+		.name="mbr",
+		.start=MBR_OFFSET,
+		.length=MBR_SIZE,
+		.flags=0,
+		.partition_id=0,
+	},
+	{
+		.name="sn",
+		.start=SN_OFFSET,
+		.length=SN_SIZE,
+		.flags=0,
+		.partition_id=0,
+	},
+	{
+		.name="bootloader",
+		.start=BOOTLOADER_OFFSET,
+		.length=BOOTLOADER_SIZE,
+		.flags=0,
+		.partition_id=0,
+	},
+	{
+		.name="hwcfg",
+		.start=HWCFG_OFFSET,
+		.length=HWCFG_SIZE,
+		.flags=0,
+		.partition_id=0,
+	},
+	{
+		.name="ntxfw",
+		.start=NTXFW_OFFSET,
+		.length=NTXFW_SIZE,
+		.flags=0,
+		.partition_id=0,
+	},
+	{
+		.name="waveform",
+		.start=WAVEFORM_OFFSET,
+		.length=WAVEFORM_SIZE,
+		.flags=0,
+		.partition_id=0,
+	},
+	{
+		.name="logo",
+		.start=LOGO_OFFSET,
+		.length=LOGO_SIZE,
+		.flags=0,
+		.partition_id=0,
+	},
+	{
+		.name="bootenv",
+		.start=BOOTENV_OFFSET,
+		.length=BOOTENV_SIZE,
+		.flags=0,
+		.partition_id=0,
+	},
+
+
+	// binary end tag .
+	{
+		.name={0},
+	}
+
+};
+
+// fastboot partitions ...
+static struct fastboot_ptentry ntx_fb_partsA[NTX_FASTBOOT_MAX_PPTN]= {
+};
+
+
+static const char gszLinuxKernel_Name[]="kernel";
+static const char gszLinuxKernelDTB_Name[]="dtb";
+static const char gszLinuxRootFS_Name[]="rootfs";
+static const char gszLinuxRecoveryFS_Name[]="recoveryfs";
+static const char gszLinuxVfatFS_Name[]="vfat";
+
+static const char gszDroidSystem_Name[]="system";
+static const char gszDroidData_Name[]="data";
+static const char gszDroidCache_Name[]="cache";
+static const char gszDroidRecovery_Name[]="recovery";
+static const char gszDroidBoot_Name[]="boot";
+static const char gszDroidVendor_Name[]="vendor";
+static const char gszDroidDevice_Name[]="device";
+static const char gszDroidMisc_Name[]="misc";
+static const char gszDroidEmergency_Name[]="emergency";
+static const char gszDroidMedia_Name[]="media";
+
+void hotfix_avoid_mmc_partition_cannot_be_recognized(void)
+{
+	// workarround to avoid mmc partition cannot be recognized on Q92
+	//if(46==gptNtxHwCfg->m_val.bPCB) 
+	if(NTXHW_BOOTDEV_SD==ntxhw_get_bootdevice_type())
+	{
+		// E60Q9X 
+		run_command("mmcinfo", 0);//
+		run_command("mmc rescan", 0);//
+	}
+}
+
+void ntx_config_fastboot_layout(void)
+{
+	int i;
+	disk_partition_t info;
+
+	int mmcc=0;
+	struct mmc *mmc;
+	block_dev_desc_t *dev_desc = NULL;
+	//unsigned sector, partno = -1;
+
+	int iPIdx;
+
+	//printf("%s()\n",__FUNCTION__);
+	hotfix_avoid_mmc_partition_cannot_be_recognized();
+
+	memset((void *)&info, 0 , sizeof(disk_partition_t));
+	/* i.MX use MBR as partition table, so this will have
+	   to find the start block and length for the
+	   partition name and register the fastboot pte we
+	   define the partition number of each partition in
+	   config file
+	 */
+	mmc = find_mmc_device(mmcc);
+	if (!mmc) {
+		printf("%s: cannot find '%d' mmc device\n",__FUNCTION__, mmcc);
+		return;
+	}
+	dev_desc = get_dev("mmc", mmcc);
+	if (NULL == dev_desc) {
+		printf("** Block device MMC %d not supported\n", mmcc);
+		return;
+	}
+
+	/* below was i.MX mmc operation code */
+	if (mmc_init(mmc)) {
+		printf("mmc%d init failed\n", mmcc);
+		return;
+	}
+
+	if(2!=gptNtxHwCfg->m_val.bUIStyle) {
+		for (i=0;i<sizeof(ntx_fb_binsA)/sizeof(ntx_fb_binsA[0]);i++) {
+			if(0==ntx_fb_binsA[i].name[0]) {
+				break;
+			}
+		}
+
+		strcpy(ntx_fb_binsA[i].name,gszLinuxKernel_Name);
+		ntx_fb_binsA[i].partition_id=0;
+		ntx_fb_binsA[i].start=KERNEL_OFFSET;
+		ntx_fb_binsA[i].length=KERNEL_SIZE;
+		ntx_fb_binsA[i].flags=0;
+		i++;
+
+		strcpy(ntx_fb_binsA[i].name,gszLinuxKernelDTB_Name);
+		ntx_fb_binsA[i].partition_id=0;
+		ntx_fb_binsA[i].start=DTB_OFFSET;
+		ntx_fb_binsA[i].length=DTB_SIZE;
+		ntx_fb_binsA[i].flags=0;
+		i++;
+
+	}
+
+
+	iPIdx=0;
+
+	if(giNTX_RootFS_partNO>0) {
+		strcpy(ntx_fb_partsA[iPIdx].name,gszLinuxRootFS_Name);
+		ntx_fb_partsA[iPIdx].partition_id=giNTX_RootFS_partNO;
+		iPIdx++;
+	}
+
+	if(giNTX_VFAT_partNO>0) {
+		if(2==gptNtxHwCfg->m_val.bUIStyle) {
+			strcpy(ntx_fb_partsA[iPIdx].name,gszDroidMedia_Name);
+		}
+		else {
+			strcpy(ntx_fb_partsA[iPIdx].name,gszLinuxVfatFS_Name);
+		}
+		ntx_fb_partsA[iPIdx].partition_id=giNTX_VFAT_partNO;
+		iPIdx++;
+	}
+	
+	if(giNTX_RecoveryFS_partNO>0) {
+		if(2==gptNtxHwCfg->m_val.bUIStyle) {
+			strcpy(ntx_fb_partsA[iPIdx].name,gszDroidRecovery_Name);
+		}
+		else {
+			strcpy(ntx_fb_partsA[iPIdx].name,gszLinuxRecoveryFS_Name);
+		}
+		ntx_fb_partsA[iPIdx].partition_id=giNTX_RecoveryFS_partNO;
+		iPIdx++;
+	}
+
+	if(giNTX_System_partNO>0) {
+		strcpy(ntx_fb_partsA[iPIdx].name,gszDroidSystem_Name);
+		ntx_fb_partsA[iPIdx].partition_id=giNTX_System_partNO;
+		iPIdx++;
+	}
+
+	if(giNTX_Data_partNO>0) {
+		strcpy(ntx_fb_partsA[iPIdx].name,gszDroidData_Name);
+		ntx_fb_partsA[iPIdx].partition_id=giNTX_Data_partNO;
+		iPIdx++;
+	}
+
+	if(giNTX_Cache_partNO>0) {
+		strcpy(ntx_fb_partsA[iPIdx].name,gszDroidCache_Name);
+		ntx_fb_partsA[iPIdx].partition_id=giNTX_Cache_partNO;
+		iPIdx++;
+	}
+	
+	if(giNTX_BootImg_partNO>0) {
+		strcpy(ntx_fb_partsA[iPIdx].name,gszDroidBoot_Name);
+		ntx_fb_partsA[iPIdx].partition_id=giNTX_BootImg_partNO;
+		iPIdx++;
+	}
+
+	if(giNTX_RecoveryImg_partNO>0) {
+		strcpy(ntx_fb_partsA[iPIdx].name,gszDroidRecovery_Name);
+		ntx_fb_partsA[iPIdx].partition_id=giNTX_RecoveryImg_partNO;
+		iPIdx++;
+	}
+
+	if(giNTX_Vendor_partNO>0) {
+		strcpy(ntx_fb_partsA[iPIdx].name,gszDroidVendor_Name);
+		ntx_fb_partsA[iPIdx].partition_id=giNTX_Vendor_partNO;
+		iPIdx++;
+	}
+
+	if(giNTX_Misc_partNO>0) {
+		strcpy(ntx_fb_partsA[iPIdx].name,gszDroidMisc_Name);
+		ntx_fb_partsA[iPIdx].partition_id=giNTX_Misc_partNO;
+		iPIdx++;
+	}
+
+	if(giNTX_Emergency_partNO>0) {
+		strcpy(ntx_fb_partsA[iPIdx].name,gszDroidEmergency_Name);
+		ntx_fb_partsA[iPIdx].partition_id=giNTX_Emergency_partNO;
+		iPIdx++;
+	}
+
+
+	for (i=0;i<sizeof(ntx_fb_binsA)/sizeof(ntx_fb_binsA[0]);i++)
+	{
+		if(0==ntx_fb_binsA[i].name[0]) {
+			printf("%s():%d binaries partition added\n",__FUNCTION__,i);
+			break;
+		}
+#if 0
+		printf("%s(%d),adding fastboot binary parts \"%s\",start=%d,len=%d\n",
+				__FUNCTION__,__LINE__,ntx_fb_binsA[i].name,
+				ntx_fb_binsA[i].start,ntx_fb_binsA[i].length);
+#endif
+
+		fastboot_flash_add_ptn(&ntx_fb_binsA[i]);
+	}
+
+	for (i=0;i<sizeof(ntx_fb_partsA)/sizeof(ntx_fb_partsA[0]);i++)
+	{
+		if(0==ntx_fb_partsA[i].name[0]) {
+			printf("%s():%d mbr partition added\n",__FUNCTION__,i);
+			break;
+		}
+#if 0
+		printf("%s(%d),adding fastboot part \"%s\",start=%d,len=%d\n",
+				__FUNCTION__,__LINE__,ntx_fb_partsA[i].name,
+				ntx_fb_partsA[i].start,ntx_fb_partsA[i].length);
+#endif
+
+		if(0==ntx_fb_partsA[i].length&&ntx_fb_partsA[i].partition_id!=0) {
+			if (get_partition_info(dev_desc,ntx_fb_partsA[i].partition_id , &info)) {
+				printf("%s: get partition:%s fail !!\n",__FUNCTION__, ntx_fb_partsA[i].name);
+				continue ;
+			}
+			ntx_fb_partsA[i].start = info.start;
+			ntx_fb_partsA[i].length = info.size;
+		}
+
+		fastboot_flash_add_ptn(&ntx_fb_partsA[i]);
+	}
+	//fastboot_flash_dump_ptn();
+
+}
+
+int ntx_is_fastboot_abort_inusbremove(void) 
+{
+#if 0
+	if(49==gptNtxHwCfg->m_val.bPCB && gptNtxHwCfg->m_val.bPCB_REV>=0x20)
+	{
+		return 1;
+	}
+	else if(2!=gptNtxHwCfg->m_val.bUIStyle && 12==gptNtxHwCfg->m_val.bKeyPad)
+	{
+		// linux platform & models without keys .
+		if(_power_key_status()) {
+			return 1;
+		}
+	}
+#endif
+	return 1;
+}
+
+#else
+
+void ntx_config_fastboot_layout(void){}
+int ntx_is_fastboot_abort_inusbremove(void) {return 0;}
+
+#endif
+
+#ifdef _MX7D_
+static NTX_GPIO gt_ntx_gpio_bat_low= {
+	MX7D_PAD_GPIO1_IO00__GPIO1_IO0,  // pin pad/mux control .
+	1, // gpio group .
+	0, // gpio number .
+	0, // NC .
+	0, // not inited .
+	"Bat_low", // name .
+	1, // 1:input ; 0:output ; 2:btn .
+};
+
+#elif defined(_MX6ULL_)
+static NTX_GPIO gt_ntx_gpio_bat_low= {
+	MX6_PAD_SNVS_TAMPER3__GPIO5_IO03|MUX_PAD_CTRL(INPUT_PAD_CTRL),  // pin pad/mux control .
+	1, // gpio group .
+	0, // gpio number .
+	0, // NC .
+	0, // not inited .
+	"Bat_low", // name .
+	1, // 1:input ; 0:output ; 2:btn .
+};
+
+
+#elif defined(_MX6SL_) || defined(_MX6SLL_)
+
+static NTX_GPIO gt_ntx_gpio_bat_low= {
+#ifdef CONFIG_TARGET_MX6SLL_KOBO_CLARA_HD
+	MX6_PAD_KEY_COL2__GPIO3_IO28,  // pin pad/mux control .
+#else
+	MX6SL_PAD_KEY_COL2__GPIO3_IO28,  // pin pad/mux control .
+#endif
+	3, // gpio group .
+	28, // gpio number .
+	0, // NC .
+	0, // not inited .
+	"Bat_low", // name .
+	1, // 1:input ; 0:output ; 2:btn .
+};
+#endif
+
+#define IS_BATT_CRITIAL_LOW()	\
+		(0==ntx_gpio_get_value(&gt_ntx_gpio_bat_low))?1:0
+
+extern int RC5T619_read_reg(unsigned char bRegAddr,unsigned char *O_pbRegVal);
+extern int RC5T619_write_buffer(unsigned char bRegAddr,unsigned char *I_pbRegWrBuf,unsigned short I_wRegWrBufBytes);
+
+int ricoh_read_adc (unsigned char adsel)
+{
+	int i, iChk;
+	unsigned char bValue;
+
+	/* ADC interrupt enable */
+	RC5T619_write_reg (0x9D, 0x08);	// INTEN_REG
+
+	/* enable interrupt request of single mode */
+	RC5T619_write_reg (0x8A, 0x01);	// EN_ADCIR3_REG
+
+	/* single request */
+	RC5T619_write_reg (0x66, (0x10|adsel));	// ADCCNT3_REG
+	for (i = 0; i < 5; i++) {
+		udelay(2000);
+		/* read completed flag of ADC */
+		iChk = RC5T619_read_reg(0x8A,&bValue);	// EN_ADCIR3_REG
+		if (iChk < 0) 
+			printf("Error in reading EN_ADCIR3_REG register\n");
+		if (bValue & 0x01) {
+			/* disable interrupt request of single mode */
+			RC5T619_write_reg (0x8A, 0x00);	// EN_ADCIR3_REG
+			break;
+		}
+	}
+	iChk = RC5T619_read_reg((adsel<<1) + 0x68,&bValue);	// VBATDATAH_REG
+	if (iChk < 0) 
+		printf("Error in reading H register\n");
+	i = bValue<<4;
+
+	iChk = RC5T619_read_reg((adsel<<1) + 0x69,&bValue);	// VBATDATAL_REG
+	if (iChk < 0) 
+		printf("Error in reading L register\n");
+	i |= bValue&0x0F;
+
+	return i;
+}
+
+#define THEM_BAT_HEAT	(606*4095/2500)		// 50 degrees
+#define THEM_BAT_COLD	(1824*4095/2500)	// 0 degrees
+
+// ADC*2*2.5/4095=V
+#define BATTERY_THRESHOLD 		2948	// 3.6V
+//#define BATTERY_USB_THRESHOLD 	3112	//3.8V
+//#define BATTERY_USB_THRESHOLD 	3071	//3.75V
+#define BATTERY_USB_THRESHOLD 	2989	// 3.65V
+void _power_off (void)
+{
+	if (1 == gptNtxHwCfg->m_val.bPMIC) {
+		unsigned char bVal;
+
+		/* Disable all interrupt */
+		RC5T619_write_reg(0x9D, 0);		// RICOH61x_INTC_INTEN
+		/* Disable RTC alarm */
+		RC5T619_read_reg(0xAE, &bVal);	// read rtc_ctrl1
+		bVal &= 0xBF;	// clear DALE
+		RC5T619_write_reg(0xAE, bVal);		// rtc_ctrl1
+		/* Not repeat power ON after power off(Power Off/N_OE) */
+		RC5T619_write_reg(0x0F, 0);		// RICOH61x_PWR_REP_CNT
+		/* Power OFF */
+		RC5T619_write_reg(0x0E, 1);		// RICOH61x_PWR_SLP_CNT
+	}
+}
+
+void isBatCritical (void)
+{
+	if (49!=gptNtxHwCfg->m_val.bPCB && 61!=gptNtxHwCfg->m_val.bPCB)	// only block in boot with BN models.
+		return;
+
+	if (1 == gptNtxHwCfg->m_val.bPMIC) {
+		int i = ricoh_read_adc (5);	// read battery temperature
+		unsigned char regVal;
+
+		RC5T619_read_reg(0x09, &regVal);	// read power on history
+		if (regVal & 0xFA)
+			printf ("RC5T619 power on history 0x%02X.\n", regVal);
+
+		printf ("RC5T619 read battery temperature %dmV (0x%03X).\n", i*2500/4095, i);
+
+		if ((THEM_BAT_HEAT > i) || (THEM_BAT_COLD < i)) {
+			printf ("RC5T619 battery temperature too high / low. Force power off.\n");
+			_power_off ();
+		}
+
+		if (IS_BATT_CRITIAL_LOW()) {
+			/* bypass battery critical if usb / adaptor detected. */
+			if (ntx_detect_usb_plugin(1)) {
+				/* USB IN */
+				unsigned short waitTime = 0;
+				unsigned char  interval = 2; //sec
+				unsigned short timeout = 480; //sec
+				printf("Battery critical !! USB_IN, charge a while\n");
+				if (49 == gptNtxHwCfg->m_val.bPCB)	//E60QDx
+					timeout = 1200;		// set 20 minutes
+				// set VWEAK to 3.3V
+				RC5T619_read_reg (0xBA, &regVal);
+				regVal &= 0xF3;
+				regVal |= 0x08;
+				RC5T619_write_reg (0xBA, regVal);
+				i = ricoh_read_adc (1);
+				while(1) {
+					if (waitTime*interval > timeout) {
+						printf("\nCharge Timeout !! (%d) secs\n", timeout);
+						break;
+					}
+					i = ricoh_read_adc (1);
+					if (!IS_BATT_CRITIAL_LOW() || (BATTERY_USB_THRESHOLD < i)) {
+						printf("\nBattery critical !! charge completed, take (%d) secs - %d\n", waitTime*interval, i);
+						printf ("RC5T619 battery %dmv. (0x%X , battery low %d)\n", i*5000/4095, i, IS_BATT_CRITIAL_LOW());
+						return;
+					}
+					if (!ntx_detect_usb_plugin(0)) {
+						printf("\nBattery critical !! USB_OUT\n");
+						break;
+					}
+					if (!(waitTime%10))
+						printf ("RC5T619 battery too low %dmv. (0x%X , battery low %d)\n", i*5000/4095, i, IS_BATT_CRITIAL_LOW());
+					printf(".");
+					waitTime++;
+					udelay(interval*1000000);
+				}
+			}
+			else
+				i = ricoh_read_adc (1);
+			printf ("RC5T619 battery too low %dmv. (0x%X) Force power off.\n", i*5000/4095, i);
+
+			_power_off ();
+		}
+		else {
+			RC5T619_charger_redetect();
+		}
+	}
+}
+
+void ntx_preboot(int iBootType,char *I_pszKernCmdLine,
+		char *O_pszKernCmdLine,unsigned long I_dwKernCmdLineSize)
+{
+	char *pcEnv_bootargs=I_pszKernCmdLine;
+#ifdef _MX50_
+	char *pcLPJ;
+#endif
+	//unsigned char bSysPartType,bRootFsType,bUIStyle,bCustomer;
+	unsigned long dwBootArgsLen;
+	char cCmdA[128];
+	static int giCallCnt = 0;
+
+#if 0
+	if (is_boot_from_usb()) {
+		printf("%s() boot from usb. Skip mmc read.\n",__func__);
+		return ;
+	}
+#endif
+
+
+	if(1==giCallCnt) {
+		printf("%s():calling %d\n",__FUNCTION__,giCallCnt);	
+		return ;
+	}
+
+	giCallCnt++;
+
+#ifdef CONFIG_MFG
+
+
+	_load_isd_hwconfig();
+
+	strcat(O_pszKernCmdLine," boot_port=0");
+
+
+
+#if (PHYS_SDRAM_SIZE==SZ_256M) || (PHYS_SDRAM_1_SIZE==(256*1024*1024))
+	strcat(O_pszKernCmdLine," mem=242M");
+#elif (PHYS_SDRAM_SIZE==SZ_512M) || (PHYS_SDRAM_1_SIZE==(512*1024*1024))
+	strcat(O_pszKernCmdLine," mem=500M");
+#else
+	#error "PHYS_SDRAM_1_SIZE || PHYS_SDRAM_SIZE value not supported ! please check !!"
+#endif
+
+
+	strcat(O_pszKernCmdLine," hwcfg_p=0x9ffffe00 hwcfg_sz=110");
+	strcat(O_pszKernCmdLine," rdinit=/linuxrc g_mass_storage.stall=0 g_mass_storage.removable=1 g_mass_storage.file=/fat g_mass_storage.ro=1 g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF g_mass_storage.iSerialNumber=");
+
+	//sprintf(cCmdA,"setenv bootcmd run bootcmd_mfg");
+	//printf("%s():run \"%s\"\n",__FUNCTION__,cCmdA);	
+	//run_command(cCmdA,0);
+
+	return;
+#endif
+
+	ASSERT(gptNtxHwCfg);
+
+	isBatCritical();
+	
+	giNtxBootMode = _detect_bootmode();
+	
+	
+
+	NtxHiddenMem_load_ntxbin(&gtNtxHiddenMem_waveform,0);
+	NtxHiddenMem_load_ntxbin(&gtNtxHiddenMem_ntxfw,0);
+
+	NtxHiddenMem_append_kcmdline(I_pszKernCmdLine,I_dwKernCmdLineSize,O_pszKernCmdLine);
+
+	gi_mmc_num_kernel = GET_ISD_NUM() ;
+	sprintf(cCmdA," boot_port=%d",_get_boot_sd_number());
+	strcat(O_pszKernCmdLine,cCmdA);
+
+BOOTMODE_ENTRY:
+
+	//printf("%s(%d):bootmode=%d\n",__FUNCTION__,__LINE__,giNtxBootMode);
+	switch(giNtxBootMode)	{
+	case NTX_BOOTMODE_ISD:
+		if(gptNtxHwCfg) {
+			if(9==gptNtxHwCfg->m_val.bCustomer) {
+				_led_R(0);
+				_led_G(1);
+				_led_B(1);
+			}
+		}
+		else {
+			printf("boot normal : no hwconfig !\n");
+		}
+		break;
+	case NTX_BOOTMODE_FASTBOOT:
+#if defined(CONFIG_FASTBOOT) || defined(CONFIG_FSL_FASTBOOT)
+		if(gptNtxHwCfg) {
+			if(9==gptNtxHwCfg->m_val.bCustomer) {
+				_led_R(1);
+				_led_G(1);
+				_led_B(1);
+			}
+		}
+		else {
+			printf("fastboot : no hwconfig !\n");
+		}
+		run_command("fastboot q0",0);
+		if(12==gptNtxHwCfg->m_val.bKeyPad) {
+			// models without keys
+#if 0
+			if(2==ntx_wait_powerkey(2,-1,0)) 
+#else
+			if(0==ntx_wait_powerkey(10,1,1)) // if user pressing and holding power key over 10 secs will return 0 or break and return non zero . 
+#endif
+			{
+				// power key clicked .
+				printf("enter recovery ...\n");
+				giNtxBootMode=NTX_BOOTMODE_RECOVERY;
+				goto BOOTMODE_ENTRY ;
+			}
+			else {
+				giNtxBootMode=NTX_BOOTMODE_ISD;
+			}
+		}
+		break;
+#endif
+
+	case NTX_BOOTMODE_SDOWNLOAD:
+		run_command("download_mode",0);
+		break;
+
+	case NTX_BOOTMODE_RECOVERY:
+		if(gptNtxHwCfg) {
+			if(9==gptNtxHwCfg->m_val.bCustomer) {
+				_led_R(1);
+				_led_G(0);
+				_led_B(0);
+			}
+		}
+		else {
+			printf("boot recovery : no hwconfig !\n");
+		}
+		sprintf(cCmdA,"setenv bootcmd run bootcmd_recovery");
+		run_command(cCmdA,0);
+		break;
+
+	case NTX_BOOTMODE_ESD_UPG:
+		gi_mmc_num_kernel = GET_ESD_NUM() ;
+
+		sprintf(cCmdA,"setenv bootcmd run bootcmd_SD");
+		run_command(cCmdA,0);
+		break;
+
+	}
+	
+
+#if 0
+	if(!gpbKernelAddr && 0==iBootType) {
+		// bootm to load ntx kernel .
+		_load_ntxkernel(&gpbKernelAddr,&gdwKernelSize);
+	}
+#endif
+
+	dwBootArgsLen=strlen(O_pszKernCmdLine);
+	if(dwBootArgsLen>=I_dwKernCmdLineSize) {
+		printf("[ERROR] kernel command buffer size not enough !\n");
+	}
+
+
+	{ 
+
+		//if(NTX_BOOTMODE_ESD_UPG==giNtxBootMode) {
+		//	_load_esd_hwconfig();
+		//}
+
+
+		
+#ifndef CONFIG_MFG
+		if(2==gptNtxHwCfg->m_val.bUIStyle)
+#endif
+		{
+			// Android UI .
+
+			if(gpbKernelAddr) {
+				strcat(O_pszKernCmdLine," androidboot.serialno=");
+				strcat(O_pszKernCmdLine,(char *)(&gcNTX_SN[3]));
+			}
+			//printf("bootargs=\"%s\"\n",O_pszKernCmdLine);
+
+#if 0
+			// only for KK android .
+			 
+			if(pcEnv_bootargs&&0==strstr(pcEnv_bootargs,"androidboot.hardware=")) {
+				char *pszPCB_name;
+
+#ifdef USE_HWCONFIG
+				pszPCB_name=NtxHwCfg_GetCfgFldStrVal(gptNtxHwCfg,HWCFG_FLDIDX_PCB);
+#else
+				if ( gptNtxHwCfg->m_val.bPCB<(sizeof(gszPCBA)/sizeof(gszPCBA[0])) ) {
+					pszPCB_name = gszPCBA[gptNtxHwCfg->m_val.bPCB];
+				}
+				else {
+					pszPCB_name = "unkown";
+				}
+#endif
+				if(pszPCB_name) {
+					strcat(O_pszKernCmdLine," androidboot.hardware=");
+					strcat(O_pszKernCmdLine,pszPCB_name);
+				}
+				else {
+					strcat(O_pszKernCmdLine," androidboot.hardware=freescale");
+				}
+			}
+#endif
+
+		}
+
+		//if(!gpbRDaddr)
+		{
+			
+
+			if(pcEnv_bootargs&&0==strstr(pcEnv_bootargs,"rootfstype=")) {
+				printf("hwcfg rootfstype : %d\n",gptNtxHwCfg->m_val.bRootFsType);
+				switch(gptNtxHwCfg->m_val.bRootFsType)
+				{
+				case 0:
+					strcat(O_pszKernCmdLine," rootfstype=ext2");
+					break;
+				default:
+				case 1:
+					strcat(O_pszKernCmdLine," rootfstype=ext3");
+					break;
+				case 2:
+					strcat(O_pszKernCmdLine," rootfstype=ext4");
+					break;
+				case 3:
+					strcat(O_pszKernCmdLine," rootfstype=vfat");
+					break;
+				}
+			}
+			
+			
+		
+			if(pcEnv_bootargs&&0==strstr(pcEnv_bootargs,"root=")) {
+				char cTempA[5] = "0";
+
+				printf("hwcfg partition type : %d\n",(int)gptNtxHwCfg->m_val.bSysPartType);
+				strcat(O_pszKernCmdLine," root=/dev/mmcblk");
+				if(NTX_BOOTMODE_ISD==giNtxBootMode) {
+					cTempA[0]='0';
+					strcat(O_pszKernCmdLine,cTempA);
+					
+					switch (gptNtxHwCfg->m_val.bSysPartType)
+					{
+					default:
+					case 0://TYPE1
+					case 2://TYPE3
+					case 4://TYPE5
+					case 5://TYPE6
+						strcat(O_pszKernCmdLine,"p1");
+						break;
+					case 1://TYPE2
+					case 3://TYPE4
+					case 6://TYPE7
+					case 14://TYPE15
+						strcat(O_pszKernCmdLine,"p2");
+						//strcat(O_pszKernCmdLine," rootdelay=3");
+						break;
+					case 12://TYPE13
+						strcat(O_pszKernCmdLine,"p3");
+						break;
+					}
+				}
+				else if(NTX_BOOTMODE_ESD_UPG==giNtxBootMode){
+					cTempA[0]='1';
+					strcat(O_pszKernCmdLine,cTempA);
+								
+					switch (gptNtxHwCfg->m_val.bSysPartType)
+					{
+					default:
+					case 0://TYPE1
+					case 2://TYPE3
+					case 4://TYPE5
+					case 5://TYPE6
+						strcat(O_pszKernCmdLine,"p1");
+						break;
+					case 1://TYPE2
+					case 3://TYPE4
+					case 6://TYPE7
+						strcat(O_pszKernCmdLine,"p2");
+						break;
+					case 12://TYPE13
+						strcat(O_pszKernCmdLine,"p3");
+						break;
+					}
+				}
+				else if(NTX_BOOTMODE_RECOVERY==giNtxBootMode) {
+					cTempA[0]='0';
+					strcat(O_pszKernCmdLine,cTempA);
+					
+					switch (gptNtxHwCfg->m_val.bSysPartType)
+					{
+					default:
+						strcat(O_pszKernCmdLine,"p1");
+						break;
+					case 12://TYPE13
+					case 2://TYPE3
+						strcat(O_pszKernCmdLine,"p2");
+						break;
+					case 1://TYPE2
+						strcat(O_pszKernCmdLine,"p1");
+						break;
+					case 5://TYPE6
+					case 6://TYPE7
+						strcat(O_pszKernCmdLine,"p3");
+						break;
+					case 7://TYPE8
+						strcat(O_pszKernCmdLine,"p4");
+						break;
+					}			
+				}
+			}
+
+
+
+		}
+		
+		
+#ifdef _MX50_
+		if(pcEnv_bootargs) {
+			if(2==gptNtxHwCfg->m_val.bCPUFreq) {
+				// 1G Hz .
+				strcat(O_pszKernCmdLine," mx50_1GHz");
+				pcLPJ = strstr(pcEnv_bootargs,"lpj=");
+				if(pcLPJ) {
+					strncpy(pcLPJ+4,"4997120",7);
+				}
+				else {
+					//strcat(O_pszKernCmdLine," lpj=4997120");
+				}
+				
+			}
+			else if(1==gptNtxHwCfg->m_val.bCPUFreq) {
+				// 800M Hz .
+				/*
+					
+				pcLPJ = strstr(pcEnv_bootargs,"lpj=");
+				if(pcLPJ) {
+					strncpy(pcLPJ+4,"3997696",7);
+				}
+				else {
+					strcat(O_pszKernCmdLine," lpj=3997696");
+				}
+				 
+				*/
+			}
+		}
+#endif
+
+#ifdef MAC_BOFFSET_IN_SNMAC_SECTOR
+		if(pcEnv_bootargs&&0==strstr(pcEnv_bootargs,"fec_mac=")) {
+			if( 'M'==(char)gcNTX_SN[MAC_BOFFSET_IN_SNMAC_SECTOR+0] && \
+					'A'==(char)gcNTX_SN[MAC_BOFFSET_IN_SNMAC_SECTOR+1] && \
+					'C'==(char)gcNTX_SN[MAC_BOFFSET_IN_SNMAC_SECTOR+2] && \
+					'='==(char)gcNTX_SN[MAC_BOFFSET_IN_SNMAC_SECTOR+3] && \
+					'\0'==(char)gcNTX_SN[MAC_BOFFSET_IN_SNMAC_SECTOR+4+17] )
+			{
+				strcat(O_pszKernCmdLine," fec_mac=");
+				strcat(O_pszKernCmdLine,&gcNTX_SN[MAC_BOFFSET_IN_SNMAC_SECTOR+4]);
+			}
+		}
+#endif
+
+		if(9==gptNtxHwCfg->m_val.bCustomer) {
+			if(gpbKernelAddr) {
+				if(pcEnv_bootargs&&0==strstr(pcEnv_bootargs,"quiet")) {
+					strcat(O_pszKernCmdLine," quiet");
+				}
+			}
+		}
+
+	} //] in hwconfig field ...
+
+	
+	//run_command("load_ntxrd", 0);// 
+}
+
+
+void ntx_prebootm(void)
+{
+	char cCmdA[500];
+	char *pcEnv_bootargs=0;
+
+	pcEnv_bootargs=getenv("bootargs");
+	if(0==pcEnv_bootargs) {
+		printf("%s() [WARNING] no bootargs !!! \n",__FUNCTION__);
+		//return ;
+	}
+
+	//printf("%s : cmdline before change=\"%s\"\n",__FUNCTION__,pcEnv_bootargs);	
+
+	ntx_preboot(0,pcEnv_bootargs,gszBootArgs,BOOTARGS_BUF_SIZE);
+
+	//printf("%s : cmdline after change=\"%s\"\n",__FUNCTION__,gszBootArgs);
+
+	if(pcEnv_bootargs) {
+		sprintf(cCmdA,"setenv bootargs ${bootargs} %s",gszBootArgs);
+		run_command(cCmdA, 0);// 
+		//printf("%s : cmd=%s\n",__FUNCTION__,cCmdA);	
+	}
+	
+}
+void ntx_prebooti(char *I_pszKernCmdLine)
+{
+	char cCmdA[500];
+	char *cmdline = getenv ("bootargs");
+
+
+	if(cmdline) {
+		printf ("bootargs %s\n",cmdline);
+		ntx_preboot(1,cmdline,gszBootArgs,BOOTARGS_BUF_SIZE);
+		sprintf(cCmdA,"setenv bootargs %s %s",cmdline,gszBootArgs);
+	}
+	else 
+	{
+		ntx_preboot(1,I_pszKernCmdLine,gszBootArgs,BOOTARGS_BUF_SIZE);
+		sprintf(cCmdA,"setenv bootargs %s %s",I_pszKernCmdLine,gszBootArgs);
+	}
+	run_command(cCmdA, 0);// 
+}
+
+
+static int do_ntx_prepare_load_kernel(cmd_tbl_t * cmdtp, int flag, int argc, char *const argv[])
+{
+	int iRet = 0;
+	//printf("%s(%d)\n",__FUNCTION__,__LINE__);
+	//init_VCOM_function(1,0);
+	return iRet;
+}
+
+U_BOOT_CMD(ntx_prepare_load_kernel, 2, 0, do_ntx_prepare_load_kernel,
+	"ntx_prepare_load_kernel - prepare to load kernel \n",
+	"ntx_prepare_load_kernel "
+		" - ntx_prepare_load_kernel.\n"
+);
+
+
+// gallen add 2011/03/02 [
+static int do_load_ntxbins(cmd_tbl_t * cmdtp, int flag, int argc, char *const argv[])
+{
+	int iRet = 0;
+	return iRet;
+}
+
+U_BOOT_CMD(load_ntxbins, 2, 0, do_load_ntxbins,
+	"load_ntxbins - netronix binaries load \n",
+	"load_ntxbins "
+		" - load netronix binaries from sd card (hwcfg,logo,waveform).\n"
+);
+//] gallen add 2011/03/02
+
+static unsigned char *boot_recovery=(unsigned char *)"boot-recovery";
+static unsigned char *wipe_data=(unsigned char *)"recovery\x0A--wipe_data\x0A--locale=en_US\x0A";
+int g_ntx_misc_offset;
+extern void setup_recovery_env(void);
+
+static int read_recovery_BCB (unsigned char *pBuf)
+{
+	char cCmdA[128+1];
+	sprintf(cCmdA,"mmc dev %d",GET_ISD_NUM());
+	run_command(cCmdA,0);
+
+	if (!g_ntx_misc_offset) {
+		sprintf(cCmdA,"mmc part");
+		run_command(cCmdA,0);
+		if (!g_ntx_misc_offset) {
+			printf ("misc partition not found!!\n");
+			return -1;
+		}
+	}
+
+#ifdef MMC_CMD_SEPERATED_SDNUM
+	sprintf(cCmdA,"mmc read 0x%x 0x%x 0x1",(unsigned)pBuf, g_ntx_misc_offset);
+#else
+	sprintf(cCmdA,"mmc read %d 0x%x 0x%x 0x1", GET_ISD_NUM(), (unsigned)pBuf, g_ntx_misc_offset);
+#endif
+	printf ("Writing recovery BCB to misc partition...\n%s\n",cCmdA);
+	run_command(cCmdA, 0);//
+	return 0;
+}
+
+int write_recovery_BCB (char *pBuf)
+{
+	char cCmdA[128+1];
+	unsigned char cBCB[512], *pBCB;
+
+	sprintf(cCmdA,"mmc dev %d",GET_ISD_NUM());
+	run_command(cCmdA,0);
+
+	if (!g_ntx_misc_offset) {
+		sprintf(cCmdA,"mmc part");
+		run_command(cCmdA,0);
+		if (!g_ntx_misc_offset) {
+			printf ("misc partition not found!!\n");
+			return 0;
+		}
+	}
+
+	if (pBuf) {
+		pBCB = (unsigned char *) pBuf;
+		printf ("Writing boot count %d to misc partition (offset %d)...\n", pBuf[64], g_ntx_misc_offset);
+	}
+	else {
+		memset (cBCB, 0, 512);
+		strcpy ((char *)cBCB, (char *)boot_recovery);
+		strcpy ((char *)&cBCB[64], (char *)wipe_data);
+		pBCB = cBCB;
+		printf ("Writing recovery BCB to misc partition (offset %d)...\n", g_ntx_misc_offset);
+	}
+
+#ifdef MMC_CMD_SEPERATED_SDNUM
+	sprintf(cCmdA,"mmc write 0x%x 0x%x 0x1",(unsigned)pBCB, g_ntx_misc_offset);
+#else	
+	sprintf(cCmdA,"mmc write %d 0x%x 0x%x 0x1", GET_ISD_NUM(), (unsigned)pBCB, g_ntx_misc_offset);
+#endif
+	run_command(cCmdA, 0);//
+
+//	if (!pBuf)
+//		setup_recovery_env();
+	return 0;
+}
+
+#define NTX_BOOT_CNT_SIG	"NTX_BOOT_COUNT"
+int ntx_check_and_increase_boot_count (void)
+{
+	unsigned char cMiscA[512];
+	if (0 == read_recovery_BCB (cMiscA)) {	// enter recovery if recovery flag found.
+		if (!strcmp ((char *)cMiscA, (char *) boot_recovery)) {
+			printf ("Recovery BCB found, skip count!\n");
+			return 1;
+		}
+		
+#ifdef NTX_ANDROID_BOOT_FAIL_COUNT
+		// this will enable boot failed conter for Android. (E60QDx customer request function.)
+		if (!strcmp (cMiscA, NTX_BOOT_CNT_SIG)) {
+			if (8 < ++cMiscA[64]) {
+				write_recovery_BCB (0);
+				return 1;
+			}
+			else 
+				write_recovery_BCB (cMiscA);
+		}
+		else {
+			memset (cMiscA, 0, 512);
+			strcpy (cMiscA, NTX_BOOT_CNT_SIG);
+			++cMiscA[64];
+			write_recovery_BCB (cMiscA);
+		}
+#endif
+	}
+	else 
+		printf ("misc partition not found!!\n");
+
+	return 0;
+}
+
+
+unsigned long long ntx_get_timeout_ustick(unsigned long dwUS)
+{
+	unsigned long long u64_timeout_tick;
+	uint64_t _Ticks;
+	extern uint64_t usec_to_tick(unsigned long usec);
+	_Ticks = usec_to_tick(dwUS);
+	u64_timeout_tick = get_ticks() + _Ticks;
+	return u64_timeout_tick;
+}
+
+int ntx_is_tick_timeout(unsigned long long u64TimeoutTick)
+{
+	unsigned long long u64_current_tick = get_ticks();
+	if(u64_current_tick>=u64TimeoutTick) {
+		return 1;
+	}
+	else {
+		return 0;
+	}
+}
+
+
+/*
+ *
+ */ 
+int ntx_wait_powerkey(int iWaitSecs,int iWaitPwrKeyStatChgTimes,int iChkEnterPwrKeyState)
+{
+	unsigned long long u64_timeout_tick = ntx_get_timeout_ustick(iWaitSecs*1000*1000);
+	unsigned long dwLoopCnt =	0;
+	int iLedOnOff=0;
+	int iPwrkeyLastState=-1,iPwrkeyCurState;
+	unsigned long dwPwrkeyStatChgCnt =	0;
+#define PWRKEY_DEBOUNCE_TOTAL		80000
+	unsigned long dwPwrkeyDebounceCnt=0;
+
+	if(iChkEnterPwrKeyState!=-1) {
+		iPwrkeyLastState=_power_key_status();
+		if(iPwrkeyLastState!=iChkEnterPwrKeyState) {
+			return -1;
+		}
+	}
+
+	printf("%s() : checking power key ...\n",__FUNCTION__);
+	do {
+
+		if(0==(dwLoopCnt&0xfff)) {
+			_led_R(iLedOnOff);
+			_led_G(iLedOnOff);
+			_led_B(iLedOnOff);
+			iLedOnOff = (iLedOnOff)?0:1;
+		}
+
+
+		if(0==dwPwrkeyDebounceCnt) {
+			iPwrkeyCurState = _power_key_status();
+			if( iPwrkeyCurState != iPwrkeyLastState ) {
+				dwPwrkeyStatChgCnt++;
+
+				if((unsigned long)iWaitPwrKeyStatChgTimes==dwPwrkeyStatChgCnt) {
+					break; 
+				}
+
+				dwPwrkeyDebounceCnt=PWRKEY_DEBOUNCE_TOTAL;
+				iPwrkeyLastState = iPwrkeyCurState;
+			}
+		}
+		else {
+			dwPwrkeyDebounceCnt--;
+		}
+
+		
+
+		if(ntx_is_tick_timeout(u64_timeout_tick)) {
+			printf("%s():times out!!!\n",__FUNCTION__);
+			break;
+		}
+
+		dwLoopCnt++;
+	}while (1);
+
+
+	if(dwPwrkeyStatChgCnt) {
+		printf("%s():power key stat changed %lu!!!\n",__FUNCTION__,dwPwrkeyStatChgCnt);
+		return (int)dwPwrkeyStatChgCnt;
+	}
+
+	return 0;
+}
+
+
+
diff --git a/board/freescale/mx6sll_kobo_clara_hd/ntx_comm.h b/board/freescale/mx6sll_kobo_clara_hd/ntx_comm.h
new file mode 100644
index 0000000000..c94cda6748
--- /dev/null
+++ b/board/freescale/mx6sll_kobo_clara_hd/ntx_comm.h
@@ -0,0 +1,80 @@
+#ifndef _ntx_comm_h//[
+#define _ntx_comm_h
+
+
+#ifdef _MX50_//[
+#include <asm/arch/mx50.h>
+#include <asm/arch/mx50_pins.h>
+#elif defined(_MX6SL_) //][ 
+#include <asm/arch/mx6.h>
+#include <asm/arch/mx6sl_pins.h>
+#include <asm/arch/iomux-v3.h>
+#endif //] _MX50_
+
+
+#ifdef __cplusplus //[
+extern C {
+#endif //] __cplusplus
+
+extern int giNTX_VFAT_partNO;
+extern int giNTX_RootFS_partNO;
+extern int giNTX_RecoveryFS_partNO;
+extern int giNTX_BootImg_partNO;
+extern int giNTX_RecoveryImg_partNO;
+extern int giNTX_System_partNO;
+extern int giNTX_Data_partNO;
+extern int giNTX_Cache_partNO;
+extern int giNTX_Vendor_partNO;
+extern int giNTX_Misc_partNO;
+extern int giNTX_Emergency_partNO;
+
+
+
+
+#ifndef _NTX_GPIO//[
+#define _NTX_GPIO
+
+typedef struct tagNTX_GPIO {
+#if defined(_MX50_) //[
+	iomux_pin_name_t PIN; // pin name .
+	iomux_pin_cfg_t PIN_CFG; // pin config .
+	u32	PIN_PAD_CFG; // pad config .
+#else //][!
+	iomux_v3_cfg_t tIOMUXv3_PAD_CFG;
+#endif //]_MX50_
+	u32 GPIO_Grp; //  gpio group .
+	u32	GPIO_Num; // gpio number .
+	int iDefaultValue; // default out value/compare value .
+	int iIsInited; // 
+	const char *pszName; // 
+	int iDirection; // 1:input ; 0:output ; 2:Btn .
+	int iCurrentVal; // 1:input ; 0:output ; 2:Btn .
+} NTX_GPIO;
+
+
+#endif //]_NTX_GPIO
+
+
+
+int ntx_gpio_init(NTX_GPIO *I_pt_gpio);
+int ntx_gpio_set_value(NTX_GPIO *I_pt_gpio,int iOutVal);
+int ntx_gpio_set_valueEx(NTX_GPIO *I_pt_gpio,int iOutVal,int iSetDir); 
+int ntx_gpio_get_value(NTX_GPIO *I_pt_gpio);
+
+int ntx_gpio_key_is_down(NTX_GPIO *I_pt_gpio);
+
+unsigned long long ntx_get_timeout_ustick(unsigned long dwUS);
+int ntx_is_tick_timeout(unsigned long long u64TimeoutTick);
+
+int ntx_wait_power_click(int iWaitSecs,int iWaitClickTimes);
+
+int ntx_read_file_in_ext4(int dev,int part,const char *filename,unsigned long *O_filelen,void *pvLoadAddr,unsigned long dwLoadMaxSize);
+
+unsigned long ntx_get_file_size_in_ext4(int dev,int part,const char *filename);
+
+#ifdef __cplusplus //[
+}
+#endif //] __cplusplus
+
+#endif//]_ntx_comm_h
+
diff --git a/board/freescale/mx6sll_kobo_clara_hd/ntx_hw.c b/board/freescale/mx6sll_kobo_clara_hd/ntx_hw.c
new file mode 100644
index 0000000000..fee1a94094
--- /dev/null
+++ b/board/freescale/mx6sll_kobo_clara_hd/ntx_hw.c
@@ -0,0 +1,2299 @@
+/*
+ * ntx_hw.c : ,board.c.
+ *
+ *
+ *
+ */ 
+
+//#define DEBUG_I2C_CHN	1
+//
+//#include <usb/imx_udc.h>
+
+#include "ntx_pads.h"
+
+#ifdef _MX7D_ //[
+
+
+static const NTX_GPIO gt_ntx_gpio_WIFI_3V3_ON= {
+	MX7D_PAD_ENET1_RX_CLK__GPIO7_IO13,  // pin pad/mux control .
+	7, // gpio group .
+	13, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"WIFI_3V3", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+
+static const NTX_GPIO gt_ntx_gpio_bootcfg_11= {
+	MX7D_PAD_LCD_DATA11__GPIO3_IO16,  // pin pad/mux control .
+	3, // gpio group .
+	16, // gpio number .
+	0, // NC .
+	0, // not inited .
+	"BT_CFG11", // name .
+	1, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_bootcfg_10= {
+	MX7D_PAD_LCD_DATA10__GPIO3_IO15,  // pin pad/mux control .
+	3, // gpio group .
+	15, // gpio number .
+	0, // NC .
+	0, // not inited .
+	"BT_CFG10", // name .
+	1, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_esdin= {
+	MX7D_PAD_SD2_CD_B__GPIO5_IO9,  // pin pad/mux control .
+	5, // gpio group .
+	9, // gpio number .
+	0, // NC .
+	0, // not inited .
+	"ESDIN", // name .
+	1, // 1:input ; 0:output ; 2:btn .
+};
+
+static const NTX_GPIO gt_ntx_gpio_ACIN= {
+	MX7D_PAD_GPIO1_IO01__GPIO1_IO1,  // pin pad/mux control .
+	1, // gpio group .
+	1, // gpio number .
+	0, // NC .
+	0, // not inited .
+	"ACIN", // name .
+	1, // 1:input ; 0:output ; 2:btn .
+};
+
+static const NTX_GPIO gt_ntx_gpio_EPDPMIC_VIN= {
+	MX7D_PAD_ENET1_CRS__GPIO7_IO14 | MUX_PAD_CTRL(EPDC_PAD_CTRL),  // pin pad/mux control  .
+	7, // gpio group .
+	14, // gpio number .
+	1, // default output value .
+	0, // not inited .
+	"EPDPMIC_VIN", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_EPDPMIC_VCOM= {
+	MX7D_PAD_ENET1_RGMII_RD0__GPIO7_IO0 | MUX_PAD_CTRL(EPDC_PAD_CTRL),  // pin pad/mux control  .
+	7, // gpio group .
+	0, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"EPDPMIC_VCOM", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_65185_WAKEUP= {
+	MX7D_PAD_EPDC_SDCE3__GPIO2_IO23,  // pin pad/mux control  .
+	2, // gpio group .
+	23, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"65185_WAKEUP", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+
+static const NTX_GPIO gt_ntx_gpio_65185_PWRUP= {
+	MX7D_PAD_EPDC_PWR_COM__GPIO2_IO30,  // pin pad/mux control  .
+	2, // gpio group .
+	30, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"65185_PWRUP", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+
+static const NTX_GPIO gt_ntx_gpio_EPDPMIC_PWRGOOD= {
+	MX7D_PAD_EPDC_PWR_STAT__GPIO2_IO31,  // pin pad/mux control .
+	2, // gpio group .
+	31, // gpio number .
+	0, // NC .
+	0, // not inited .
+	"EPDPMIC_PWRGOOD", // name .
+	1, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_LED_R= {
+	MX7D_PAD_ENET1_TX_CLK__GPIO7_IO12,  // pin pad/mux control .
+	7, // gpio group .
+	12, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"R", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+static NTX_GPIO gt_ntx_gpio_LED_G= {
+	MX7D_PAD_ENET1_RGMII_TX_CTL__GPIO7_IO10,  // pin pad/mux control .
+	7, // gpio group .
+	10, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"G", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_LED_B= {
+	MX7D_PAD_ENET1_RGMII_TXC__GPIO7_IO11,  // pin pad/mux control .
+	7, // gpio group .
+	11, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"B", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+
+static const NTX_GPIO gt_ntx_gpio_FLPWR= {
+	MX7D_PAD_ENET1_RGMII_RD1__GPIO7_IO1,  // pin pad/mux control  .
+	7, // gpio group .
+	1, // gpio number .
+	1, // default output value .
+	0, // not inited .
+	"FL_PWR", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+
+static const NTX_GPIO gt_ntx_gpio_TPRST= {
+	MX7D_PAD_ENET1_RGMII_TD0__GPIO7_IO6,  // pin pad/mux control  .
+	7, // gpio group .
+	6, // gpio number .
+	1, // default output value .
+	0, // not inited .
+	"TP_RST", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+
+#elif defined(_MX6ULL_) //][
+
+#define PMIC_RC5T619 1
+
+static const NTX_GPIO gt_ntx_gpio_TPRST= {
+	MX6_PAD_GPIO1_IO06__GPIO1_IO06,  // pin pad/mux control  .
+	1, // gpio group .
+	6, // gpio number .
+	1, // default output value .
+	0, // not inited .
+	"TP_RST", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+
+static NTX_GPIO gt_ntx_gpio_LED_G= {
+	MX6_PAD_SNVS_TAMPER5__GPIO5_IO05 | MUX_PAD_CTRL(NO_PAD_CTRL),  // pin pad/mux control .
+	5, // gpio group .
+	5, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"G", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+
+static const NTX_GPIO gt_ntx_gpio_WIFI_3V3_ON= {
+	MX6_PAD_CSI_DATA02__GPIO4_IO23 | MUX_PAD_CTRL(NO_PAD_CTRL),  // pin pad/mux control .
+	4, // gpio group .
+	23, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"WIFI_3V3", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+
+static const NTX_GPIO gt_ntx_gpio_power_key= {
+	MX6_PAD_SNVS_TAMPER4__GPIO5_IO04 | MUX_PAD_CTRL(NO_PAD_CTRL),  // pin pad/mux control .
+	5, // gpio group .
+	4, // gpio number .
+	0, // key down value .
+	0, // not inited .
+	"[POWER]", // name .
+	2, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_EPDPMIC_VIN= {
+	MX6_PAD_LCD_DATA09__GPIO3_IO14 | MUX_PAD_CTRL(EPDC_PAD_CTRL),  // pin pad/mux control  .
+	3, // gpio group .
+	14, // gpio number .
+	1, // default output value .
+	0, // not inited .
+	"EPDPMIC_VIN", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_EPDPMIC_VCOM= {
+	MX6_PAD_LCD_DATA19__GPIO3_IO24 | MUX_PAD_CTRL(EPDC_PAD_CTRL),  // pin pad/mux control  .
+	3, // gpio group .
+	24, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"EPDPMIC_VCOM", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_EPDPMIC_PWRGOOD= {
+	MX6_PAD_LCD_DATA11__GPIO3_IO16|MUX_PAD_CTRL(INPUT_PAD_CTRL),  // pin pad/mux control .
+	3, // gpio group .
+	16, // gpio number .
+	0, // NC .
+	0, // not inited .
+	"EPDPMIC_PWRGOOD", // name .
+	1, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_bootcfg2_3= {
+	MX6_PAD_LCD_DATA11__GPIO3_IO16|MUX_PAD_CTRL(INPUT_PAD_CTRL),  // pin pad/mux control .
+	3, // gpio group .
+	16, // gpio number .
+	0, // NC .
+	0, // not inited .
+	"BT_CFG2_3", // name .
+	1, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_bootcfg2_4= {
+	MX6_PAD_LCD_DATA12__GPIO3_IO17|MUX_PAD_CTRL(INPUT_PAD_CTRL),  // pin pad/mux control .
+	3, // gpio group .
+	17, // gpio number .
+	0, // NC .
+	0, // not inited .
+	"BT_CFG2_4", // name .
+	1, // 1:input ; 0:output ; 2:btn .
+};
+
+static const NTX_GPIO gt_ntx_gpio_hallsensor_key= {
+	MX6_PAD_SNVS_TAMPER2__GPIO5_IO02|MUX_PAD_CTRL(INPUT_PAD_CTRL),  // pin pad/mux control .
+	5, // gpio group .
+	2, // gpio number .
+	0, // key down value .
+	0, // not inited .
+	"[HALL]", // name .
+	2, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_home_key= {
+	0,  // pin pad/mux control .
+	0, // gpio group .
+	0, // gpio number .
+	0, // key down value .
+	0, // not inited .
+	"[HOME]", // name .
+	2, // 1:input ; 0:output ; 2:btn .
+};
+static NTX_GPIO gt_ntx_gpio_LED_R= {
+	0,  // pin pad/mux control .
+	0, // gpio group .
+	0, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"R", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+static NTX_GPIO gt_ntx_gpio_LED_B= {
+	0,  // pin pad/mux control .
+	0, // gpio group .
+	0, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"B", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+
+
+#elif defined(_MX6SLL_) //][
+#define PMIC_RC5T619 1
+static const NTX_GPIO gt_ntx_gpio_TPRST= {
+#ifdef CONFIG_TARGET_MX6SLL_KOBO_CLARA_HD
+	MX6_PAD_SD1_DATA2__GPIO5_IO13|MUX_PAD_CTRL(LED_PAD_CTRL),  // pin pad/mux control  .
+#else
+	MX6SL_PAD_SD1_DAT2__GPIO5_IO13|MUX_PAD_CTRL(LED_PAD_CTRL),  // pin pad/mux control  .
+#endif
+	5, // gpio group .
+	13, // gpio number .
+	1, // default output value .
+	0, // not inited .
+	"TP_RST", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_TPRST2= {
+#ifdef CONFIG_TARGET_MX6SLL_KOBO_CLARA_HD
+	MX6_PAD_GPIO4_IO18__GPIO4_IO18|MUX_PAD_CTRL(LED_PAD_CTRL),  // pin pad/mux control  .
+#else
+	MX6SL_PAD_FEC_RXD1__GPIO4_IO18|MUX_PAD_CTRL(LED_PAD_CTRL),  // pin pad/mux control  .
+#endif
+	4, // gpio group .
+	18, // gpio number .
+	1, // default output value .
+	0, // not inited .
+	"TP_RST", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+static NTX_GPIO gt_ntx_gpio_LED_G= {
+#ifdef CONFIG_TARGET_MX6SLL_KOBO_CLARA_HD
+	MX6_PAD_SD1_DATA6__GPIO5_IO07|MUX_PAD_CTRL(LED_PAD_CTRL),  // pin pad/mux control .
+#else
+	MX6SL_PAD_SD1_DAT6__GPIO5_IO07|MUX_PAD_CTRL(LED_PAD_CTRL),  // pin pad/mux control .
+#endif
+	5, // gpio group .
+	7, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"G", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+static NTX_GPIO gt_ntx_gpio_LED_G2= {
+#ifdef CONFIG_TARGET_MX6SLL_KOBO_CLARA_HD
+	MX6_PAD_GPIO4_IO22__GPIO4_IO22|MUX_PAD_CTRL(LED_PAD_CTRL),  // pin pad/mux control .
+#else
+	MX6SL_PAD_FEC_TX_EN__GPIO4_IO22|MUX_PAD_CTRL(LED_PAD_CTRL),  // pin pad/mux control .
+#endif
+	4, // gpio group .
+	22, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"G", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+static NTX_GPIO gt_ntx_gpio_LED_R= {
+#ifdef CONFIG_TARGET_MX6SLL_KOBO_CLARA_HD
+	MX6_PAD_SD1_DATA5__GPIO5_IO09|MUX_PAD_CTRL(LED_PAD_CTRL),  // pin pad/mux control .
+#else
+	MX6SL_PAD_SD1_DAT5__GPIO5_IO09|MUX_PAD_CTRL(LED_PAD_CTRL),  // pin pad/mux control .
+#endif
+	5, // gpio group .
+	9, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"R", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+static NTX_GPIO gt_ntx_gpio_LED_R2= {
+#ifdef CONFIG_TARGET_MX6SLL_KOBO_CLARA_HD
+	MX6_PAD_GPIO4_IO17__GPIO4_IO17|MUX_PAD_CTRL(LED_PAD_CTRL),  // pin pad/mux control .
+#else
+	MX6SL_PAD_FEC_RXD0__GPIO4_IO17|MUX_PAD_CTRL(LED_PAD_CTRL),  // pin pad/mux control .
+#endif
+	4, // gpio group .
+	17, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"R", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+
+static NTX_GPIO gt_ntx_gpio_LED_B= {
+#ifdef CONFIG_TARGET_MX6SLL_KOBO_CLARA_HD
+	MX6_PAD_SD1_DATA7__GPIO5_IO10|MUX_PAD_CTRL(LED_PAD_CTRL),  // pin pad/mux control .
+#else
+	MX6SL_PAD_SD1_DAT7__GPIO5_IO10|MUX_PAD_CTRL(LED_PAD_CTRL),  // pin pad/mux control .
+#endif
+	5, // gpio group .
+	10, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"B", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+static NTX_GPIO gt_ntx_gpio_LED_B2= {
+#ifdef CONFIG_TARGET_MX6SLL_KOBO_CLARA_HD
+	MX6_PAD_GPIO4_IO16__GPIO4_IO16|MUX_PAD_CTRL(LED_PAD_CTRL),  // pin pad/mux control .
+#else
+	MX6SL_PAD_FEC_TXD1__GPIO4_IO16|MUX_PAD_CTRL(LED_PAD_CTRL),  // pin pad/mux control .
+#endif
+	4, // gpio group .
+	16, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"B", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_WIFI_3V3_ON= {
+#ifdef CONFIG_TARGET_MX6SLL_KOBO_CLARA_HD
+	MX6_PAD_SD2_DATA6__GPIO4_IO29,  // pin pad/mux control .
+#else
+	MX6SL_PAD_SD2_DAT6__GPIO4_IO29,  // pin pad/mux control .
+#endif
+	4, // gpio group .
+	29, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"WIFI_3V3", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_power_key= {
+#ifdef CONFIG_TARGET_MX6SLL_KOBO_CLARA_HD
+	MX6_PAD_SD1_DATA1__GPIO5_IO08|MUX_PAD_CTRL(INPUT_PAD_CTRL),  // pin pad/mux control .
+#else
+	MX6SL_PAD_SD1_DAT1__GPIO5_IO08|MUX_PAD_CTRL(INPUT_PAD_CTRL),  // pin pad/mux control .
+#endif
+	5, // gpio group .
+	8, // gpio number .
+	0, // key down value .
+	0, // not inited .
+	"[POWER]", // name .
+	2, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_power_key_2= {
+#ifdef CONFIG_TARGET_MX6SLL_KOBO_CLARA_HD
+	MX6_PAD_GPIO4_IO25__GPIO4_IO25|MUX_PAD_CTRL(INPUT_PAD_CTRL),  // pin pad/mux control .
+#else
+	MX6SL_PAD_FEC_CRS_DV__GPIO4_IO25|MUX_PAD_CTRL(INPUT_PAD_CTRL),  // pin pad/mux control .
+#endif
+	4, // gpio group .
+	25, // gpio number .
+	0, // key down value .
+	0, // not inited .
+	"[POWER]", // name .
+	2, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_home_key= {
+#ifdef CONFIG_TARGET_MX6SLL_KOBO_CLARA_HD
+	MX6_PAD_KEY_COL0__GPIO3_IO24|MUX_PAD_CTRL(INPUT_PAD_CTRL),  // pin pad/mux control .
+#else
+	MX6SL_PAD_KEY_COL0__GPIO3_IO24|MUX_PAD_CTRL(INPUT_PAD_CTRL),  // pin pad/mux control .
+#endif
+	3, // gpio group .
+	24, // gpio number .
+	0, // key down value .
+	0, // not inited .
+	"[HOME]", // name .
+	2, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_EPDPMIC_VIN= {
+#ifdef CONFIG_TARGET_MX6SLL_KOBO_CLARA_HD
+	MX6_PAD_EPDC_PWR_WAKE__GPIO2_IO14 | MUX_PAD_CTRL(EPDC_PAD_CTRL),  // pin pad/mux control  .
+#else
+	MX6_PAD_EPDC_PWRWAKEUP__GPIO_2_14 | MUX_PAD_CTRL(EPDC_PAD_CTRL),  // pin pad/mux control  .
+#endif
+	2, // gpio group .
+	14, // gpio number .
+	1, // default output value .
+	0, // not inited .
+	"EPDPMIC_VIN", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_EPDPMIC_VCOM= {
+#ifdef CONFIG_TARGET_MX6SLL_KOBO_CLARA_HD
+	MX6_PAD_EPDC_VCOM0__GPIO2_IO03 | MUX_PAD_CTRL(EPDC_PAD_CTRL),  // pin pad/mux control  .
+#else
+	MX6SL_PAD_EPDC_VCOM0__GPIO2_IO03 | MUX_PAD_CTRL(EPDC_PAD_CTRL),  // pin pad/mux control  .
+#endif
+	2, // gpio group .
+	3, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"EPDPMIC_VCOM", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_EPDPMIC_PWRGOOD= {
+#ifdef CONFIG_TARGET_MX6SLL_KOBO_CLARA_HD
+	MX6_PAD_EPDC_PWR_STAT__GPIO2_IO13|MUX_PAD_CTRL(INPUT_PAD_CTRL),  // pin pad/mux control .
+#else
+	MX6_PAD_EPDC_PWRSTAT__GPIO_2_13 | MUX_PAD_CTRL(INPUT_PAD_CTRL),  // pin pad/mux control .
+#endif
+	2, // gpio group .
+	13, // gpio number .
+	0, // NC .
+	0, // not inited .
+	"EPDPMIC_PWRGOOD", // name .
+	1, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_bootcfg_23= {
+#ifdef CONFIG_TARGET_MX6SLL_KOBO_CLARA_HD
+	MX6_PAD_LCD_DATA11__GPIO2_IO31|MUX_PAD_CTRL(INPUT_PAD_CTRL),  // pin pad/mux control .
+#else
+	MX6SL_PAD_LCD_DAT11__GPIO2_IO31|MUX_PAD_CTRL(INPUT_PAD_CTRL),  // pin pad/mux control .
+#endif
+	2, // gpio group .
+	31, // gpio number .
+	0, // NC .
+	0, // not inited .
+	"BT_CFG23", // name .
+	1, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_bootcfg_24= {
+#ifdef CONFIG_TARGET_MX6SLL_KOBO_CLARA_HD
+	MX6_PAD_LCD_DATA12__GPIO3_IO00|MUX_PAD_CTRL(INPUT_PAD_CTRL),  // pin pad/mux control .
+#else
+	MX6SL_PAD_LCD_DAT12__GPIO3_IO00|MUX_PAD_CTRL(INPUT_PAD_CTRL),  // pin pad/mux control .
+#endif
+	3, // gpio group .
+	0, // gpio number .
+	0, // NC .
+	0, // not inited .
+	"BT_CFG24", // name .
+	1, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_hallsensor_key= {
+#ifdef CONFIG_TARGET_MX6SLL_KOBO_CLARA_HD
+	MX6_PAD_SD1_DATA4__GPIO5_IO12|MUX_PAD_CTRL(INPUT_PAD_CTRL),  // pin pad/mux control .
+#else
+	MX6SL_PAD_SD1_DAT4__GPIO5_IO12|MUX_PAD_CTRL(INPUT_PAD_CTRL),  // pin pad/mux control .
+#endif
+	5, // gpio group .
+	12, // gpio number .
+	0, // key down value .
+	0, // not inited .
+	"[HALL]", // name .
+	2, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_hallsensor_key2= {
+#ifdef CONFIG_TARGET_MX6SLL_KOBO_CLARA_HD
+	MX6_PAD_GPIO4_IO23__GPIO4_IO23|MUX_PAD_CTRL(INPUT_PAD_CTRL),  // pin pad/mux control .
+#else
+	MX6SL_PAD_FEC_MDC__GPIO4_IO23|MUX_PAD_CTRL(INPUT_PAD_CTRL),  // pin pad/mux control .
+#endif
+	4, // gpio group .
+	23, // gpio number .
+	0, // key down value .
+	0, // not inited .
+	"[HALL]", // name .
+	2, // 1:input ; 0:output ; 2:btn .
+};
+
+#elif defined(_MX6SL_) //][
+
+#define PMIC_RC5T619 1
+static const NTX_GPIO gt_ntx_gpio_home_key_gp3_24= {
+	MX6SL_PAD_KEY_COL0__GPIO_3_24_KEYPAD,  // pin pad/mux control .
+	3, // gpio group .
+	24, // gpio number .
+	0, // key down value .
+	0, // not inited .
+	"[HOME]", // name .
+	2, // 1:input ; 0:output ; 2:btn .
+};
+
+static const NTX_GPIO gt_ntx_gpio_home_key_gp3_27= {
+	MX6SL_PAD_KEY_ROW1__GPIO_3_27_KEYPAD,  // pin pad/mux control  .
+	3, // gpio group .
+	27, // gpio number .
+	0, // key down value .
+	0, // not inited .
+	"[HOME]", // name .
+	2, // 1:input ; 0:output ; 2:btn .
+};
+
+
+static const NTX_GPIO gt_ntx_gpio_home_key= {
+	MX6SL_PAD_KEY_ROW0__GPIO_3_25,  // pin pad/mux control .
+	3, // gpio group .
+	25, // gpio number .
+	0, // key down value .
+	0, // not inited .
+	"[HOME]", // name .
+	2, // 1:input ; 0:output ; 2:btn .
+};
+
+static const NTX_GPIO gt_ntx_gpio_fl_key= {
+	MX6SL_PAD_KEY_ROW0__GPIO_3_25,  // pin pad/mux control  .
+	3, // gpio group .
+	25, // gpio number .
+	0, // key down value .
+	0, // not inited .
+	"[FL]", // name .
+	2, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_return_key= {
+	MX6SL_PAD_KEY_ROW1__GPIO_3_27,  // pin pad/mux control  .
+	3, // gpio group .
+	27, // gpio number .
+	0, // key down value .
+	0, // not inited .
+	"[RETURN]", // name .
+	2, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_menu_key= {
+	MX6SL_PAD_KEY_ROW2__GPIO_3_29,  // pin pad/mux control  .
+	3, // gpio group .
+	29, // gpio number .
+	0, // key down value .
+	0, // not inited .
+	"[MENU]", // name .
+	2, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_menu_key_gp3_25= {
+	MX6SL_PAD_KEY_ROW0__GPIO_3_25,  // pin pad/mux control  .
+	3, // gpio group .
+	25, // gpio number .
+	0, // key down value .
+	0, // not inited .
+	"[MENU]", // name .
+	2, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_left_key= {
+	MX6SL_PAD_KEY_ROW2__GPIO_3_29,  // pin pad/mux control  .
+	3, // gpio group .
+	29, // gpio number .
+	0, // key down value .
+	0, // not inited .
+	"[LEFT]", // name .
+	2, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_right_key= {
+	MX6SL_PAD_KEY_ROW3__GPIO_3_31_KEYPAD,  // pin pad/mux control .
+	3, // gpio group .
+	31, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"[RIGHT]", // name .
+	2, // 1:input ; 0:output ; 2:btn .
+};
+
+static const NTX_GPIO gt_ntx_gpio_fl_key_gp3_26= {
+	MX6SL_PAD_KEY_COL1__GPIO_3_26,  // pin pad/mux control  .
+	3, // gpio group .
+	26, // gpio number .
+	0, // key down value .
+	0, // not inited .
+	"[FL]", // name .
+	2, // 1:input ; 0:output ; 2:btn .
+};
+
+static const NTX_GPIO gt_ntx_gpio_hallsensor_key_gp5_12= {
+	MX6SL_PAD_SD1_DAT4__GPIO_5_12,  // pin pad/mux control .
+	5, // gpio group .
+	12, // gpio number .
+	0, // key down value .
+	0, // not inited .
+	"[HALL]", // name .
+	2, // 1:input ; 0:output ; 2:btn .
+};
+
+static const NTX_GPIO gt_ntx_gpio_hallsensor_key= {
+	MX6SL_PAD_FEC_MDC__GPIO_4_23,  // pin pad/mux control .
+	4, // gpio group .
+	23, // gpio number .
+	0, // key down value .
+	0, // not inited .
+	"[HALL]", // name .
+	2, // 1:input ; 0:output ; 2:btn .
+};
+
+static const NTX_GPIO gt_ntx_gpio_power_key_gp5_8= {
+	MX6SL_PAD_SD1_DAT1__GPIO_5_8,  // pin pad/mux control .
+	5, // gpio group .
+	8, // gpio number .
+	0, // key down value .
+	0, // not inited .
+	"[POWER]", // name .
+	2, // 1:input ; 0:output ; 2:btn .
+};
+
+
+static const NTX_GPIO gt_ntx_gpio_power_key= {
+	MX6SL_PAD_FEC_CRS_DV__GPIO_4_25,  // pin pad/mux control .
+	4, // gpio group .
+	25, // gpio number .
+	0, // key down value .
+	0, // not inited .
+	"[POWER]", // name .
+	2, // 1:input ; 0:output ; 2:btn .
+};
+
+static const NTX_GPIO gt_ntx_gpio_ACIN= {
+	MX6SL_PAD_SD1_CMD__GPIO_5_14,  // pin pad/mux control .
+	5, // gpio group .
+	14, // gpio number .
+	0, // NC .
+	0, // not inited .
+	"ACIN", // name .
+	1, // 1:input ; 0:output ; 2:btn .
+};
+static NTX_GPIO *gpt_ntx_gpio_ACIN=&gt_ntx_gpio_ACIN;
+
+static const NTX_GPIO gt_ntx_gpio_USBID= {
+	MX6SL_PAD_SD1_DAT5__GPIO_5_9_PULLHIGH,  // pin pad/mux control .
+	5, // gpio group .
+	9, // gpio number .
+	0, // NC .
+	0, // not inited .
+	"USBID", // name .
+	1, // 1:input ; 0:output ; 2:btn .
+};
+
+static const NTX_GPIO gt_ntx_gpio_esdin= {
+	MX6SL_PAD_SD2_DAT4__GPIO_5_2,  // pin pad/mux control .
+	5, // gpio group .
+	2, // gpio number .
+	0, // NC .
+	0, // not inited .
+	"ESDIN", // name .
+	1, // 1:input ; 0:output ; 2:btn .
+};
+
+static const NTX_GPIO gt_ntx_gpio_bootcfg_23= {
+	MX6SL_PAD_LCD_DAT11__GPIO_2_31,  // pin pad/mux control .
+	2, // gpio group .
+	31, // gpio number .
+	0, // NC .
+	0, // not inited .
+	"BT_CFG23", // name .
+	1, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_bootcfg_24= {
+	MX6SL_PAD_LCD_DAT12__GPIO_3_0,  // pin pad/mux control .
+	3, // gpio group .
+	0, // gpio number .
+	0, // NC .
+	0, // not inited .
+	"BT_CFG24", // name .
+	1, // 1:input ; 0:output ; 2:btn .
+};
+
+static const NTX_GPIO gt_ntx_gpio_bootcfg_16= {
+	MX6SL_PAD_LCD_DAT6__GPIO_2_26,  // pin pad/mux control .
+	2, // gpio group .
+	26, // gpio number .
+	0, // NC .
+	0, // not inited .
+	"BT_CFG16", // name .
+	1, // 1:input ; 0:output ; 2:btn .
+};
+
+static const NTX_GPIO gt_ntx_gpio_bootcfg_15= {
+	MX6SL_PAD_LCD_DAT5__GPIO_2_25,  // pin pad/mux control .
+	2, // gpio group .
+	25, // gpio number .
+	0, // NC .
+	0, // not inited .
+	"BT_CFG15", // name .
+	1, // 1:input ; 0:output ; 2:btn .
+};
+
+static const NTX_GPIO gt_ntx_gpio_EPDPMIC_PWRGOOD= {
+	MX6SL_PAD_EPDC_PWRSTAT__GPIO_2_13_PUINT,  // pin pad/mux control .
+	2, // gpio group .
+	13, // gpio number .
+	0, // NC .
+	0, // not inited .
+	"EPDPMIC_PWRGOOD", // name .
+	1, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_EPDPMIC_VCOM= {
+	MX6SL_PAD_EPDC_VCOM0__GPIO_2_3,  // pin pad/mux control  .
+	2, // gpio group .
+	3, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"EPDPMIC_VCOM", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_EPDPMIC_VIN= {
+	MX6SL_PAD_EPDC_PWRWAKEUP__GPIO_2_14,  // pin pad/mux control  .
+	2, // gpio group .
+	14, // gpio number .
+	1, // default output value .
+	0, // not inited .
+	"EPDPMIC_VIN", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_65185_WAKEUP= {
+	MX6SL_PAD_EPDC_PWRCTRL0__GPIO_2_7,  // pin pad/mux control  .
+	2, // gpio group .
+	7, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"65185_WAKEUP", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+
+static const NTX_GPIO gt_ntx_gpio_65185_PWRUP= {
+	MX6SL_PAD_EPDC_PWRCTRL1__GPIO_2_8,  // pin pad/mux control  .
+	2, // gpio group .
+	8, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"65185_PWRUP", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+
+
+
+static const NTX_GPIO gt_ntx_gpio_ON_LED= {
+	MX6SL_PAD_FEC_REF_CLK__GPIO_4_26,  // pin pad/mux control .
+	4, // gpio group .
+	26, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"ON_LED", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+static NTX_GPIO gt_ntx_gpio_ON_LED_gp5_13= {
+	MX6SL_PAD_SD1_DAT2__GPIO_5_13,  // pin pad/mux control .
+	5, // gpio group .
+	13, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"ON_LED", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+static NTX_GPIO gt_ntx_gpio_ACTION_LED_gp5_10= {
+	MX6SL_PAD_SD1_DAT7__GPIO_5_10,  // pin pad/mux control .
+	5, // gpio group .
+	10, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"ACTION_LED", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+
+static const NTX_GPIO gt_ntx_gpio_ACTION_LED= {
+	MX6SL_PAD_FEC_TX_EN__GPIO_4_22,  // pin pad/mux control .
+	4, // gpio group .
+	22, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"ACTION_LED", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_ACTION_LED_gp5_7= {
+	MX6SL_PAD_SD1_DAT6__GPIO_5_7,  // pin pad/mux control .
+	5, // gpio group .
+	7, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"ACTION_LED", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_Charge_LED= {
+	MX6SL_PAD_FEC_TXD1__GPIO_4_16,  // pin pad/mux control .
+	4, // gpio group .
+	16, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"Charge_LED", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_Charge_LED_gp5_15= {
+	MX6SL_PAD_SD1_CLK__GPIO_5_15,  // pin pad/mux control .
+	5, // gpio group .
+	15, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"Charge_LED", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_Charge_LED_gp5_10= {
+	MX6SL_PAD_SD1_DAT7__GPIO_5_10,  // pin pad/mux control .
+	5, // gpio group .
+	10, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"Charge_LED", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_Charge_LED_gp5_9= {
+	MX6SL_PAD_SD1_DAT5__GPIO_5_9,  // pin pad/mux control .
+	5, // gpio group .
+	9, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"Charge_LED", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+
+static const NTX_GPIO gt_ntx_gpio_ISD_3V3_ON= {
+	MX6SL_PAD_KEY_ROW3__GPIO_3_31,  // pin pad/mux control .
+	3, // gpio group .
+	31, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"ISD_3V3", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_ESD_3V3_ON= {
+	MX6SL_PAD_KEY_ROW2__GPIO_3_29,  // pin pad/mux control .
+	3, // gpio group .
+	29, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"ESD_3V3", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_TP_3V3_ON= {
+	MX6SL_PAD_KEY_ROW4__GPIO_4_1,  // pin pad/mux control .
+	4, // gpio group .
+	1, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"TP_3V3", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+
+static const NTX_GPIO gt_ntx_gpio_IR_RST= {
+	MX6SL_PAD_SD1_DAT5__GPIO_5_9,  // pin pad/mux control .
+	5, // gpio group .
+	9, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"IR_RST", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_CT_RST= {
+	MX6SL_PAD_SD1_DAT2__GPIO_5_13,  // pin pad/mux control .
+	5, // gpio group .
+	13, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"CT_RST", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+
+
+static const NTX_GPIO gt_ntx_gpio_WIFI_3V3_ON= {
+	MX6SL_PAD_SD2_DAT6__GPIO_4_29,  // pin pad/mux control .
+	4, // gpio group .
+	29, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"WIFI_3V3", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+
+static const NTX_GPIO gt_ntx_gpio_EP_3V3_ON= {
+	MX6SL_PAD_KEY_ROW5__GPIO_4_3,  // pin pad/mux control .
+	4, // gpio group .
+	3, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"EP_3V3", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+static const NTX_GPIO gt_ntx_gpio_EP_PWRCTRL1= {
+	MX6SL_PAD_EPDC_PWRCTRL1__GPIO_2_8,  // pin pad/mux control .
+	2, // gpio group .
+	8, // gpio number .
+	0, // default output value .
+	0, // not inited .
+	"EPDC_PWRCTRL1", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+
+
+static const NTX_GPIO gt_ntx_gpio_HOME_LED= {
+	MX6SL_PAD_SD1_DAT7__GPIO_5_10,  // pin pad/mux control .
+	5, // gpio group .
+	10, // gpio number .
+	0, // default output value .
+	1, // inited .
+	"HOME_LED", // name .
+	0, // 1:input ; 0:output ; 2:btn .
+};
+
+#elif defined (_MX50_) //][
+#elif defined ( _MX6Q_ )
+#endif //]CONFIG_MX6SL
+
+
+// LED gpios ...
+static NTX_GPIO *gpt_ntx_gpio_LED_G;
+static NTX_GPIO *gpt_ntx_gpio_LED_B;
+static NTX_GPIO *gpt_ntx_gpio_LED_R;
+static NTX_GPIO *gpt_ntx_gpio_LED_HOME;
+
+// Touch reset gpios ...
+static NTX_GPIO *gpt_ntx_gpio_TP_RST; // Touch reset output .
+static NTX_GPIO *gpt_ntx_gpio_IR_RST; // IR touch reset output .
+static NTX_GPIO *gpt_ntx_gpio_CT_RST; // C touch reset output .
+
+// EPD PMIC gpios ...
+static NTX_GPIO *gpt_ntx_gpio_65185_WAKEUP;
+static NTX_GPIO *gpt_ntx_gpio_65185_PWRUP;
+static NTX_GPIO *gpt_ntx_gpio_FP9928_RAIL_ON;
+
+// MISC detction gpios ...
+static NTX_GPIO *gpt_ntx_gpio_esdin; // External SD detction pin .
+static NTX_GPIO *gpt_ntx_gpio_ACIN; // 
+static NTX_GPIO *gpt_ntx_gpio_USBID; // 
+
+// power switch gpios ...
+static NTX_GPIO *gpt_ntx_gpio_ISD_3V3_ON; // internal SD power .
+static NTX_GPIO *gpt_ntx_gpio_ESD_3V3_ON; // external SD power . 
+static NTX_GPIO *gpt_ntx_gpio_EP_3V3_ON; // EPD power .
+static NTX_GPIO *gpt_ntx_gpio_EP_VCOM_ON; // EPD power .
+static NTX_GPIO *gpt_ntx_gpio_TP_3V3_ON; // Touch power .
+static NTX_GPIO *gpt_ntx_gpio_WIFI_3V3_ON; // Wifi power .
+static NTX_GPIO *gpt_ntx_gpio_FLPWR; // Front light power .
+
+
+int ntxhw_USBID_detected(void)
+{
+	if(gpt_ntx_gpio_USBID && !ntx_gpio_get_value(gpt_ntx_gpio_USBID)) {
+		return 1;
+	}
+	return 0;
+}
+
+NTX_GPIO * ntx_gpio_keysA[NTX_GPIO_KEYS] = {
+#if defined(_MX6Q_) //[
+	&gt_ntx_gpio_power_key,
+	&gt_ntx_gpio_OTG_FB_key,
+#elif defined(_MX7D_) //][
+#elif defined(_MX6SL_) //][
+#elif defined(_MX6ULL_) //][
+//	&gt_ntx_gpio_home_key,
+//	&gt_ntx_gpio_fl_key,
+//	&gt_ntx_gpio_hallsensor_key,
+#endif //]_MX6SL_
+	0,
+};
+
+//int gi_ntx_gpio_keys=sizeof(ntx_gpio_keysA)/sizeof(ntx_gpio_keysA[0]);
+int gi_ntx_gpio_keys=0;
+
+NTX_GPIO *gptNtxGpioKey_Home,*gptNtxGpioKey_FL,*gptNtxGpioKey_Power;
+NTX_GPIO *gptNtxGpioKey_Menu,*gptNtxGpioKey_Return,*gptNtxGpioSW_HallSensor;
+NTX_GPIO *gptNtxGpioKey_Left,*gptNtxGpioKey_Right;
+
+void wifi_3v3(int iON) 
+{
+	void _set_WIFI_3V3_ON(int value);
+
+	_set_WIFI_3V3_ON(iON);
+}
+
+void _led_R(int iIsTurnON)
+{
+	if(!gptNtxHwCfg) {
+		printf("%s(%d) : cannot work without ntx hwconfig !\n",__FUNCTION__,iIsTurnON);
+		return ;
+	}
+
+#if defined(_MX7D_) || defined(_MX6SLL_) || defined(_MX6ULL_)//[
+	
+	if(gpt_ntx_gpio_LED_R) {
+		ntx_gpio_set_value(gpt_ntx_gpio_LED_R,iIsTurnON?0:1);
+	}
+
+#elif defined(_MX6SL_) //][
+	if(31==gptNtxHwCfg->m_val.bPCB||32==gptNtxHwCfg->m_val.bPCB) {
+		// E60Q0X/E60Q1X .
+		ntx_gpio_set_value(&gt_ntx_gpio_Charge_LED,iIsTurnON);
+	}
+	else if(47==gptNtxHwCfg->m_val.bPCB || 54==gptNtxHwCfg->m_val.bPCB) {
+		// ED0Q02 . ED0Q12
+	}
+	else if(40==gptNtxHwCfg->m_val.bPCB) {
+		// E60Q52 .
+		ntx_gpio_set_value(&gt_ntx_gpio_Charge_LED_gp5_15,iIsTurnON?0:1);
+	}
+	else if(55==gptNtxHwCfg->m_val.bPCB) {
+		// E70Q02 .
+		ntx_gpio_set_value(&gt_ntx_gpio_Charge_LED_gp5_9,iIsTurnON?0:1);
+	}
+	else {
+		if(5==gptNtxHwCfg->m_val.bLed||6==gptNtxHwCfg->m_val.bLed||7==gptNtxHwCfg->m_val.bLed||8==gptNtxHwCfg->m_val.bLed) {
+			// Green only/White only/No Lights/White and Home LED .
+		}
+		else
+		if(1==gptNtxHwCfg->m_val.bLed) {
+			// RGB type LED .
+			ntx_gpio_set_value(&gt_ntx_gpio_Charge_LED_gp5_10,iIsTurnON?0:1);
+		}
+		else {
+			ntx_gpio_set_value(&gt_ntx_gpio_Charge_LED_gp5_15,iIsTurnON?0:1);
+		}
+	}
+#endif //]_MX6SL_ || _MX6SLL_
+}
+/*
+ * For models without RGB LED, default goes _led_G()
+ */
+void _led_G(int iIsTurnON)
+{
+
+#if defined(_MX7D_) || defined(_MX6ULL_) || defined(_MX6SLL_) //[
+	if(6==gptNtxHwCfg->m_val.bLed) {
+		// no lights .
+	}
+	else {
+		//printf("%s(%d):%p\n",__FUNCTION__,iIsTurnON,gpt_ntx_gpio_LED_G);
+		if(gpt_ntx_gpio_LED_G) {
+			if(iIsTurnON) {
+				ntx_gpio_set_valueEx(gpt_ntx_gpio_LED_G,0,0);
+			}
+			else {
+				ntx_gpio_set_valueEx(gpt_ntx_gpio_LED_G,1,0);
+			}
+		}
+	}
+#elif defined(_MX6SL_) //][
+	int iChk;
+
+	//printf("%s(%d)\n",__FUNCTION__,iIsTurnON);
+	//ntx_gpio_set_value(&gt_ntx_gpio_ISD_3V3_ON,0);
+	//ntx_gpio_set_value(&gt_ntx_gpio_ESD_3V3_ON,1);
+	//ntx_gpio_set_value(&gt_ntx_gpio_TP_3V3_ON,1);
+	//ntx_gpio_set_value(&gt_ntx_gpio_WIFI_3V3_ON,0);
+	//ntx_gpio_set_value(&gt_ntx_gpio_EP_3V3_ON,1);
+	if(!gptNtxHwCfg) {
+		printf("%s(%d) : cannot work without ntx hwconfig !\n",__FUNCTION__,iIsTurnON);
+		return ;
+	}
+
+	if(31==gptNtxHwCfg->m_val.bPCB||32==gptNtxHwCfg->m_val.bPCB) {
+		// E60Q0X/E60Q1X .
+		ntx_gpio_set_value(&gt_ntx_gpio_ACTION_LED,iIsTurnON);
+	}
+	else if(50==gptNtxHwCfg->m_val.bPCB||46==gptNtxHwCfg->m_val.bPCB||
+		58==gptNtxHwCfg->m_val.bPCB||42==gptNtxHwCfg->m_val.bPCB||
+		61==gptNtxHwCfg->m_val.bPCB)
+	{
+		// E60QFX/E60Q9X/E60QJX/E60Q6X/E60QKX .
+		if(iIsTurnON) {
+
+			gt_ntx_gpio_ON_LED_gp5_13.iIsInited = 0;
+#if 1
+			gt_ntx_gpio_ON_LED_gp5_13.iDirection = 0;
+			ntx_gpio_set_value(&gt_ntx_gpio_ON_LED_gp5_13,0);
+#else
+			gt_ntx_gpio_ON_LED_gp5_13.iDirection = 1;
+			iChk = ntx_gpio_get_value(&gt_ntx_gpio_ON_LED_gp5_13);
+			if(iChk!=0) {
+				printf("The LED should be set low ,Please check !!!\n");
+			}
+#endif
+		}
+		else {
+			gt_ntx_gpio_ON_LED_gp5_13.iIsInited = 0;
+			gt_ntx_gpio_ON_LED_gp5_13.iDirection = 0;
+			ntx_gpio_set_value(&gt_ntx_gpio_ON_LED_gp5_13,1);
+		}
+	}
+	else {
+		if(6==gptNtxHwCfg->m_val.bLed) {
+			// no lights .
+		}
+		else {
+			ntx_gpio_set_value(&gt_ntx_gpio_ACTION_LED_gp5_7,iIsTurnON?0:1);
+		}
+	}
+#endif //]_MX6SL_
+}
+void _led_B(int iIsTurnON)
+{
+#if defined(_MX7D_) || defined(_MX6ULL_) || defined(_MX6SLL_) //[
+	if(gpt_ntx_gpio_LED_B) {
+		ntx_gpio_set_value(gpt_ntx_gpio_LED_B,iIsTurnON?0:1);
+	}
+#elif defined(_MX6SL_) //][
+	if(31==gptNtxHwCfg->m_val.bPCB||32==gptNtxHwCfg->m_val.bPCB) {
+		ntx_gpio_set_value(&gt_ntx_gpio_ON_LED,iIsTurnON);
+	}
+	else if(47==gptNtxHwCfg->m_val.bPCB || 54==gptNtxHwCfg->m_val.bPCB) {
+		// ED0Q02 . ED0Q12
+	}
+	else if(55==gptNtxHwCfg->m_val.bPCB) {
+		// E70Q02 .
+		ntx_gpio_set_value(&gt_ntx_gpio_ACTION_LED_gp5_10,iIsTurnON?0:1);
+	}
+	else {
+		if(1==gptNtxHwCfg->m_val.bLed) {
+			// RGB type LED .
+			ntx_gpio_set_value(&gt_ntx_gpio_ON_LED_gp5_13,iIsTurnON?0:1);
+		}
+	}
+#endif //]_MX6SL_
+}
+
+void _set_ISD_3V3_ON(int value)
+{
+	if(gpt_ntx_gpio_ISD_3V3_ON) {
+		ntx_gpio_set_value(gpt_ntx_gpio_ISD_3V3_ON, value);
+	}
+}
+
+void _set_ESD_3V3_ON(int value)
+{
+	if(gpt_ntx_gpio_ESD_3V3_ON) {
+		ntx_gpio_set_value(gpt_ntx_gpio_ESD_3V3_ON, value);
+	}
+}
+
+void _set_TP_3V3_ON(int value)
+{
+	if(gpt_ntx_gpio_TP_3V3_ON) {
+		ntx_gpio_set_value(gpt_ntx_gpio_TP_3V3_ON, value);
+	}
+}
+void _set_TP_RST(int value)
+{
+	if(gpt_ntx_gpio_TP_RST) {
+		ntx_gpio_set_value(gpt_ntx_gpio_TP_RST, value);
+	}
+
+}
+
+
+void _set_WIFI_3V3_ON(int value)
+{
+	if(gpt_ntx_gpio_WIFI_3V3_ON) {
+		ntx_gpio_set_value((NTX_GPIO *)gpt_ntx_gpio_WIFI_3V3_ON, value);
+	}
+}
+
+void _set_EP_3V3_ON(int value)
+{
+	if(gpt_ntx_gpio_EP_3V3_ON) {
+		ntx_gpio_set_value(gpt_ntx_gpio_EP_3V3_ON, value);
+	}
+}
+
+
+int __get_sd_number(void)
+{
+	int iBT_PortNum=-1;
+#ifdef _MX6Q_ //[
+	int iBT_CFG_PORT0,iBT_CFG_PORT1;
+
+	iBT_CFG_PORT0=ntx_gpio_get_value((NTX_GPIO *)&gt_ntx_gpio_bootcfg_0);
+	iBT_CFG_PORT1=ntx_gpio_get_value((NTX_GPIO *)&gt_ntx_gpio_bootcfg_1);
+	iBT_PortNum=iBT_CFG_PORT1<<1|iBT_CFG_PORT0;
+#elif defined(_MX6SL_) || defined(_MX6SLL_) //][!_MX6Q_
+	int iBT_CFG23,iBT_CFG24;
+
+	iBT_CFG23=ntx_gpio_get_value((NTX_GPIO *)&gt_ntx_gpio_bootcfg_23);
+	iBT_CFG24=ntx_gpio_get_value((NTX_GPIO *)&gt_ntx_gpio_bootcfg_24);
+	printf("%s(),cfg23=%d,cfg24=%d \n",__FUNCTION__,iBT_CFG23,iBT_CFG24);
+	iBT_PortNum=iBT_CFG24<<1|iBT_CFG23;
+#elif defined(_MX6ULL_) //][!_MX6ULL_
+#if 1
+	iBT_PortNum=1;
+#else
+	int iBT_CFG2_3,iBT_CFG2_4;
+
+	iBT_CFG2_4=ntx_gpio_get_value((NTX_GPIO *)&gt_ntx_gpio_bootcfg2_4);
+	iBT_CFG2_3=ntx_gpio_get_value((NTX_GPIO *)&gt_ntx_gpio_bootcfg2_3);
+	printf("%s(),cfg2_3=%d,cfg2_4=%d \n",__FUNCTION__,iBT_CFG2_3,iBT_CFG2_4);
+	iBT_PortNum=iBT_CFG2_4<<1|iBT_CFG2_3;
+#endif
+#elif defined(_MX7D_) //][!_MX7D_
+	int iBT_CFG11,iBT_CFG10;
+
+	iBT_CFG11=ntx_gpio_get_value((NTX_GPIO *)&gt_ntx_gpio_bootcfg_11);
+	iBT_CFG10=ntx_gpio_get_value((NTX_GPIO *)&gt_ntx_gpio_bootcfg_10);
+	printf("%s(),cfg11=%d,cfg10=%d \n",__FUNCTION__,iBT_CFG11,iBT_CFG10);
+	iBT_PortNum=iBT_CFG11<<1|iBT_CFG10;
+#endif //] _MX6Q_
+
+	return iBT_PortNum;
+}
+
+unsigned char ntxhw_get_bootdevice_type(void) 
+{
+	unsigned char bBootDevType = NTXHW_BOOTDEV_UNKOWN;
+#ifdef _MX7D_ //[
+#elif defined(_MX6ULL_) //][
+#elif defined(_MX6SL_) //][
+
+	unsigned char bBootCfg15;
+	unsigned char bBootCfg16;
+
+	bBootCfg15=ntx_gpio_get_value(&gt_ntx_gpio_bootcfg_15)?0x1:0x0;
+	bBootCfg16=ntx_gpio_get_value(&gt_ntx_gpio_bootcfg_16)?0x2:0x0;
+
+	bBootDevType=bBootCfg15|bBootCfg16;
+
+	#if 0
+	printf("%s(),BT_CFG15=%x,BT_CFG16=%x,BT_DEV=%x\n",__FUNCTION__,
+			bBootCfg15,bBootCfg16,bBootDevType);
+	#endif
+#else //][!_MX6SL_
+
+#endif //]_MX6SL_
+
+	return bBootDevType;
+}
+
+int _get_boot_sd_number(void)
+{
+	static int giBT_PortNum=-1;
+
+	if(-1==giBT_PortNum) {
+		//char cCmdA[256];
+
+		giBT_PortNum=__get_sd_number();
+
+		//sprintf(cCmdA,"setenv fastboot_dev mmc%d",giBT_PortNum);
+		//run_command(cCmdA, 0);// 
+
+	}
+	else {
+	}
+
+	return giBT_PortNum;
+}
+
+int _get_pcba_id (void)
+{
+	static int g_pcba_id;
+
+	if(g_pcba_id) {
+		return g_pcba_id;
+	}
+
+	if(gptNtxHwCfg) {
+		switch(gptNtxHwCfg->m_val.bPCB)
+		{
+
+#ifdef _MX7D_ //[
+#elif defined(_MX6SL_)||defined(_MX6SLL_) //][
+#elif defined(_MX6ULL_) //][
+#else //][ !_MX6SL_
+			case 12: //E60610
+			case 20: //E60610C
+			case 21: //E60610D
+				g_pcba_id = 1;
+				break;
+			case 15: //E60620
+				g_pcba_id = 4;
+				break;
+			case 16: //E60630
+				g_pcba_id = 6;
+				break;
+			case 18: //E50600
+				g_pcba_id = 2;
+				break;
+			case 19: //E60680
+				g_pcba_id = 3;
+				break;
+			case 22: //E606A0
+				g_pcba_id = 10;
+				break;
+			case 23: //E60670
+				g_pcba_id = 5;
+				break;
+			case 24: //E606B0
+				g_pcba_id = 14;
+				break;
+			case 27: //E50610
+				g_pcba_id = 9;
+				break;
+			case 28: //E606C0
+				g_pcba_id = 11;
+				break;
+#endif //]_MX6SL
+
+			default:
+				g_pcba_id = gptNtxHwCfg->m_val.bPCB;
+				printf ("[%s-%d] PCBA ID=%d\n",__func__,__LINE__,g_pcba_id);
+				break;	
+		}
+	}
+	else {
+		printf("%s(): [Warning] No hwconfig !\n",__FUNCTION__);
+	}
+	
+	return g_pcba_id;
+}
+
+int _power_key_status (void)
+{
+	int iRet;
+	iRet=ntx_gpio_key_is_down(gptNtxGpioKey_Power);
+	return iRet;
+}
+
+int _sd_cd_status (void)
+{
+#ifdef _MX6Q_ //[
+	return 0;
+#else//][!_MX6Q_
+	if(gpt_ntx_gpio_esdin) {
+		printf ("no extSD defined.\n");
+		return 0;
+	}
+	else {
+		return ntx_gpio_get_value(gpt_ntx_gpio_esdin)?0:1;
+	}
+#endif //] _MX6Q_
+}
+
+int _hallsensor_status (void)
+{
+#if defined (_MX6Q_) //[
+#else //][!
+	if(gptNtxGpioSW_HallSensor) {
+		// E60Q1X/E60Q0X .
+		return ntx_gpio_key_is_down(gptNtxGpioSW_HallSensor);
+	}
+	else {
+		return -1;
+	}
+#endif //]
+	return 0;
+}
+
+int ntx_gpio_key_is_fastboot_down(void)
+{
+#ifdef _MX6Q_ //[
+	return ntx_gpio_key_is_down(&gt_ntx_gpio_OTG_FB_key);
+#elif defined(_MX6SL_) || defined(_MX6SLL_) || defined(_MX6ULL_)
+	if( 36==gptNtxHwCfg->m_val.bPCB || 40==gptNtxHwCfg->m_val.bPCB|| 
+			50==gptNtxHwCfg->m_val.bPCB || 
+			16==gptNtxHwCfg->m_val.bKeyPad || 18==gptNtxHwCfg->m_val.bKeyPad ||
+			11==gptNtxHwCfg->m_val.bKeyPad )
+	{
+		// Q30/Q50/QF0/QG0/Keypad type: HOMEPAD/FL_Key .
+		return ntx_gpio_key_is_fl_down();
+	}
+	else {
+		return ntx_gpio_key_is_home_down();
+	}
+#else //][!_MX6Q_
+	return 0;
+#endif//] _MX6Q_
+}
+int ntx_gpio_key_is_home_down(void)
+{
+#if defined(_MX6SL_)||defined(_MX6SLL_)||defined(_MX6ULL_)//[
+	if(gptNtxGpioKey_Home) {
+		return ntx_gpio_key_is_down(gptNtxGpioKey_Home);
+	}
+#endif //]_MX6SL_
+
+	return 0;
+}
+
+int ntx_gpio_key_is_menu_down(void)
+{
+
+#if defined(_MX6SL_) || defined(_MX6SLL_) || defined(_MX6ULL_)//[
+	if(gptNtxGpioKey_Menu) {
+		return ntx_gpio_key_is_down(gptNtxGpioKey_Menu);
+	}
+#endif //]_MX6SL_
+	return 0;
+}
+
+int ntx_gpio_key_is_fl_down(void)
+{
+#if defined(_MX6SL_) || defined(_MX6SLL_) || defined(_MX6ULL_)//[
+	if(gptNtxGpioKey_FL) {
+		return ntx_gpio_key_is_down(gptNtxGpioKey_FL);
+	}
+#endif //]
+	return 0;
+}
+
+
+static const unsigned char gbMicroPI2C_ChipAddr = 0x43;
+static unsigned int guiMicroPI2C_I2C_bus = 2;// I2C3
+int msp430_I2C_Chn_set(unsigned int uiI2C_Chn)
+{
+	switch(uiI2C_Chn) {
+	case 0:
+	case 1:
+	case 2:
+	case 3:
+		guiMicroPI2C_I2C_bus = uiI2C_Chn;
+		break;
+	default:
+		printf("%s invalid I2C channel #%u!!\n",__FUNCTION__,uiI2C_Chn);
+		return -1;
+	}
+	return 0;
+}
+
+int msp430_read_buf(unsigned char bRegAddr,unsigned char *O_pbBuf,int I_iBufSize)
+{
+	int iRet;
+	unsigned int uiCurrI2CBus;
+
+	uiCurrI2CBus = i2c_get_bus_num();
+	if(uiCurrI2CBus!=guiMicroPI2C_I2C_bus) {
+#ifdef DEBUG_I2C_CHN//[
+		printf("%s(): change I2C bus to %d for MSP430\n",
+				__FUNCTION__,(int)guiMicroPI2C_I2C_bus);
+#endif //]DEBUG_I2C_CHN
+		i2c_set_bus_num(guiMicroPI2C_I2C_bus);
+	}
+
+	iRet = i2c_read(gbMicroPI2C_ChipAddr, bRegAddr, 1, O_pbBuf, I_iBufSize);
+
+	if(uiCurrI2CBus!=guiMicroPI2C_I2C_bus) {
+#ifdef DEBUG_I2C_CHN//[
+		printf("%s(): restore I2C bus to %d \n",
+				__FUNCTION__,(int)uiCurrI2CBus);
+#endif//]DEBUG_I2C_CHN
+		i2c_set_bus_num(uiCurrI2CBus);
+	}
+
+	return iRet;
+}
+int msp430_read_reg(unsigned char bRegAddr,unsigned char *O_pbRegVal)
+{
+	return msp430_read_buf(bRegAddr,O_pbRegVal,1);
+}
+
+int msp430_write_buf(unsigned char bRegAddr,unsigned char *I_pbBuf,int I_iBufSize)
+{
+	int iRet;
+	unsigned int uiCurrI2CBus;
+
+	uiCurrI2CBus = i2c_get_bus_num();
+	if(uiCurrI2CBus!=guiMicroPI2C_I2C_bus) {
+#ifdef DEBUG_I2C_CHN//[
+		printf("%s(): change I2C bus to %d for MSP430\n",
+				__FUNCTION__,(int)guiMicroPI2C_I2C_bus);
+#endif//]DEBUG_I2C_CHN
+		i2c_set_bus_num(guiMicroPI2C_I2C_bus);
+	}
+
+	iRet = i2c_write(gbMicroPI2C_ChipAddr,bRegAddr,1,I_pbBuf,I_iBufSize);
+
+	if(uiCurrI2CBus!=guiMicroPI2C_I2C_bus) {
+#ifdef DEBUG_I2C_CHN//[
+		printf("%s(): restore I2C bus to %d \n",
+				__FUNCTION__,(int)uiCurrI2CBus);
+#endif //]DEBUG_I2C_CHN
+		i2c_set_bus_num(uiCurrI2CBus);
+	}
+
+	return iRet;
+}
+int msp430_write_reg(unsigned char bRegAddr,unsigned char bRegVal)
+{
+	return msp430_write_buf(bRegAddr,&bRegVal,1);
+}
+
+
+#ifdef PMIC_RC5T619 //[
+
+static const unsigned char gbRicohRC5T619_ChipAddr=0x32;
+static unsigned int guiRicohRC5T619_I2C_bus=2;// I2C3 .
+
+int RC5T619_I2C_Chn_set(unsigned int uiI2C_Chn)
+{
+	switch(uiI2C_Chn) {
+	case 0:// I2C1 .
+	case 1:// I2C2 .
+	case 2:// I2C3 .
+	case 3:// I2C4 .
+		guiRicohRC5T619_I2C_bus = uiI2C_Chn;
+		break;
+	default:
+		printf("%s invalid I2C channel #%u!!\n",__FUNCTION__,uiI2C_Chn);
+		return -1;
+	}
+	return 0;
+}
+
+int RC5T619_read_reg(unsigned char bRegAddr,unsigned char *O_pbRegVal)
+{
+	int iRet = -1;
+	int iChk;
+	unsigned char bRegVal;
+	unsigned int uiCurrI2CBus;
+
+	uiCurrI2CBus = i2c_get_bus_num();
+	if(uiCurrI2CBus!=guiRicohRC5T619_I2C_bus) {
+#ifdef DEBUG_I2C_CHN//[
+		printf("%s(): change I2C bus to %d for RC5T619\n",
+				__FUNCTION__,(int)guiRicohRC5T619_I2C_bus);
+#endif//] DEBUG_I2C_CHN
+		i2c_set_bus_num(guiRicohRC5T619_I2C_bus);
+	}
+
+	iChk = i2c_read(gbRicohRC5T619_ChipAddr, bRegAddr, 1, &bRegVal, 1);
+	if(0==iChk) {
+//		printf("RC5T619 [0x%x]=0x%x\n",bRegAddr,bRegVal);
+		if(O_pbRegVal) {
+			*O_pbRegVal = bRegVal;
+			iRet = 0;
+		}
+		else {
+			iRet = 1;
+		}
+	}
+	else {
+		printf("RC5T619 read [0x%x] failed !!\n",bRegAddr);
+	}
+
+	if(uiCurrI2CBus!=guiRicohRC5T619_I2C_bus) {
+#ifdef DEBUG_I2C_CHN//[
+		printf("%s(): restore I2C bus to %d \n",
+				__FUNCTION__,(int)uiCurrI2CBus);
+#endif //]DEBUG_I2C_CHN
+		i2c_set_bus_num(uiCurrI2CBus);
+	}
+
+	return iRet;
+}
+int RC5T619_write_buffer(unsigned char bRegAddr,unsigned char *I_pbRegWrBuf,unsigned short I_wRegWrBufBytes)
+{
+	int iRet = -1;
+	unsigned int uiCurrI2CBus;
+	int iChk;
+
+	uiCurrI2CBus = i2c_get_bus_num();
+	if(uiCurrI2CBus!=guiRicohRC5T619_I2C_bus) {
+#ifdef DEBUG_I2C_CHN//[
+		printf("%s(): change I2C bus to %d for RC5T619\n",
+				__FUNCTION__,(int)guiRicohRC5T619_I2C_bus);
+#endif //]DEBUG_I2C_CHN
+		i2c_set_bus_num(guiRicohRC5T619_I2C_bus);
+	}
+
+	iChk = i2c_write(gbRicohRC5T619_ChipAddr, bRegAddr, 1, I_pbRegWrBuf, I_wRegWrBufBytes);
+	if(0==iChk) {
+		iRet=(int)I_wRegWrBufBytes;
+	}
+	else {
+		printf("RC5T619 write to [0x%x] %d bytes failed !!\n",bRegAddr,I_wRegWrBufBytes);
+		iRet=iChk ;
+	}
+
+	if(uiCurrI2CBus!=guiRicohRC5T619_I2C_bus) {
+#ifdef DEBUG_I2C_CHN//[
+		printf("%s(): restore I2C bus to %d \n",
+				__FUNCTION__,(int)uiCurrI2CBus);
+#endif //]DEBUG_I2C_CHN
+		i2c_set_bus_num(uiCurrI2CBus);
+	}
+
+	return iRet;
+}
+
+int RC5T619_write_reg(unsigned char bRegAddr,unsigned char bRegWrVal)
+{
+	return RC5T619_write_buffer(bRegAddr,&bRegWrVal,1);
+}
+
+int RC5T619_set_charger_params(int iChargerType)
+{
+	unsigned char val;
+	if(1!=gptNtxHwCfg->m_val.bPMIC) {
+		//printf("%s():skipped ,RC5T619 disabled by hwconfig",__FUNCTION__);
+		return -3;
+	}
+
+	RC5T619_read_reg (0xBD, &val);
+	if (0 == (val & 0xC0))
+		return 0;
+
+	switch (iChargerType) {
+	default:
+	case USB_CHARGER_SDP:
+		{
+			int retry_cnt = 10;
+			unsigned char ilim=8;		// set ILIM 900mA
+
+			if (49 == gptNtxHwCfg->m_val.bPCB)
+				ilim = 5;	// set ILIM 600mA for E60QDx
+			RC5T619_write_reg (0xB6, ilim);	// REGISET1 , set ILIM_ADP
+			RC5T619_write_reg (0xB8, 0x04);	// CHGISET , set ICHG 500mA
+			RC5T619_write_reg (0xB7, (0xE0|ilim));	// REGISET2 , set ILIM_USB
+			do {
+				RC5T619_write_reg (0xB7, (0xE0|ilim));	// REGISET2 , set ILIM_USB
+				RC5T619_read_reg (0xB7, &val);
+				if (ilim != (val&0x0F))
+					printf ("REGISET2 val %02X\n",val);
+			} while ((val != (val&0x0F)) && (--retry_cnt));
+		}
+		break;
+	case USB_CHARGER_CDP:
+	case USB_CHARGER_DCP:
+		//printf ("%s : set 900mA for DCP/CDP \n",__func__);
+		RC5T619_write_reg (0xB6, 0x09);	// REGISET1 , set ILIM_ADP 1000mA
+		RC5T619_write_reg (0xB7, 0x29);	// REGISET2 , set ILIM_USB 1000mA
+		RC5T619_write_reg (0xB8, 0x07);	// CHGISET , set ICHG 800mA
+		break;
+	}
+	return 0;
+}
+
+int RC5T619_charger_redetect(void)
+{
+	int iRet=0;
+	int iChk;
+	unsigned char bRegAddr,bVal;
+
+	if(1!=gptNtxHwCfg->m_val.bPMIC) {
+		//printf("%s():skipped ,RC5T619 disabled by hwconfig",__FUNCTION__);
+		return -3;
+	}
+ 
+	bRegAddr = 0xDA;
+	bVal = 0x01;
+	iChk = RC5T619_write_reg(bRegAddr,bVal);
+	if(iChk<0) {
+		printf("%s():write reg0x%x->0x%x error %d",
+				__FUNCTION__,bRegAddr,bVal,iChk);
+		return -1;
+	}
+
+	return iRet;
+}
+
+int RC5T619_restart(void)
+{
+	int iRet=0;
+	int iChk;
+	unsigned char bRegAddr,bVal;
+
+	if(1!=gptNtxHwCfg->m_val.bPMIC) {
+		//printf("%s():skipped ,RC5T619 disabled by hwconfig",__FUNCTION__);
+		return -3;
+	}
+
+	printf("%s():restarting system ...\n",__FUNCTION__);
+
+	bRegAddr = 0x0f; // RICOH61x_PWR_REP_CNT .
+	bVal = 0x35;// 500ms off time .
+	iChk = RC5T619_write_reg(bRegAddr,bVal);
+	if(iChk<0) {
+		printf("%s():write reg0x%x->0x%x error %d",
+				__FUNCTION__,bRegAddr,bVal,iChk);
+		return -1;
+	}
+
+	bRegAddr = 0x0e; // RICOH61x_PWR_SLP_CNT .
+	bVal = 0x1; 
+	iChk = RC5T619_write_reg(bRegAddr,bVal);
+	if(iChk<0) {
+		printf("%s():write reg0x%x->0x%x error %d",
+				__FUNCTION__,bRegAddr,bVal,iChk);
+		return -1;
+	}
+
+	return iRet;
+}
+
+int RC5T619_enable_watchdog(int iIsEnable)
+{
+	int iRet=0;
+	int iChk;
+	unsigned char bRegAddr,bVal ;
+
+	if(1!=gptNtxHwCfg->m_val.bPMIC) {
+		//printf("%s():skipped ,RC5T619 disabled by hwconfig",__FUNCTION__);
+		return -3;
+	}
+
+	RC5T619_write_reg(0x11, 8);	// disable N_OE
+
+	bRegAddr = 0x0B;
+	iChk = RC5T619_read_reg(bRegAddr,&bVal);
+	if(iChk<0) {
+		printf("%s():read reg0x%x error %d",
+				__FUNCTION__,bRegAddr,iChk);
+		return -1;
+	}
+
+	// RICOH61x_PWR_WD
+	if(iIsEnable) {
+		bVal &= ~0x0C;
+		iChk = RC5T619_write_reg(bRegAddr,bVal);
+	}
+	else {
+		bVal |= 0x0C;
+		iChk = RC5T619_write_reg(bRegAddr,bVal);
+	}
+
+	if(iChk<0) {
+		printf("%s():write reg0x%x error %d",
+				__FUNCTION__,bRegAddr,iChk);
+		iRet = -2;
+	}
+
+	return iRet;
+}
+#else //][!PMIC_RC5T619
+int RC5T619_read_reg(unsigned char bRegAddr,unsigned char *O_pbRegVal){return -1;}
+int RC5T619_write_reg(unsigned char bRegAddr,unsigned char bRegWrVal){return -1;}
+int RC5T619_write_buffer(unsigned char bRegAddr,unsigned char *I_pbRegWrBuf,unsigned short I_wRegWrBufBytes){return -1;}
+int RC5T619_enable_watchdog(int iIsEnable){return -1;}
+int RC5T619_charger_redetect(void){return -1;}
+int RC5T619_I2C_Chn_set(unsigned int uiI2C_Chn) {return -1;}
+#endif //] PMIC_RC5T619
+
+
+int ntx_detect_usb_plugin(int iIsDetectChargerType) 
+{
+	int iRet=0;
+	if(1==gptNtxHwCfg->m_val.bPMIC) {
+#ifdef PMIC_RC5T619 //[
+		unsigned char bReg,bRegAddr;
+		int iChk;
+		int iTryCnt=0;
+		const int iTryMax=50;
+
+
+		// Ricoh RC5T619 .
+		bRegAddr=0xbd;
+		iChk = RC5T619_read_reg(bRegAddr,&bReg);
+		if(iChk>=0) {
+			if(bReg&0xc0) 
+			{
+				iRet = USB_CHARGER_UNKOWN;
+
+				if(iIsDetectChargerType) 
+				{
+					RC5T619_charger_redetect();
+					printf("%s():Charge detecting ...",__FUNCTION__);
+					do {
+						if(++iTryCnt>=iTryMax) {
+							printf("retry(%d) timed out\n",iTryCnt);
+							break;
+						}
+
+						iChk = RC5T619_read_reg(0xDA,&bReg);	// GCHGDET_REG
+
+						if(0x8!=(bReg&0xc)) {
+							// Detecting not completely .
+							udelay(10*1000);
+							printf(".");
+							continue ;
+						}
+
+						if (bReg & 0x30) {
+							if((bReg & 0x30)==0x01) {
+								printf ("set 900mA for CDP (%d)\n",iTryCnt);
+								RC5T619_set_charger_params(USB_CHARGER_CDP);
+								iRet = USB_CHARGER_CDP;
+							}
+							else {
+								printf ("set 900mA for DCP (%d)\n",iTryCnt);
+								RC5T619_set_charger_params(USB_CHARGER_DCP);
+								iRet = USB_CHARGER_DCP;
+							}
+						}
+						else {
+							printf ("set 500mA for SDP (0x%02x)(%d)\n",bReg,iTryCnt);
+							RC5T619_set_charger_params(USB_CHARGER_SDP);
+							iRet = USB_CHARGER_SDP;
+						}
+						break;
+					}while(1);
+
+				}// Detecting Charger type ...
+			}
+		}
+#endif //]PMIC_RC5T619
+	}
+	else {
+		if(gpt_ntx_gpio_ACIN) {
+			iRet = ntx_gpio_get_value(gpt_ntx_gpio_ACIN)?0:1;
+		}
+		else {
+			iRet = 0;
+		}
+	}
+
+	if(49==gptNtxHwCfg->m_val.bPCB && gptNtxHwCfg->m_val.bPCB_REV>=0x20) {
+		// E60QDXA2
+		// detect the usb id pin .
+		if(ntxhw_USBID_detected()) {
+			iRet |= USB_CHARGER_OTG;
+		}
+	}
+
+	return iRet;
+}
+
+
+int init_pwr_i2c_function(int iSetAsFunc)
+{
+	return 0;
+}
+
+void EPDPMIC_power_on(int iIsPowerON)
+{
+#ifdef _MX6Q_//[
+#else //][!_MX6Q_
+	if(iIsPowerON) {
+		ntx_gpio_set_value((NTX_GPIO *)&gt_ntx_gpio_EPDPMIC_VIN,1);
+	}
+	else {
+		ntx_gpio_set_value((NTX_GPIO *)&gt_ntx_gpio_EPDPMIC_VIN,0);
+	}
+#endif ///]_MX6Q_
+}
+void EPDPMIC_vcom_onoff(int iIsON)
+{
+#ifdef _MX6Q_//[
+#else //][!_MX6Q_
+	if(iIsON) {
+		ntx_gpio_set_value((NTX_GPIO *)&gt_ntx_gpio_EPDPMIC_VCOM,1);
+	}
+	else {
+		ntx_gpio_set_value((NTX_GPIO *)&gt_ntx_gpio_EPDPMIC_VCOM,0);
+	}
+#endif//] _MX6Q_
+}
+
+int EPDPMIC_isPowerGood(void)
+{
+	int iRet;
+	iRet = ntx_gpio_get_value((NTX_GPIO *)&gt_ntx_gpio_EPDPMIC_PWRGOOD)?1:0;
+	//printf("%s() = %d\n",__FUNCTION__,iRet);
+	return iRet;
+}
+ 
+void FP9928_rail_power_onoff(int iIsON)
+{
+	if(gpt_ntx_gpio_FP9928_RAIL_ON) {
+		ntx_gpio_set_value(gpt_ntx_gpio_FP9928_RAIL_ON,iIsON?1:0);
+	}
+}
+
+void _init_tps65185_power(int iIsWakeup,int iIsActivePwr)
+{
+
+#ifdef _MX6Q_//[
+#else //][!_MX6Q_
+	udelay(200);
+	printf("@@@ init_tps_65185_WAKEUP @@@\r\n ");
+	if(gpt_ntx_gpio_65185_WAKEUP) {
+		ntx_gpio_set_value(gpt_ntx_gpio_65185_WAKEUP,iIsWakeup);
+	}
+
+	printf("@@@ init_tps_65185_PWRUP @@@\r\n ");
+	if(gpt_ntx_gpio_65185_PWRUP) {
+		ntx_gpio_set_value(gpt_ntx_gpio_65185_PWRUP,iIsActivePwr);
+		if(iIsActivePwr) {
+			udelay(2*1000);
+		}
+	}
+
+#endif //]_MX6Q_
+}
+
+void tps65185_rail_power_onoff(int iIsON)
+{
+	if(iIsON) {
+		if(gpt_ntx_gpio_65185_WAKEUP) {
+			if(1!=ntx_gpio_get_current_value(gpt_ntx_gpio_65185_WAKEUP)) {
+				printf("%s() TPS65185 wakeup\n",__FUNCTION__);
+				ntx_gpio_set_value(gpt_ntx_gpio_65185_WAKEUP,1);
+				udelay(2000);
+			}
+		}
+		if(gpt_ntx_gpio_65185_PWRUP) {
+			if(1!=ntx_gpio_get_current_value(gpt_ntx_gpio_65185_PWRUP)) {
+				printf("%s() TPS65185 Enable RAIL POWER\n",__FUNCTION__);
+				ntx_gpio_set_value(gpt_ntx_gpio_65185_PWRUP,1);
+				udelay(2000);
+			}
+		}
+	}
+	else {
+
+		if(gpt_ntx_gpio_65185_PWRUP) {
+			if(0!=ntx_gpio_get_current_value(gpt_ntx_gpio_65185_PWRUP)) {
+				printf("%s() TPS65185 Disable RAIL POWER\n",__FUNCTION__);
+				ntx_gpio_set_value(gpt_ntx_gpio_65185_PWRUP,0);
+				udelay(2000);
+			}
+		}
+
+		if(gpt_ntx_gpio_65185_WAKEUP) {
+			if(0!=ntx_gpio_get_current_value(gpt_ntx_gpio_65185_WAKEUP)) {
+				printf("%s() TPS65185 sleep\n",__FUNCTION__);
+				ntx_gpio_set_value(gpt_ntx_gpio_65185_WAKEUP,0);
+				udelay(2000);
+			}
+		}
+	}
+}
+
+static void ntx_io_assign(void)
+{
+	// assigns power key .
+	if(!gptNtxHwCfg) {
+		printf("warning : ntxhwcfg not exist !\n");
+	}
+	gptNtxGpioKey_Power = (NTX_GPIO *)&gt_ntx_gpio_power_key;
+	#if defined(_MX6SLL_)
+	if (NTXHWCFG_TST_FLAG(gptNtxHwCfg->m_val.bPCB_Flags2,0)) 
+		gptNtxGpioKey_Power = (NTX_GPIO *)&gt_ntx_gpio_power_key_2;
+	#endif
+
+	// assigns home key .
+	if(11==gptNtxHwCfg->m_val.bKeyPad || 12==gptNtxHwCfg->m_val.bKeyPad ) {
+		// KeyPad is FL_Key/NO_Key .
+		gptNtxGpioKey_Home = 0;
+	}
+	else {
+		gptNtxGpioKey_Home = (NTX_GPIO *)&gt_ntx_gpio_home_key;
+	}
+
+	// assigns frontlight key .
+	if(12==gptNtxHwCfg->m_val.bKeyPad||14==gptNtxHwCfg->m_val.bKeyPad||
+		17==gptNtxHwCfg->m_val.bKeyPad||18==gptNtxHwCfg->m_val.bKeyPad||
+		22==gptNtxHwCfg->m_val.bKeyPad) 
+	{
+		// Keypad is NO_Key || RETURN+HOME+MENU || HOMEPAD || HOME_Key || LEFT+RIGHT+HOME+MENU
+		gptNtxGpioKey_FL = 0;
+	}
+
+
+	if(0!=gptNtxHwCfg->m_val.bHallSensor) {
+
+		gptNtxGpioSW_HallSensor= (NTX_GPIO *)&gt_ntx_gpio_hallsensor_key;
+#if defined(_MX6SLL_) //[
+		if(NTXHWCFG_TST_FLAG(gptNtxHwCfg->m_val.bPCB_Flags2,0)) {
+			// EMMC@SD1(I/O@SD4).
+			gptNtxGpioSW_HallSensor= (NTX_GPIO *)&gt_ntx_gpio_hallsensor_key2;
+		}
+#endif //](_MX6SLL_)
+	}
+	else {
+		//printf("no hallsensor !\n");
+		gptNtxGpioSW_HallSensor=0;
+	}
+
+#if 0
+	if(17==gptNtxHwCfg->m_val.bKeyPad) 
+	{
+		// keypad is 'RETURN+HOME+MENU'
+		gptNtxGpioKey_Menu = (NTX_GPIO *)&gt_ntx_gpio_menu_key;
+		gptNtxGpioKey_Return = (NTX_GPIO *)&gt_ntx_gpio_return_key ;
+	}
+
+	if(22==gptNtxHwCfg->m_val.bKeyPad) 
+	{
+		// keypad is 'LEFT+RIGHT+HOME+MENU'
+		gptNtxGpioKey_Menu = (NTX_GPIO *)&gt_ntx_gpio_menu_key_gp3_25;
+		gptNtxGpioKey_Left = (NTX_GPIO *)&gt_ntx_gpio_left_key;
+		gptNtxGpioKey_Right = (NTX_GPIO *)&gt_ntx_gpio_right_key;
+	}
+#endif
+
+
+	gpt_ntx_gpio_LED_G=(NTX_GPIO *)&gt_ntx_gpio_LED_G;
+	gpt_ntx_gpio_LED_R=(NTX_GPIO *)&gt_ntx_gpio_LED_R;
+	gpt_ntx_gpio_LED_B=(NTX_GPIO *)&gt_ntx_gpio_LED_B;
+	#if defined(_MX6SLL_)
+	// assigns Green LED .
+	if (NTXHWCFG_TST_FLAG(gptNtxHwCfg->m_val.bPCB_Flags2,0)) {
+		gpt_ntx_gpio_LED_R=(NTX_GPIO *)&gt_ntx_gpio_LED_R2;
+		gpt_ntx_gpio_LED_G=(NTX_GPIO *)&gt_ntx_gpio_LED_G2;
+		gpt_ntx_gpio_LED_B=(NTX_GPIO *)&gt_ntx_gpio_LED_B2;
+	}
+	#endif
+
+	// assigns WIFI 3V3 .
+	gpt_ntx_gpio_WIFI_3V3_ON = (NTX_GPIO *)&gt_ntx_gpio_WIFI_3V3_ON;
+
+
+	gpt_ntx_gpio_CT_RST = (NTX_GPIO *)&gt_ntx_gpio_TPRST;
+	#if defined(_MX6SLL_)//[
+	if (NTXHWCFG_TST_FLAG(gptNtxHwCfg->m_val.bPCB_Flags2,0)) {
+		gpt_ntx_gpio_CT_RST = (NTX_GPIO *)&gt_ntx_gpio_TPRST2;
+	}
+	#endif
+
+	// assigns Touch RST .
+	if(4==gptNtxHwCfg->m_val.bTouchType) {
+		// IR touch type ...
+		gpt_ntx_gpio_TP_RST = gpt_ntx_gpio_IR_RST;
+	}
+	else if (3==gptNtxHwCfg->m_val.bTouchType) {
+		// C touch type ...
+		gpt_ntx_gpio_TP_RST = gpt_ntx_gpio_CT_RST;
+	}
+
+
+	gpt_ntx_gpio_EP_3V3_ON = (NTX_GPIO *)&gt_ntx_gpio_EPDPMIC_VIN ;
+	gpt_ntx_gpio_EP_VCOM_ON = (NTX_GPIO *)&gt_ntx_gpio_EPDPMIC_VCOM ;
+
+	//gpt_ntx_gpio_FLPWR = ;
+	//gpt_ntx_gpio_FP9928_RAIL_ON	= ;
+	
+#ifdef PMIC_RC5T619 //[
+	// Ricoh PMIC IO assign ...
+#if defined(_MX6ULL_) //[
+	RC5T619_I2C_Chn_set(3);
+#endif //] _MX6ULL_
+
+#endif //]PMIC_RC5T619
+
+}
+
+
+/**********************************************
+ *
+ * ntx_hw_early_init() 
+ *
+ * the initial actions in early time .
+ * 
+ **********************************************/
+void ntx_hw_early_init(void)
+{
+	//EPDPMIC_power_on(0);
+	
+	printf("%s() %d\n",__FUNCTION__, is_boot_from_usb());
+	//udc_init();
+	if(!gptNtxHwCfg) {
+		if (is_boot_from_usb()) {
+			gptNtxHwCfg = (volatile NTX_HWCONFIG *) 0x83808000;
+			return;
+		}
+		_load_isd_hwconfig();
+	}
+
+	ntx_io_assign();
+
+
+	RC5T619_enable_watchdog(0);
+	if(gpt_ntx_gpio_FLPWR) {
+		ntx_gpio_init(gpt_ntx_gpio_FLPWR);
+	}
+
+
+	if(gpt_ntx_gpio_TP_RST) {
+		ntx_gpio_init(gpt_ntx_gpio_TP_RST);
+	}
+
+	EPDPMIC_power_on(0);
+
+	if(11==gptNtxHwCfg->m_val.bDisplayCtrl) {
+		_init_tps65185_power(0,0);
+	}
+
+}
+
+static void ntx_keys_setup(void)
+{
+
+	ntx_gpio_keysA[gi_ntx_gpio_keys] = gptNtxGpioKey_Power;
+	gi_ntx_gpio_keys++;
+	if(12==gptNtxHwCfg->m_val.bKeyPad) {
+		// NO_Key .
+	}
+	else 
+	{
+
+
+		if(gptNtxGpioKey_Home && 
+				(13==gptNtxHwCfg->m_val.bKeyPad||
+				 14==gptNtxHwCfg->m_val.bKeyPad||
+				 16==gptNtxHwCfg->m_val.bKeyPad||
+				 17==gptNtxHwCfg->m_val.bKeyPad||
+				 18==gptNtxHwCfg->m_val.bKeyPad)) 
+		{
+			// FL+HOME/HOME_Key/FL+HOMEPAD/RETURN+HOME+MENU/HOMEPAD
+			ntx_gpio_keysA[gi_ntx_gpio_keys] = gptNtxGpioKey_Home;
+			gi_ntx_gpio_keys++;
+		}
+
+		if(gptNtxGpioKey_FL && 
+			(11==gptNtxHwCfg->m_val.bKeyPad||
+			13==gptNtxHwCfg->m_val.bKeyPad||
+			16==gptNtxHwCfg->m_val.bKeyPad)) 
+		{
+			// FL_Key/FL+HOME/FL+HOMEPAD
+			ntx_gpio_keysA[gi_ntx_gpio_keys] = gptNtxGpioKey_FL;
+			gi_ntx_gpio_keys++;
+		}
+
+		if(gptNtxGpioSW_HallSensor && 0!=gptNtxHwCfg->m_val.bHallSensor)
+		{
+			ntx_gpio_keysA[gi_ntx_gpio_keys] = gptNtxGpioSW_HallSensor;
+			gi_ntx_gpio_keys++;
+		}
+
+		if(gptNtxGpioKey_Menu) 
+		{
+			// RETURN+HOME+MENU
+			ntx_gpio_keysA[gi_ntx_gpio_keys] = gptNtxGpioKey_Menu;
+			gi_ntx_gpio_keys++;
+		}
+
+		if(gptNtxGpioKey_Return) 
+		{
+			// RETURN+HOME+MENU
+			ntx_gpio_keysA[gi_ntx_gpio_keys] = gptNtxGpioKey_Return;
+			gi_ntx_gpio_keys++;
+		}
+
+		if(gptNtxGpioKey_Left) 
+		{
+			// 
+			ntx_gpio_keysA[gi_ntx_gpio_keys] = gptNtxGpioKey_Left;
+			gi_ntx_gpio_keys++;
+		}
+
+		if(gptNtxGpioKey_Right) 
+		{
+			// 
+			ntx_gpio_keysA[gi_ntx_gpio_keys] = gptNtxGpioKey_Right;
+			gi_ntx_gpio_keys++;
+		}
+		
+	}
+
+
+	if(gi_ntx_gpio_keys>=NTX_GPIO_KEYS) {
+		printf("\n\n\n%s(%d) memory overwrite !!!\n\n\n",__FILE__,__LINE__);
+		udelay(1000*1000);
+	}
+}
+
+void ntx_hw_late_init(void) 
+{
+	//NTX_GPIO *pt_gpio;
+
+	printf("%s()\n",__FUNCTION__);
+	if(!gptNtxHwCfg) {
+		_load_isd_hwconfig();
+	}
+
+	_load_ntx_sn();
+
+
+	ntx_parse_syspart_type();
+
+	EPDPMIC_power_on(1);
+	if(11==gptNtxHwCfg->m_val.bDisplayCtrl) {
+		_init_tps65185_power(1,0);
+	}
+
+	ntx_keys_setup();
+
+#if defined(_MX6Q_)
+#else
+
+
+	if(9==gptNtxHwCfg->m_val.bCustomer) {
+		_led_R(0);
+		_led_G(0);
+		_led_B(1);
+	}
+	else {
+		_led_R(0);
+		_led_G(1);
+		_led_B(0);
+	}
+
+  
+
+	_sd_cd_status();
+
+
+	gpt_ntx_gpio_USBID = 0;
+
+#if defined(_MX6SL_) || defined(_MX6SLL_) || defined(_MX6ULL_)//[
+	if(gpt_ntx_gpio_LED_HOME) {
+		ntx_gpio_init(gpt_ntx_gpio_LED_HOME);
+	}
+
+	// setup I2C chanel .
+	if( (46==gptNtxHwCfg->m_val.bPCB && gptNtxHwCfg->m_val.bPCB_REV>=0x10) ||
+			48==gptNtxHwCfg->m_val.bPCB ||
+			50==gptNtxHwCfg->m_val.bPCB ||
+	 		51==gptNtxHwCfg->m_val.bPCB	||
+			55==gptNtxHwCfg->m_val.bPCB)
+	{
+		// >=E60Q9XA1 or =E60QAX | E60QFX | E60QHX |E70Q02 .
+		msp430_I2C_Chn_set(0); // MSP430 @ I2C1 .
+	}
+
+	if(3==gptNtxHwCfg->m_val.bUIConfig) {
+		// MFG mode .
+		RC5T619_set_charger_params(USB_CHARGER_CDP);
+	}
+	else {
+		if (49 == gptNtxHwCfg->m_val.bPCB) {	// run charger detect for E60QDx
+			RC5T619_write_reg(0xBA, 0x88);	// set CHGPON to 3.2V
+			RC5T619_write_reg(0xB4, 0x20);	// set USB_VCONTMASK
+
+			RC5T619_charger_redetect();
+			ntx_detect_usb_plugin (1);
+		}
+		else
+			RC5T619_set_charger_params(USB_CHARGER_SDP);
+	}
+
+#endif
+
+#endif
+}
+
diff --git a/board/freescale/mx6sll_kobo_clara_hd/ntx_hw.h b/board/freescale/mx6sll_kobo_clara_hd/ntx_hw.h
new file mode 100644
index 0000000000..f20665ec45
--- /dev/null
+++ b/board/freescale/mx6sll_kobo_clara_hd/ntx_hw.h
@@ -0,0 +1,59 @@
+#ifndef _NTX_HW_//[
+#define _NTX_HW_
+
+#define NTX_GPIO_KEYS		5
+extern NTX_GPIO * ntx_gpio_keysA[] ;
+extern NTX_GPIO *gptNtxGpioKey_Home,*gptNtxGpioKey_FL,*gptNtxGpioKey_Power;
+extern NTX_GPIO *gptNtxGpioKey_Menu,*gptNtxGpioKey_Return,*gptNtxGpioSW_HallSensor;
+extern int gi_ntx_gpio_keys;
+
+
+void _led_R(int iIsTrunOn);
+void _led_G(int iIsTrunOn);
+void _led_B(int iIsTrunOn);
+
+
+int _get_boot_sd_number(void);
+int _get_pcba_id (void);
+int _power_key_status (void);
+int _sd_cd_status (void);
+
+int ntx_gpio_key_is_fastboot_down(void);
+int ntx_gpio_key_is_home_down(void);
+int ntx_gpio_key_is_fl_down(void);
+int ntx_gpio_key_is_menu_down(void);
+int init_pwr_i2c_function(int iSetAsFunc);
+
+void EPDPMIC_power_on(int iIsPowerON);
+void EPDPMIC_vcom_onoff(int iIsON);
+void FP9928_rail_power_onoff(int iIsON);
+void tps65185_rail_power_onoff(int iIsON);
+void ntx_hw_late_init(void);
+void ntx_hw_early_init(void);
+
+int RC5T619_read_reg(unsigned char bRegAddr,unsigned char *O_pbRegVal);
+int RC5T619_write_reg(unsigned char bRegAddr,unsigned char bRegWrVal);
+int RC5T619_write_buffer(unsigned char bRegAddr,unsigned char *I_pbRegWrBuf,unsigned short I_wRegWrBufBytes);
+
+int msp430_I2C_Chn_set(unsigned int uiI2C_Chn);
+int msp430_read_buf(unsigned char bRegAddr,unsigned char *O_pbBuf,int I_iBufSize);
+int msp430_read_reg(unsigned char bRegAddr,unsigned char *O_pbRegVal);
+int msp430_write_buf(unsigned char bRegAddr,unsigned char *I_pbBuf,int I_iBufSize);
+int msp430_write_reg(unsigned char bRegAddr,unsigned char bRegVal);
+#define NTXHW_BOOTDEV_SD		0x2
+#define NTXHW_BOOTDEV_MMC		0x3
+#define NTXHW_BOOTDEV_UNKOWN		0xff
+unsigned char ntxhw_get_bootdevice_type(void);
+#endif //]_NTX_HW_
+
+#define USB_CHARGER_OTG			0x1000
+#define USB_CHARGER_SDP			0x0004
+#define USB_CHARGER_CDP			0x0002
+#define USB_CHARGER_DCP			0x0003
+#define USB_CHARGER_UNKOWN	0x0001
+int ntx_detect_usb_plugin(int iIsDetectChargerType);
+
+int ntxhw_USBID_detected(void);
+
+int _hallsensor_status (void);
+
diff --git a/board/freescale/mx6sll_kobo_clara_hd/ntx_hwconfig.h b/board/freescale/mx6sll_kobo_clara_hd/ntx_hwconfig.h
new file mode 100644
index 0000000000..db8ce3ec3c
--- /dev/null
+++ b/board/freescale/mx6sll_kobo_clara_hd/ntx_hwconfig.h
@@ -0,0 +1,364 @@
+#ifndef __ntx_hwconfig_h//[
+#define __ntx_hwconfig_h
+
+
+#ifdef __cplusplus //[
+extern "C" {
+#endif //] __cplusplus
+
+
+#define NTX_HWCFG_MAGIC				"HW CONFIG "
+#define NTX_HWCFG_VER					"v2.8"
+
+#define SYSHWCONFIG_SEEKSIZE	(1024*512)
+
+
+typedef struct tagNTXHWCFG_HDR {
+	char cMagicNameA[10];// should be "HW CONFIG "
+	char cVersionNameA[5];// should be "vx.x"
+	unsigned char bHWConfigSize;// v0.1=19 .
+} NTXHWCFG_HDR ;
+
+typedef struct tagNTXHWCFG_VAL { 
+	unsigned char bPCB;// 
+	unsigned char bKeyPad;// key pad type .
+	unsigned char bAudioCodec;//
+	unsigned char bAudioAmp;//
+	unsigned char bWifi;//
+	unsigned char bBT;//
+	unsigned char bMobile;//
+	unsigned char bTouchCtrl;//touch controller .
+	unsigned char bTouchType;//touch type .
+	unsigned char bDisplayCtrl;//
+	unsigned char bDisplayPanel;//
+	unsigned char bRSensor;//
+	unsigned char bMicroP;//
+	unsigned char bCustomer;//
+	unsigned char bBattery;//
+	unsigned char bLed;//
+	unsigned char bRamSize;// ram size 
+	unsigned char bIFlash; // internal flash type .
+	unsigned char bExternalMem;// external sd type .
+	unsigned char bRootFsType;// root fs type .
+	unsigned char bSysPartType;// system partition type .
+	unsigned char bProgressXHiByte; // Progress bar position while boot ,X
+	unsigned char bProgressXLoByte; //                                  ,X
+	unsigned char bProgressYHiByte; // 							,Y
+	unsigned char bProgressYLoByte; // 							,Y
+	unsigned char bProgressCnts;		// 							Cnt .
+	unsigned char bContentType; // Book content type .
+	unsigned char bCPU; //main cpu type .
+	unsigned char bUIStyle; // UI style .
+	unsigned char bRamType; // Ram Type .
+	unsigned char bUIConfig; // UI config .
+	unsigned char bDisplayResolution;// Display resolution .
+	unsigned char bFrontLight;// Front Light .
+	unsigned char bCPUFreq;// CPU frequency  .
+	unsigned char bHallSensor;// Hall Sensor Controller  .
+	unsigned char bDisplayBusWidth;// Display BUS width/bits .
+	unsigned char bFrontLight_Flags;// Front Light Flags .
+	unsigned char bPCB_Flags;// PCB Flags .
+	unsigned char bFrontLight_LED_Driver;// Front Light LED driver .
+	unsigned char bVCOM_10mV_HiByte;// VCOM mV High byte .
+	unsigned char bVCOM_10mV_LoByte;// VCOM mV Low byte .
+	unsigned char bPCB_REV;// PCB revision .
+	unsigned char bPCB_LVL;// PCB develop level .
+	unsigned char bHOME_LED_PWM;// HOME LED PWM source .
+	unsigned char bPMIC;// System PMIC .
+	unsigned char bFL_PWM;// FrontLight PWM source
+	unsigned char bRTC;// System RTC source
+	unsigned char bBootOpt;// Boot option
+	unsigned char bTouch2Ctrl;//touch controller .
+	unsigned char bTouch2Type;//touch type .
+	unsigned char bGPS;//GPS module .
+	unsigned char bFM;//FM module .
+	unsigned char bRSensor2;//
+	unsigned char bLightSensor;//
+	unsigned char bTPFWIDByte0;// TP firmware ID byte0 .
+	unsigned char bTPFWIDByte1;// TP firmware ID byte1 .
+	unsigned char bTPFWIDByte2;// TP firmware ID byte2 .
+	unsigned char bTPFWIDByte3;// TP firmware ID byte3 .
+	unsigned char bTPFWIDByte4;// TP firmware ID byte4 .
+	unsigned char bTPFWIDByte5;// TP firmware ID byte5 .
+	unsigned char bTPFWIDByte6;// TP firmware ID byte6 .
+	unsigned char bTPFWIDByte7;// TP firmware ID byte7 .
+	unsigned char bGPU; //GPU .
+	unsigned char bPCB_Flags2;// PCB Flags2 .
+	unsigned char bEPD_Flags;// EPD Flags .
+} NTXHWCFG_VAL ;
+
+typedef struct tagNTX_HWCONFG{
+	NTXHWCFG_HDR m_hdr;
+	NTXHWCFG_VAL m_val;
+	unsigned char m_bReserveA[110-sizeof(NTXHWCFG_HDR)-sizeof(NTXHWCFG_VAL)];
+} NTX_HWCONFIG;
+
+// Filed types ...
+#define FIELD_TYPE_IDXSTR	0
+#define FIELD_TYPE_BYTE		1
+#define FIELD_TYPE_FLAGS		2
+
+// Filed Flags ...
+#define FIELD_FLAGS_HW		0x0000
+#define FIELD_FLAGS_SW		0x0001
+
+
+typedef struct tagHwConfigField{
+	char *szVersion;
+	char *szFieldName ;
+	int iFieldValueCnt;
+	char **szFieldValueA ;
+	unsigned short wFieldType;
+	unsigned short wFieldFlags;
+} HwConfigField ;
+
+
+extern const char * gszPCBA[];
+extern const char * gszKeyPadA[];
+extern const char * gszAudioCodecA[];//
+extern const char * gszAudioAmpA[];//
+extern const char * gszWifiA[];//
+extern const char * gszBTA[];//
+extern const char * gszMobileA[];//
+extern const char * gszTouchCtrlA[];//touch controller .
+extern const char * gszTouchTypeA[];//
+extern const char * gszDisplayCtrlA[];
+extern const char * gszDisplayPanelA[];
+extern const char * gszRSensorA[];//
+extern const char * gszMicroPA[];//
+extern const char * gszCustomerA[];//
+extern const char * gszBatteryA[];//
+extern const char * gszLedA[];//
+extern const char * gszRamSizeA[];// ram size 
+extern const char * gszIFlashA[]; // internal flash type .
+extern const char * gszExternalMemA[];// external sd type .
+extern const char * gszRootFsTypeA[];// root fs type .
+extern const char * gszSysPartTypeA[];// system partition type .
+extern const char * gszCPUA[];// cpu type .
+extern const char * gszUIStyleA[];// UI Style (netronix UI/customer UI) .
+extern const char * gszRAMTypeA[];// Ram Type .
+extern const char * gszUIConfigA[];// UI Config .
+extern const char * gszDisplayResolutionA[];// Display Resolution .
+extern const char * gszFrontLightA[];// Front Light .
+extern const char * gszCPUFreqA[];// CPU frequency .
+extern const char * gszHallSensorA[];// Hall Sensor .
+extern const char * gszDisplayBusWidthA[];// Display BUS width .
+extern const char * gszFrontLightLEDrvA[];//Front Light LED driver IC .
+extern const char * gszPCB_LVLA[];//PCB develop level .
+extern const char * gszHOME_LED_PWMA[];// HOME LED PWM source .
+extern const char * gszPMICA[];// System PMIC .
+extern const char * gszFL_PWMA[];// FrontLight PWM source
+extern const char * gszRTCA[];// System RTC source .
+extern const char * gszFMA[];// FM controller .
+extern const char * gszGPSA[];// GPS controller .
+extern const char * gszLightSensorA[];// Light sensor .
+extern const char * gszGPUA[];// GPU .
+
+
+// the return value of hw config apis . >=0 is success ,others is fail .
+#define HWCFG_RET_SUCCESS  (0)
+#define HWCFG_RET_PTRERR (-1) // parameter include error pointer
+#define HWCFG_RET_HDRNOTMATCH (-2) // hwconfig header magic not match .
+#define HWCFG_RET_CFGVERTOOOLD (-3) // hwconfig tool version newer than config struct value (you should update the config file)...
+#define HWCFG_RET_CFGVERTOONEW (-4) // hwconfig tool version older than config struct value (you should update the config tool)...
+#define HWCFG_RET_CFGVERNOTMATCH (-5) // hwconfig tool version and config struct version not match ...
+#define HWCFG_RET_CFGVERFMTERR (-6) // config version format error (must be vX.X) ...
+#define HWCFG_RET_NOTHISFIELDIDX (-7) // field index error .
+#define HWCFG_RET_NOTHISFIELDNAME (-8) // field name error .
+#define HWCFG_RET_FILEOPENFAIL (-9) // file open fail .
+#define HWCFG_RET_FILEWRITEFAIL (-10) // file open fail .
+#define HWCFG_RET_FIELDTYPEERROR (-11) // field type error .
+#define HWCFG_RET_FIELDTRDONLY (-12) // field read only .
+#define HWCFG_RET_CFGVALFLAGIDXERROR (-13) // index of config's flags not avalible  .
+#define HWCFG_RET_CFGVALFLAGNAMEERROR (-14) // flag name of config not avalible  .
+#define HWCFG_RET_FIELDIDXOUTRANGE (-15) // field index out of range  .
+
+
+// ntx hardward config field index list ...
+#define HWCFG_FLDIDX_PCB								0
+#define HWCFG_FLDIDX_KeyPad							1
+#define HWCFG_FLDIDX_AudioCodec					2
+#define HWCFG_FLDIDX_AudioAmp						3
+#define HWCFG_FLDIDX_Wifi								4
+#define HWCFG_FLDIDX_BT									5
+#define HWCFG_FLDIDX_Mobile							6
+#define HWCFG_FLDIDX_TouchCtrl					7
+#define HWCFG_FLDIDX_TouchType					8
+#define HWCFG_FLDIDX_DisplayCtrl				9
+#define HWCFG_FLDIDX_DisplayPanel				10
+#define HWCFG_FLDIDX_RSensor						11
+#define HWCFG_FLDIDX_MicroP							12
+#define HWCFG_FLDIDX_Customer						13
+#define HWCFG_FLDIDX_Battery						14
+#define HWCFG_FLDIDX_Led								15
+#define HWCFG_FLDIDX_RamSize						16
+#define HWCFG_FLDIDX_IFlash							17
+#define HWCFG_FLDIDX_ExternalMem				18
+#define HWCFG_FLDIDX_RootFsType					19 // v0.2
+#define HWCFG_FLDIDX_SysPartType				20 // v0.3
+
+#define HWCFG_FLDIDX_ProgressXHiByte			21 // v0.4
+#define HWCFG_FLDIDX_ProgressXLoByte			22 // v0.4
+#define HWCFG_FLDIDX_ProgressYHiByte			23 // v0.4
+#define HWCFG_FLDIDX_ProgressYLoByte			24 // v0.4
+#define HWCFG_FLDIDX_ProgressCnts				25 // v0.4
+
+#define HWCFG_FLDIDX_ContentType				26 // v0.5
+#define HWCFG_FLDIDX_CPU						27 // v0.6
+#define HWCFG_FLDIDX_UISTYLE					28 // v0.7
+
+#define HWCFG_FLDIDX_RAMTYPE					29 // v0.8
+#define HWCFG_FLDIDX_UICONFIG					30 // v0.9
+#define HWCFG_FLDIDX_DISPLAYRESOLUTION			31 // v1.0
+#define HWCFG_FLDIDX_FRONTLIGHT			32 // v1.1
+#define HWCFG_FLDIDX_CPUFREQ			33 // v1.2
+#define HWCFG_FLDIDX_HALLSENSOR			34 // v1.3
+#define HWCFG_FLDIDX_DisplayBusWidth			35 // v1.4
+#define HWCFG_FLDIDX_FrontLight_Flags			36 // v1.5
+#define HWCFG_FLDIDX_PCB_Flags			37 // v1.6
+#define HWCFG_FLDIDX_FrontLight_LEDrv			38 // v1.7
+#define HWCFG_FLDIDX_VCOM_10mV_HiByte			39 // v1.8
+#define HWCFG_FLDIDX_VCOM_10mV_LoByte			40 // v1.8
+#define HWCFG_FLDIDX_PCB_REV			41 // v1.9
+#define HWCFG_FLDIDX_PCB_LVL			42 // v2.0
+#define HWCFG_FLDIDX_HOME_PWM			43 // v2.1
+#define HWCFG_FLDIDX_PMIC					44 // v2.1
+#define HWCFG_FLDIDX_FL_PWM				45// v2.1
+#define HWCFG_FLDIDX_RTC				46// v2.1
+#define HWCFG_FLDIDX_BOOTOPT				47// v2.2
+#define HWCFG_FLDIDX_Touch2Ctrl					48 // v2.3
+#define HWCFG_FLDIDX_Touch2Type					49 // v2.3
+#define HWCFG_FLDIDX_GPS					50 // v2.4
+#define HWCFG_FLDIDX_FM					51 // v2.4
+#define HWCFG_FLDIDX_RSensor2					52 // v2.5
+#define HWCFG_FLDIDX_LightSensor					53 // v2.5
+#define HWCFG_FLDIDX_TPFWIDByte0					54 // v2.6
+#define HWCFG_FLDIDX_TPFWIDByte1					55 // v2.6
+#define HWCFG_FLDIDX_TPFWIDByte2					56 // v2.6
+#define HWCFG_FLDIDX_TPFWIDByte3					57 // v2.6
+#define HWCFG_FLDIDX_TPFWIDByte4					58 // v2.6
+#define HWCFG_FLDIDX_TPFWIDByte5					59 // v2.6
+#define HWCFG_FLDIDX_TPFWIDByte6					60 // v2.6
+#define HWCFG_FLDIDX_TPFWIDByte7					61 // v2.6
+#define HWCFG_FLDIDX_GPU									62 // v2.7
+#define HWCFG_FLDIDX_PCB_Flags2						63 // v2.8
+#define HWCFG_FLDIDX_EPD_Flags						64 // v2.8
+
+
+
+
+NTX_HWCONFIG *NtxHwCfg_Load(const char *szFileName,int iIsSeek);
+NTX_HWCONFIG *NtxHwCfg_LoadEx(const char *szFileName,unsigned long dwIsSeek);
+int NtxHwCfg_Save(const char *szFileName,int iIsSeek);
+NTX_HWCONFIG *NtxHwCfg_Get(void);
+
+
+int NtxHwCfg_GetTotalFlds(void);//o@X.
+int NtxHwCfg_GetFldVal(int iFldIdx,HwConfigField *O_ptHwCfgFld);//ovwq.
+unsigned char NtxHwCfg_FldStrVal2Val(int iFldIdx,char *szFldStrVal);//r.
+const char *NtxHwCfg_FldVal2StrVal(int iFldIdx,unsigned char bFldVal);//r.
+int NtxHwCfg_FldName2Idx(const char *szFldName);
+int NtxHwCfg_is_HW_Fld(int iFldIdx);
+int NtxHwCfg_is_SW_Fld(int iFldIdx);
+
+int NtxHwCfg_ChkCfgHeaderEx2(NTX_HWCONFIG *pHdr,int iIsIgnoreVersion,const char *pcCompareHdrVersionA);
+int NtxHwCfg_ChkCfgHeaderEx(NTX_HWCONFIG *pHdr,int iIsIgnoreVersion);
+int NtxHwCfg_ChkCfgHeader(NTX_HWCONFIG *pHdr);//dAY,.
+int NtxHwCfg_CfgUpgrade(NTX_HWCONFIG *pHdr);//u@P.
+
+int NtxHwCfg_GetCfgTotalFlds(NTX_HWCONFIG *pHdr);//oA`@X.
+
+int NtxHwCfg_GetCfgFldVal(NTX_HWCONFIG *pHdr,int iFieldIdx);
+const char *NtxHwCfg_GetCfgFldStrVal(NTX_HWCONFIG *pHdr,int iFieldIdx);
+int NtxHwCfg_GetCfgFldFlagVal(NTX_HWCONFIG *pHdr,int iFieldIdx,int iFlagsIdx);
+int NtxHwCfg_GetCfgFldFlagValByName(NTX_HWCONFIG *pHdr,int iFieldIdx,const char *pszFlagName);
+
+int NtxHwCfg_SetCfgFldVal(NTX_HWCONFIG *pHdr,int iFieldIdx,int iFieldVal);
+int NtxHwCfg_SetCfgFldValEx(NTX_HWCONFIG *pHdr,int iFieldIdx,int iFieldVal,int iHW_WR_Protect);
+int NtxHwCfg_SetCfgFldStrVal(NTX_HWCONFIG *pHdr,int iFieldIdx,const char *pszFieldStrVal);
+int NtxHwCfg_SetCfgFldStrValEx(NTX_HWCONFIG *pHdr,int iFieldIdx,const char *pszFieldStrVal,int iHW_WR_Protect);
+int NtxHwCfg_SetCfgFldFlagValByName(NTX_HWCONFIG *pHdr,int iFieldIdx,const char *pszFlagName,int iIsTurnON,int iHW_WR_Protect);
+
+int NtxHwCfg_SetCfgFldValDefs(NTX_HWCONFIG *I_pHdr,int I_iFieldIdx,
+		const char **I_pszFieldValDefs,int I_iTotalVals);
+
+int NtxHwCfg_CompareHdrFldVersion(NTX_HWCONFIG *pHdr,int iFieldIdx);
+
+// get field value name in hardware config struct ...
+#define NTXHWCFG_GET_FLDCFGNAME(pHdr,_fld)		gsz##_fld##A[pHdr->m_val.b##_fld]
+// get print format by field in hardware config struct ...
+#define NTXHWCFG_GET_FLDCFGPRTFMT(pHdr,_fld)	"%s : %s",#_fld,NTXHWCFG_GET_FLDCFGNAME(pHdr,_fld)
+
+#define NTXHWCFG_TST_FLAG(_flags,_bit_n)	((_flags)&(0x01<<(_bit_n)))?1:0
+
+
+#define NTXHWCFG_CHK_HDR(_pHdr,_iIsIgnoreVersion,_pcCompareHdrVersionA) \
+({\
+	int _iRet ;\
+	const char szNtxHwCfgMagic[]=NTX_HWCFG_MAGIC;\
+	char *_pcHdrVer=(_pcCompareHdrVersionA);\
+	\
+	if(!(_pHdr)) {\
+		_iRet = HWCFG_RET_PTRERR;\
+	}\
+	else {\
+		if(szNtxHwCfgMagic[0]==(_pHdr)->m_hdr.cMagicNameA[0] &&\
+			szNtxHwCfgMagic[1]==(_pHdr)->m_hdr.cMagicNameA[1] &&\
+			szNtxHwCfgMagic[2]==(_pHdr)->m_hdr.cMagicNameA[2] &&\
+			szNtxHwCfgMagic[3]==(_pHdr)->m_hdr.cMagicNameA[3] &&\
+			szNtxHwCfgMagic[4]==(_pHdr)->m_hdr.cMagicNameA[4] &&\
+			szNtxHwCfgMagic[5]==(_pHdr)->m_hdr.cMagicNameA[5] &&\
+			szNtxHwCfgMagic[6]==(_pHdr)->m_hdr.cMagicNameA[6] &&\
+			szNtxHwCfgMagic[7]==(_pHdr)->m_hdr.cMagicNameA[7] &&\
+			szNtxHwCfgMagic[8]==(_pHdr)->m_hdr.cMagicNameA[8] &&\
+			szNtxHwCfgMagic[9]==(_pHdr)->m_hdr.cMagicNameA[9] )\
+		{\
+			if((_iIsIgnoreVersion)) {\
+				_iRet = HWCFG_RET_SUCCESS;\
+			}\
+			else if((_pcHdrVer)) {\
+				if(_pcHdrVer[0]==(_pHdr)->m_hdr.cVersionNameA[0] &&\
+					_pcHdrVer[2]==(_pHdr)->m_hdr.cVersionNameA[2] &&\
+					_pcHdrVer[4]==(_pHdr)->m_hdr.cVersionNameA[4] ) \
+				{\
+					if((_pHdr)->m_hdr.cVersionNameA[1]>_pcHdrVer[1]) {\
+						_iRet = HWCFG_RET_CFGVERTOONEW;\
+					}\
+					else if((_pHdr)->m_hdr.cVersionNameA[1]<_pcHdrVer[1]) {\
+						_iRet = HWCFG_RET_CFGVERTOOOLD;\
+					}\
+					else {\
+						if((_pHdr)->m_hdr.cVersionNameA[3]>_pcHdrVer[3]) {\
+							_iRet = HWCFG_RET_CFGVERTOONEW;\
+						}\
+						else if((_pHdr)->m_hdr.cVersionNameA[3]<_pcHdrVer[3]) {\
+							_iRet = HWCFG_RET_CFGVERTOOOLD;\
+						}\
+						else {\
+							_iRet = HWCFG_RET_SUCCESS;\
+						}\
+					}\
+				}\
+				else {\
+					_iRet = HWCFG_RET_CFGVERFMTERR;\
+				}\
+			}\
+			else {\
+				_iRet = HWCFG_RET_PTRERR;\
+			}\
+		}\
+		else {\
+			_iRet = HWCFG_RET_HDRNOTMATCH;\
+		}\
+	}\
+	_iRet;\
+})
+
+
+
+#ifdef __cplusplus //[
+}
+#endif //] __cplusplus
+
+#endif //] __ntx_hwconfig_h
+
diff --git a/board/freescale/mx6sll_kobo_clara_hd/ntx_pads.h b/board/freescale/mx6sll_kobo_clara_hd/ntx_pads.h
new file mode 100644
index 0000000000..5ef92b592c
--- /dev/null
+++ b/board/freescale/mx6sll_kobo_clara_hd/ntx_pads.h
@@ -0,0 +1,140 @@
+#ifndef NTX_PADS_H //[
+#define NTX_PADS_H
+
+
+#if defined( _MX7D_ )//[
+
+	#define UART_PAD_CTRL  (PAD_CTL_DSE_3P3V_49OHM | \
+		PAD_CTL_PUS_PU100KOHM | PAD_CTL_HYS)
+
+	#define USDHC_PAD_CTRL (PAD_CTL_DSE_3P3V_32OHM | PAD_CTL_SRE_SLOW | \
+		PAD_CTL_HYS | PAD_CTL_PUE | PAD_CTL_PUS_PU47KOHM)
+
+	#define ENET_PAD_CTRL  (PAD_CTL_PUS_PU100KOHM | PAD_CTL_DSE_3P3V_98OHM)
+	#define ENET_PAD_CTRL_MII  (PAD_CTL_PUS_PU100KOHM | PAD_CTL_DSE_3P3V_98OHM)
+
+	#define ENET_RX_PAD_CTRL  (PAD_CTL_PUS_PU100KOHM | PAD_CTL_DSE_3P3V_98OHM)
+
+	#define I2C_PAD_CTRL    (PAD_CTL_DSE_3P3V_32OHM | PAD_CTL_SRE_SLOW | \
+		PAD_CTL_HYS | PAD_CTL_PUE | PAD_CTL_PUS_PU100KOHM)
+
+	#define LCD_PAD_CTRL    (PAD_CTL_HYS | PAD_CTL_PUS_PU100KOHM | \
+		PAD_CTL_DSE_3P3V_49OHM)
+
+	#define QSPI_PAD_CTRL	\
+		(PAD_CTL_DSE_3P3V_49OHM | PAD_CTL_PUE | PAD_CTL_PUS_PU47KOHM)
+
+	#define SPI_PAD_CTRL (PAD_CTL_DSE_3P3V_49OHM | PAD_CTL_SRE_SLOW | PAD_CTL_HYS)
+
+	#define EPDC_PAD_CTRL	0x0
+
+#elif defined( _MX6ULL_ )//[
+
+	#define EPDC_PAD_CTRL	0x0
+
+	#define UART_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |		\
+		PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+		PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+	#define USDHC_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+		PAD_CTL_PUS_22K_UP  | PAD_CTL_SPEED_LOW |		\
+		PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+	#define USDHC_DAT3_CD_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |	\
+		PAD_CTL_PUS_100K_DOWN  | PAD_CTL_SPEED_LOW |		\
+		PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+	#define I2C_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE |            \
+		PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |               \
+		PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
+		PAD_CTL_ODE)
+
+	#define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP | PAD_CTL_PUE |     \
+		PAD_CTL_SPEED_HIGH   |                                  \
+		PAD_CTL_DSE_48ohm   | PAD_CTL_SRE_FAST)
+
+	#define LCD_PAD_CTRL    (PAD_CTL_HYS | PAD_CTL_PUS_100K_UP | PAD_CTL_PUE | \
+		PAD_CTL_PKE | PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm)
+
+	#define MDIO_PAD_CTRL  (PAD_CTL_PUS_100K_UP | PAD_CTL_PUE |     \
+		PAD_CTL_DSE_48ohm   | PAD_CTL_SRE_FAST | PAD_CTL_ODE)
+
+	#define ENET_CLK_PAD_CTRL  (PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST)
+
+	#define ENET_RX_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |          \
+		PAD_CTL_SPEED_HIGH   | PAD_CTL_SRE_FAST)
+	
+	#define GPMI_PAD_CTRL0 (PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_100K_UP)
+	#define GPMI_PAD_CTRL1 (PAD_CTL_DSE_40ohm | PAD_CTL_SPEED_MED | \
+			PAD_CTL_SRE_FAST)
+	#define GPMI_PAD_CTRL2 (GPMI_PAD_CTRL0 | GPMI_PAD_CTRL1)
+
+	#define WEIM_NOR_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE | \
+		PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED | \
+		PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST)
+
+	#define SPI_PAD_CTRL (PAD_CTL_HYS |				\
+		PAD_CTL_SPEED_MED |		\
+		PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+	#define OTG_ID_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+		PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |		\
+		PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+
+	#define INPUT_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE |		\
+		PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+		PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#elif defined( _MX6SLL_ )//[
+	#define UART_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |		\
+		PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+		PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+	#define USDHC_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+		PAD_CTL_PUS_22K_UP  | PAD_CTL_SPEED_LOW |		\
+		PAD_CTL_DSE_34ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+	#define USDHC_PAD_CTRL_WP (PAD_CTL_PKE | PAD_CTL_PUE |		\
+		PAD_CTL_PUS_100K_DOWN | PAD_CTL_SPEED_LOW |		\
+		PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+	#define I2C_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE |            \
+		PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |               \
+		PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
+		PAD_CTL_ODE)
+
+	#define LCD_PAD_CTRL    (PAD_CTL_HYS | PAD_CTL_PUS_100K_UP | PAD_CTL_PUE | \
+		PAD_CTL_PKE | PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm)
+
+	#define OTG_ID_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+		PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |		\
+		PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+	#define SPI_PAD_CTRL (PAD_CTL_HYS | PAD_CTL_SPEED_MED | \
+		PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+	#define LCD_PAD_CTRL    (PAD_CTL_HYS | PAD_CTL_PUS_100K_UP | PAD_CTL_PUE | \
+		PAD_CTL_PKE | PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm)
+
+	#define EPDC_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_SPEED_MED |	\
+		PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+	#define INPUT_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE |            \
+		PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |               \
+		PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
+		PAD_CTL_ODE)
+
+#if 1
+	#define LED_PAD_CTRL    (NO_PAD_CTRL)
+#else
+	#define LED_PAD_CTRL    (PAD_CTL_HYS|PAD_CTL_PUS_47K_UP|PAD_CTL_PUE|PAD_CTL_PKE| \
+		PAD_CTL_SPEED_LOW |PAD_CTL_DSE_80ohm |PAD_CTL_SRE_FAST)
+#endif
+
+#endif //] _MX7D_
+
+
+#endif //]NTX_PADS_H
+
+
diff --git a/board/freescale/mx6sll_kobo_clara_hd/plugin.S b/board/freescale/mx6sll_kobo_clara_hd/plugin.S
new file mode 100644
index 0000000000..d85dcf0668
--- /dev/null
+++ b/board/freescale/mx6sll_kobo_clara_hd/plugin.S
@@ -0,0 +1,283 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+
+/* DDR script */
+.macro imx6sll_lpddr3_arm2_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x00080000
+	str r1, [r0, #0x550]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x534]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x2AC]
+	str r1, [r0, #0x548]
+	str r1, [r0, #0x52C]
+	ldr r1, =0x00020000
+	str r1, [r0, #0x530]
+	ldr r1, =0x00003030
+	str r1, [r0, #0x2B0]
+	str r1, [r0, #0x2B4]
+	str r1, [r0, #0x2B8]
+	str r1, [r0, #0x2BC]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x540]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x544]
+	str r1, [r0, #0x54C]
+	str r1, [r0, #0x554]
+	str r1, [r0, #0x558]
+	str r1, [r0, #0x294]
+	str r1, [r0, #0x298]
+	str r1, [r0, #0x29C]
+	str r1, [r0, #0x2A0]
+
+	ldr r1, =0x00082030
+	str r1, [r0, #0x2C0]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r1, =0x00008000
+	str r1, [r0, #0x1C]
+	ldr r1, =0xA1390003
+	str r1, [r0, #0x800]
+	ldr r1, =0x084700C7
+	str r1, [r0, #0x85C]
+	ldr r1, =0x00400000
+	str r1, [r0, #0x890]
+
+	ldr r1, =0x3C3A3C3C
+	str r1, [r0, #0x848]
+	ldr r1, =0x24293625
+	str r1, [r0, #0x850]
+
+	ldr r1, =0x33333333
+	str r1, [r0, #0x81C]
+	str r1, [r0, #0x820]
+	str r1, [r0, #0x824]
+	str r1, [r0, #0x828]
+
+	ldr r1, =0xf3333333
+	str r1, [r0, #0x82C]
+	str r1, [r0, #0x830]
+	str r1, [r0, #0x834]
+	str r1, [r0, #0x838]
+
+	ldr r1, =0x24922492
+	str r1, [r0, #0x8C0]
+	ldr r1, =0x00000800
+	str r1, [r0, #0x8B8]
+
+	ldr r1, =0x00020052
+	str r1, [r0, #0x004]
+	ldr r1, =0x53574333
+	str r1, [r0, #0x00C]
+	ldr r1, =0x00100B22
+	str r1, [r0, #0x010]
+	ldr r1, =0x00170778
+	str r1, [r0, #0x038]
+	ldr r1, =0x00C700DB
+	str r1, [r0, #0x014]
+	ldr r1, =0x00201718
+	str r1, [r0, #0x018]
+	ldr r1, =0x0F9F26D2
+	str r1, [r0, #0x02C]
+	ldr r1, =0x009F0E10
+	str r1, [r0, #0x030]
+	ldr r1, =0x0000005F
+	str r1, [r0, #0x040]
+	ldr r1, =0xC4190000
+	str r1, [r0, #0x000]
+	ldr r1, =0x20000000
+	str r1, [r0, #0x83C]
+
+	ldr r1, =0x00008050
+	str r1, [r0, #0x01C]
+	ldr r1, =0x00008058
+	str r1, [r0, #0x01C]
+	ldr r1, =0x003F8030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x003F8038
+	str r1, [r0, #0x01C]
+	ldr r1, =0xFF0A8030
+	str r1, [r0, #0x01C]
+	ldr r1, =0xFF0A8038
+	str r1, [r0, #0x01C]
+	ldr r1, =0x04028030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x04028038
+	str r1, [r0, #0x01C]
+	ldr r1, =0x83018030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x83018038
+	str r1, [r0, #0x01C]
+	ldr r1, =0x01038030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x01038038
+	str r1, [r0, #0x01C]
+
+	ldr r1, =0x00001800
+	str r1, [r0, #0x020]
+	ldr r1, =0xA1390003
+	str r1, [r0, #0x800]
+	ldr r1, =0x00020052
+	str r1, [r0, #0x004]
+	ldr r1, =0x00011006
+	str r1, [r0, #0x404]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x01C]
+.endm
+
+.macro imx6sll_lpddr2_arm2_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x00080000
+	str r1, [r0, #0x550]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x534]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x2AC]
+	str r1, [r0, #0x548]
+	str r1, [r0, #0x52C]
+	ldr r1, =0x00020000
+	str r1, [r0, #0x530]
+	ldr r1, =0x00003030
+	str r1, [r0, #0x2B0]
+	str r1, [r0, #0x2B4]
+	str r1, [r0, #0x2B8]
+	str r1, [r0, #0x2BC]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x540]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x544]
+	str r1, [r0, #0x54C]
+	str r1, [r0, #0x554]
+	str r1, [r0, #0x558]
+	str r1, [r0, #0x294]
+	str r1, [r0, #0x298]
+	str r1, [r0, #0x29C]
+	str r1, [r0, #0x2A0]
+
+	ldr r1, =0x00082030
+	str r1, [r0, #0x2C0]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r1, =0x00008000
+	str r1, [r0, #0x1C]
+	ldr r1, =0xA1390003
+	str r1, [r0, #0x800]
+	ldr r1, =0x084700C7
+	str r1, [r0, #0x85C]
+	ldr r1, =0x00400000
+	str r1, [r0, #0x890]
+
+	ldr r1, =0x3A383C40
+	str r1, [r0, #0x848]
+	ldr r1, =0x242C3020	
+	str r1, [r0, #0x850]
+
+	ldr r1, =0x33333333
+	str r1, [r0, #0x81C]
+	str r1, [r0, #0x820]
+	str r1, [r0, #0x824]
+	str r1, [r0, #0x828]
+
+	ldr r1, =0xf3333333
+	str r1, [r0, #0x82C]
+	str r1, [r0, #0x830]
+	str r1, [r0, #0x834]
+	str r1, [r0, #0x838]
+
+	ldr r1, =0x24922492
+	str r1, [r0, #0x8C0]
+	ldr r1, =0x00000800
+	str r1, [r0, #0x8B8]
+
+	ldr r1, =0x00020052
+	str r1, [r0, #0x004]
+	ldr r1, =0x53574333
+	str r1, [r0, #0x00C]
+	ldr r1, =0x00100A82
+	str r1, [r0, #0x010]
+	ldr r1, =0x00170777
+	str r1, [r0, #0x038]
+	ldr r1, =0x00C70093
+	str r1, [r0, #0x014]
+	ldr r1, =0x00201708
+	str r1, [r0, #0x018]
+	ldr r1, =0x0F9F26D2
+	str r1, [r0, #0x02C]
+	ldr r1, =0x009F0E10
+	str r1, [r0, #0x030]
+	ldr r1, =0x0000004F
+	str r1, [r0, #0x040]
+	ldr r1, =0xC3110000
+	str r1, [r0, #0x000]
+	ldr r1, =0x20000000
+	str r1, [r0, #0x83C]
+
+	ldr r1, =0x00008050
+	str r1, [r0, #0x01C]
+	ldr r1, =0x00008058
+	str r1, [r0, #0x01C]
+	ldr r1, =0x003F8030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x003F8038
+	str r1, [r0, #0x01C]
+	ldr r1, =0xFF0A8030
+	str r1, [r0, #0x01C]
+	ldr r1, =0xFF0A8038
+	str r1, [r0, #0x01C]
+	ldr r1, =0x04028030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x04028038
+	str r1, [r0, #0x01C]
+	ldr r1, =0x82018030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x82018038
+	str r1, [r0, #0x01C]
+	ldr r1, =0x01038030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x01038038
+	str r1, [r0, #0x01C]
+
+	ldr r1, =0x00001800
+	str r1, [r0, #0x020]
+	ldr r1, =0xA1390003
+	str r1, [r0, #0x800]
+	ldr r1, =0x00020052
+	str r1, [r0, #0x004]
+	ldr r1, =0x00011006
+	str r1, [r0, #0x404]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x01C]
+.endm
+.macro imx6_clock_gating
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x068]
+	str r1, [r0, #0x06c]
+	str r1, [r0, #0x070]
+	str r1, [r0, #0x074]
+	str r1, [r0, #0x078]
+	str r1, [r0, #0x07c]
+	str r1, [r0, #0x080]
+.endm
+
+.macro imx6_qos_setting
+.endm
+
+.macro imx6_ddr_setting
+#if defined (CONFIG_LPDDR2)
+	imx6sll_lpddr2_arm2_setting
+#else
+	imx6sll_lpddr3_arm2_setting
+#endif
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx6_plugin.S>
diff --git a/configs/mx6sll_kobo_clara_hd_defconfig b/configs/mx6sll_kobo_clara_hd_defconfig
new file mode 100644
index 0000000000..489057cd98
--- /dev/null
+++ b/configs/mx6sll_kobo_clara_hd_defconfig
@@ -0,0 +1,7 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6sll_kobo_clara_hd/imximage_lpddr2_512M.cfg,LPDDR2_512M"
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6SLL_KOBO_CLARA_HD=y
+CONFIG_CMD_GPIO=y
+CONFIG_SYS_PROMPT="clara-hd # "
+CONFIG_BOOTDELAY=5
diff --git a/include/configs/mx6sll_kobo_clara_hd.h b/include/configs/mx6sll_kobo_clara_hd.h
new file mode 100644
index 0000000000..517c3137f6
--- /dev/null
+++ b/include/configs/mx6sll_kobo_clara_hd.h
@@ -0,0 +1,267 @@
+/*
+ * Copyright 2013-2016 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX6SL EVK board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#undef CONFIG_CMD_SET
+
+
+#define _MX6SLL_
+
+/* uncomment for PLUGIN mode support */
+/* #define CONFIG_USE_PLUGIN */
+
+/* uncomment for SECURE mode support */
+/* #define CONFIG_SECURE_BOOT */
+
+#ifdef CONFIG_SECURE_BOOT
+#ifndef CONFIG_CSF_SIZE
+#define CONFIG_CSF_SIZE 0x4000
+#endif
+#endif
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(16 * SZ_1M)
+
+#define CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_BOARD_LATE_INIT
+
+#define CONFIG_MXC_UART
+#define CONFIG_MXC_UART_BASE		UART1_BASE
+
+/* MMC Configs */
+#define CONFIG_SYS_FSL_ESDHC_ADDR	USDHC2_BASE_ADDR
+#define CONFIG_SYS_FSL_USDHC_NUM	3
+#define CONFIG_SYS_MMC_ENV_DEV		0   /* USDHC2 */
+
+/* I2C Configs */
+#define CONFIG_CMD_I2C
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C_MXC_I2C1		/* enable I2C bus 1 */
+#define CONFIG_SYS_I2C_MXC_I2C2		/* enable I2C bus 2 */
+#define CONFIG_SYS_I2C_MXC_I2C3		/* enable I2C bus 3 */
+#define CONFIG_SYS_I2C_SPEED		  100000
+
+/* PMIC */
+/*
+#define CONFIG_POWER
+#define CONFIG_POWER_I2C
+#define CONFIG_POWER_PFUZE100
+#define CONFIG_POWER_PFUZE100_I2C_ADDR	0x08
+*/
+#define CONFIG_MFG_ENV_SETTINGS \
+	"mfgtool_args=setenv bootargs console=${console},${baudrate} " \
+		"\0" \
+	"initrd_addr=0x83800000\0" \
+	"initrd_high=0xffffffff\0" \
+	"bootcmd_mfg=run mfgtool_args;bootz ${loadaddr} ${initrd_addr} ${fdt_addr};\0" \
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	"epdc_waveform=epdc_splash.bin\0" \
+	"script=boot.scr\0" \
+	"image=zImage\0" \
+	"console=ttymxc0\0" \
+	"fdt_high=0xffffffff\0" \
+	"initrd_high=0xffffffff\0" \
+	"fdt_file=undefined\0" \
+	"fdt_addr=0x83000000\0" \
+	"ip_dyn=yes\0" \
+	"mmcdev="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
+	"mmcpart=1\0" \
+	"mmcautodetect=no\0" \
+	"mmcargs=setenv bootargs console=${console},${baudrate} rootwait rw " \
+		"no_console_suspend root=/dev/mmcblk0p2 rootfstype=ext4 \0" \
+	"loadbootscript=" \
+		"fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"source\0" \
+	"loadimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} zimage\0" \
+	"loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} imx6sll-kobo-clarahd.dtb\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"load_ntxkernel; " \
+		"load_ntxdtb; " \
+		"run mmcargs; " \
+		"if run loadfdt; then " \
+			"if run loadimage; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"echo WARN: Cannot load the image; " \
+			"fi; " \
+		"else " \
+			"echo WARN: Cannot load the DT; " \
+		"fi;\0" \
+
+#ifdef CONFIG_MFG
+	#define CONFIG_BOOTCOMMAND \
+	   "mmc dev ${mmcdev};" \
+	   "run bootcmd_mfg; " \
+
+#else
+	#define CONFIG_BOOTCOMMAND \
+	   "mmc dev ${mmcdev};" \
+	   "if run loadimage; then " \
+	    "run mmcboot; " \
+	   "fi; " \
+
+#endif
+
+/* Miscellaneous configurable options */
+#define CONFIG_CMD_MEMTEST
+#define CONFIG_SYS_MEMTEST_START	0x80000000
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START + SZ_128M)
+
+#define CONFIG_STACKSIZE		SZ_128K
+
+/* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS		1
+#define PHYS_SDRAM			MMDC0_ARB_BASE_ADDR
+#ifdef CONFIG_LPDDR2
+#define PHYS_SDRAM_SIZE			SZ_256M
+#elif defined CONFIG_LPDDR2_512M
+#define PHYS_SDRAM_SIZE			SZ_512M
+#else
+#define PHYS_SDRAM_SIZE			SZ_2G
+#endif
+
+#define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM
+#define CONFIG_SYS_INIT_RAM_ADDR	IRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE	IRAM_SIZE
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+/* Environment organization */
+#define CONFIG_ENV_SIZE			SZ_8K
+#define CONFIG_SYS_MMC_ENV_PART		0   /* user partition */
+#define CONFIG_MMCROOT			"/dev/mmcblk0p2"  /* USDHC1 */
+
+/* Put config in FAT for ease of building/modifying. */
+#define CONFIG_ENV_IS_IN_FAT
+#if 0
+#ifdef CONFIG_SYS_BOOT_SPINOR
+#define CONFIG_SYS_USE_SPINOR
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#else
+#define CONFIG_ENV_IS_IN_MMC
+/* #define CONFIG_VIDEO */
+#endif
+#endif // 0
+
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_ENV_OFFSET		(12 * SZ_64K)
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_OFFSET		(768 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#define CONFIG_ENV_SPI_BUS		CONFIG_SF_DEFAULT_BUS
+#define CONFIG_ENV_SPI_CS		CONFIG_SF_DEFAULT_CS
+#define CONFIG_ENV_SPI_MODE		CONFIG_SF_DEFAULT_MODE
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
+#endif
+
+#if defined(CONFIG_ENV_IS_IN_FAT)
+#define FAT_ENV_INTERFACE               "mmc"
+#define FAT_ENV_DEVICE_AND_PART         "0:1"
+#define FAT_ENV_FILE                    "uboot.env"
+#define CONFIG_FAT_WRITE
+#endif // CONFIG_ENV_IS_IN_FAT
+
+/* Network */
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+
+/* USB Configs */
+#define CONFIG_CMD_USB
+#ifdef CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX6
+#define CONFIG_USB_STORAGE
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_MXC_USB_PORTSC		(PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS		0
+#define CONFIG_USB_MAX_CONTROLLER_COUNT	2
+#endif
+
+#define CONFIG_IMX_THERMAL
+
+#define CONFIG_IOMUX_LPSR
+
+#ifdef CONFIG_SYS_USE_SPINOR
+#define CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_STMICRO
+#define CONFIG_MXC_SPI
+#define CONFIG_SF_DEFAULT_BUS  0
+#define CONFIG_SF_DEFAULT_SPEED 20000000
+#define CONFIG_SF_DEFAULT_MODE (SPI_MODE_0)
+#define CONFIG_SF_DEFAULT_CS   0
+#endif
+
+#ifdef CONFIG_VIDEO
+#define CONFIG_CFB_CONSOLE
+#define CONFIG_VIDEO_MXS
+#define CONFIG_VIDEO_LOGO
+#define CONFIG_VIDEO_SW_CURSOR
+#define CONFIG_VGA_AS_SINGLE_DEVICE
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+#define CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define CONFIG_CMD_BMP
+#define CONFIG_BMP_16BPP
+#define CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_VIDEO_BMP_LOGO
+#define CONFIG_IMX_VIDEO_SKIP
+#endif
+
+
+/*#define CONFIG_MXC_EPDC  1*/
+
+/*
+ * EPDC SPLASH SCREEN Configs
+ */
+#ifdef CONFIG_MXC_EPDC
+	/*
+	 * Framebuffer and LCD
+	 */
+	#define CONFIG_SPLASH_SCREEN
+	#define CONFIG_CMD_BMP
+	#define CONFIG_LCD
+	#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+#ifdef CONFIG_MXC_EPDC
+	#undef LCD_TEST_PATTERN
+	#define LCD_BPP					LCD_MONOCHROME
+
+	#define CONFIG_WAVEFORM_BUF_SIZE		0x200000
+#endif
+#endif /* CONFIG_SPLASH_SCREEN */
+
+/*
+#define CONFIG_SC_TIMER_CLK
+#define CONFIG_SYSCOUNTER_TIMER
+*/
+
+#define CONFIG_GPT_TIMER
+
+#define CONFIG_CMD_DATE  
+#define CONFIG_NTX_SW
+#define CONFIG_RESERVED_TOPRAMSIZE		(8*1024*1024)
+
+#define CONFIG_ANDROID_SUPPORT		1
+#if defined(CONFIG_ANDROID_SUPPORT)
+#include "mx6sll_ntx_android.h"
+#endif 
+
+#endif				/* __CONFIG_H */
